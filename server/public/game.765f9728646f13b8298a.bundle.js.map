{"version":3,"file":"game.765f9728646f13b8298a.bundle.js","mappings":"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CA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,CAAC,YAAY,qDAAC,OAAO;AAClD;AACA;AACA;AACA;AACA,iCAAiC,CAAC,YAAY,qDAAC,WAAW;AAC1D;AACA;AACA;;AAEA,6BAA6B,CAAC;;AAE9B;AACA,2BAA2B,CAAC;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,CAAC;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb,SAAS;;AAET,QAAQ,CAAC;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,CAAC;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,CAAC,YAAY,YAAY;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;;;;ACvMe;AACf;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;ACpD2D;AAC7B;AACmB;AACjB;AACA;AACkB;AAI5B;AACY;AACE;AACN;AAC4B;;AAE1D,iBAAiB,2EAA8B;;;AAGhC;AACf;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;;AAEA,2CAA2C,gDAAO,CAAC,iEAAgB;AACnE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B,mBAAmB,+CAAM;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qBAAqB,qDAAM;AAC3B;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,0BAA0B,+CAAU,CAAC,+CAAM;AAC3C;;AAEA,wBAAwB,UAAU;AAClC,4BAA4B,UAAU;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,aAAa,gDAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA,YAAY,gDAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,gDAAO;AACf;;AAEA;AACA;;AAEA,YAAY,+CAAM;AAClB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,+DAAgB;;AAE5C;AACA;;AAEA,mBAAmB,+CAAM,KAAK,gDAAO,kCAAkC,+CAAM;AAC7E,mBAAmB,+CAAM,KAAK,gDAAO,mCAAmC,+CAAM;;AAE9E,mBAAmB,+CAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,8CAAS;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,oBAAoB,CAAC,UAAU,KAAK;AACpC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,uDAAS;;AAElD;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd,oBAAoB,+CAAM;AAC1B;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D,QAAQ;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,gDAAO;;AAExB;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,+CAAM;AACtB,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,mBAAmB,gDAAO;;AAE1B,0BAA0B,8DAAiB;AAC3C;;AAEA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,gDAAO;;AAE1B,+BAA+B,8DAAiB;AAChD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,sDAAS;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,+CAAM;AACtC,gBAAgB,+CAAM;;AAEtB;AACA;;AAEA,gBAAgB,+CAAM;AACtB,gBAAgB,+CAAM,eAAe,+CAAM,eAAe,+CAAM;;AAEhE;AACA,oBAAoB,+CAAM,gBAAgB,+CAAM,KAAK,+CAAM,gBAAgB,+CAAM;AACjF,oBAAoB,gDAAO;AAC3B;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,0DAAK;AACzB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,8CAAK;AAC9C;;AAEA;AACA;;AAEA,QAAQ,0DAAK;AACb;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,C;;;;;;;;;;;;;;;;;;;;;;AChXA;AACA;;AAE4B;AACW;AACM;;AAE7C;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B;AAC3B;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,CAAC;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;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;;;;;;;;;;;;;;;;;ACnHO;AACA;;AAEP;;AAEO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D,sBAAsB;AACpF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CwD;AACA;AACxB;AACF;AACgG;AAChE;AACnB;AACU;AACP;AACM;AACD;AACuB;AAChC;;AAEQ;AACE;AACG;AACK;AACH;AACjB;AACI;AACR;;AAE7B;AACP,IAAI,qDAAU;AACd,IAAI,uDAAY;AAChB,IAAI,sDAAW;AACf,IAAI,+CAAQ;AACZ,IAAI,qEAAmB;AACvB;;AAEO;AACP,IAAI,iEAAsB;;AAE1B,IAAI,gEAAqB;;AAEzB,IAAI,kEAAuB;AAC3B;AACA,IAAI,kEAAqB;AACzB,IAAI,wDAAW;AACf,IAAI,0DAAc;AAClB,IAAI,2DAAoB;AACxB,IAAI,yDAAc;AAClB,IAAI,+CAAM;AACV,IAAI,2DAAe;AACnB,IAAI,2DAAgB;AACpB,IAAI,2DAAe;AACnB;AACA;AACA,IAAI,gEAAgB;;AAEpB,IAAI,qEAAmB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,CAAC;AACT,sBAAsB,CAAC;AACvB;AACA;AACA;AACA,cAAc;AACd;AACA,+BAA+B,CAAC;AAChC;AACA,SAAS;AACT;;AAEA;AACA,QAAQ,CAAC;AACT,wBAAwB,CAAC;AACzB;;AAEA,YAAY,CAAC;AACb,YAAY,gDAAO;AACnB,SAAS;AACT;AACA;;AAEA;AACA,QAAQ,0DAAK;AACb;AACA;AACA,IAAI,0DAAK;;AAET,qBAAqB,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mDAAmD,IAAI;AACvD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA,QAAQ,8CAAQ,KAAK,8DAAY;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B,gDAAQ;;AAErC;;AAEA,0BAA0B,gDAAQ;;AAElC;AACA;AACA,6CAA6C,gDAAQ;;AAErD;AACA;AACA,0BAA0B,sDAAQ;AAClC;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,gCAAgC,gDAAO;;AAEvC,IAAI,gDAAO;AACX,iCAAiC,gDAAO;;AAExC;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,uBAAuB;AACpE;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET,kCAAkC,YAAY;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;;AAGA,mBAAmB,8DAAY;AAC/B,mBAAmB,8DAAY;AAC/B,sBAAsB,8DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAU;AAC5B,mBAAmB,gEAAW;AAC9B;AACA;AACA,KAAK;;AAEL;AACA;AACA,kBAAkB,sEAAQ;AAC1B,mBAAmB,0EAAS;AAC5B;AACA;AACA,KAAK;;AAEL;AACA,uBAAuB,uEAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAkB;AAC3C,yBAAyB,uEAAkB;;AAE3C;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,gDAAO,oBAAoB,0CAAE;AACjC,oBAAoB,gDAAQ;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,sDAAQ;AACtC;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,YAAY,+CAAM;AAClB;AACA,KAAK;;AAEL;AACA,yBAAyB,+CAAM;AAC/B,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,gDAAO;AACf;;AAEA;AACA;;AAEA,QAAQ,gDAAO;AACf;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtcyB;;AAEK;AACE;AACU;AACR;AACM;AACI;AACJ;AACwB;;AAE7B;AAC4B;AACjC;AACG;AACmB;AACX;AACkB;AACd;AACA;AACJ;AACY;;AAErD;AACA,IAAI,6CAAc;AAClB,UAAU,6CAAe;;AAEzB;AACA,QAAQ,qDAAU;AAClB,QAAQ,qDAAU;;AAElB,QAAQ,mDAAQ;AAChB,QAAQ,mDAAQ;;AAEhB,sBAAsB,mDAAQ;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,gDAAO;AACpB,YAAY,gEAAmB;AAC/B;;AAEA,QAAQ,2DAAc;AACtB,QAAQ,uDAAe;AACvB;;;AAGA;AACA,yBAAyB,qDAAU;AACnC;AACA;AACA;AACA;AACA;;AAEA,IAAI,gDAAM;AACV,IAAI,wDAAW;;AAEf,gBAAgB,qDAAU;AAC1B;;AAEA;AACA,uBAAuB,+CAAM;AAC7B,IAAI,gDAAO;;AAEX,6BAA6B,qDAAY;AACzC,IAAI,gDAAO;;AAEX,2CAA2C,iDAAQ;AACnD,IAAI,gDAAO;;AAEX,2BAA2B,iDAAU;AACrC,IAAI,gDAAO;;AAEX,IAAI,gDAAO,mBAAmB,oDAAW;;AAEzC,IAAI,gDAAO,UAAU,+CAAM;;AAE3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA,iCAAiC;AACjC;AACA,QAAQ,CAAC;AACT,KAAK;AACL;AACA,QAAQ,CAAC;AACT,KAAK;;AAEL,qBAAqB,gDAAO;;AAE5B;AACA,IAAI,+CAAiB;AACrB,YAAY,+CAAiB;AAC7B,YAAY,2DAAK;;AAEjB,sBAAsB,2CAAK;AAC3B;AACA,sBAAsB,CAAC;AACvB,kCAAkC,YAAY,kBAAkB;AAChE,sBAAsB,sDAAS,YAAY;AAC3C,qBAAqB,sDAAS;AAC9B,sBAAsB,sDAAS,yEAAyE;AACxG,wBAAwB,sDAAS,gEAAgE;AACjG,4CAA4C,IAAI,sDAAS,wEAAwE;AACjI;AACA;;AAEA,QAAQ,CAAC;AACT;AACA,YAAY,2DAAK;AACjB,SAAS;AACT,KAAK;;AAEL,IAAI,iDAAQ;AACZ,IAAI,iDAAa;AACjB,IAAI,kDAAU;AACd,IAAI,6DAAqB;AACzB;AACA,OAAO,gDAAO;AACd,QAAQ,2DAAa;AACrB,CAAC,I;;;;;;;;;;;;;;;;;;ACvIiC;AACO;;AAEzC;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA,UAAU,4CAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;;AAET;AACA,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB,iBAAiB,4CAAI;AACrB,gBAAgB,CAAC;AACjB;AACA,KAAK;;AAEL;AACA,+CAA+C,4CAAI;AACnD,KAAK;;AAEL;AACA,+BAA+B,sDAAU;AACzC;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/D8B;AACM;AACM;AACV;AACV;AAC4C;AACvB;AACE;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,iEAAY;AAClC,0BAA0B,iEAAY;AACtC,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;;AAEf,QAAQ,CAAC;AACT;AACA,YAAY,CAAC;AACb;;AAEA,QAAQ,0DAAK;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;;AAEf,QAAQ,CAAC;AACT;AACA,YAAY,CAAC;AACb;;AAEA,QAAQ,0DAAK;AACb,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,0BAA0B,+CAAM;AAChC,KAAK;AACL;AACA;AACA,kBAAkB,0DAAK;AACvB;;AAEO;AACP,UAAU,2CAAE;;AAEZ;AACA,QAAQ,2CAAE;AACV,QAAQ,mDAAS;AACjB,QAAQ,mDAAS;;AAEjB,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC,mBAAmB,2CAAE;AAC9B,QAAQ,CAAC;AACT,MAAM;AACN,QAAQ,mDAAS;AACjB,QAAQ,mDAAS,KAAK,qDAAC;;AAEvB;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;;AAEA;AACA,sBAAsB,6CAAQ;;AAE9B,QAAQ,8CAAM,CAAC,2CAAE;AACjB,qBAAqB,8CAAM,CAAC,2CAAE,WAAW,6CAAQ;AACjD;;AAEO;AACP;;AAEA;AACA;AACA,oBAAoB,gDAAO;AAC3B,2BAA2B,gDAAO;;AAElC;AACA,wBAAwB,mBAAmB;AAC3C,6BAA6B,gDAAO;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,gDAAO;AACf,KAAK;AACL;AACA;;AAEA;AACA;AACA,sCAAsC,gDAAO;AAC7C,SAAS;AACT;AACA,IAAI,gDAAO;AACX;;AAEO;AACP,mBAAmB,gDAAO;AAC1B,sBAAsB,gDAAO;;AAE7B,sBAAsB,gDAAO;AAC7B;;AAEA,2CAA2C,2CAAE,SAAS,4CAAI,aAAa,gDAAO;AAC9E;AACA,sCAAsC,gDAAO;;AAE7C;AACA;AACA;AACA;;AAEA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;;AAEf,QAAQ,gDAAO;;AAEf,QAAQ,gDAAO;AACf,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,SAAS;AACT,MAAM;AACN,2BAA2B,2CAAE,QAAQ,4CAAI;AACzC,YAAY,MAAM,OAAO,qDAAC,2BAA2B,qDAAC;AACtD;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEO;AACP;AACA,IAAI,gDAAO;;AAEX,IAAI,gDAAO;;AAEX,IAAI,CAAC;AACL;;AAEO;AACP,YAAY,CAAC,2BAA2B,CAAC;AACzC;;AAEO;AACP;AACA,IAAI,CAAC;AACL;AACA,QAAQ,CAAC;AACT;;AAEA;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA,CAAC;;AAED,iEAAe,MAAM,E;;;;;;;;;;;;;;;;;;AC9NrB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtC8B;AAIT;;AAErB;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED,CAMuB;AACsD;AAC7C;AACO;AACoB;AACrC;AACmB;AACG;AACd;;AAE9B;;AAEO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,QAAQ,gDAAK,KAAK,yCAAE;AACpB;;AAEA;AACA,eAAe,kDAAQ;AACvB;;AAEA;AACA,gBAAgB,mDAAS;AACzB;;AAEA;AACA,QAAQ,mDAAS;AACjB;;AAEA;AACA;;AAEA;;AAEA,6BAA6B,sEAAkB;AAC/C,qBAAqB,+CAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gDAAM;AAChC,0BAA0B,gDAAM;;AAEhC,QAAQ,gDAAO;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,KAAK;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV,iCAAiC,sDAAS;AAC1C;;AAEA;;AAEA,QAAQ,gDAAO;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,mBAAmB,iEAAY;AAC/B,IAAI,kDAAQ;;AAEZ,iBAAiB,iEAAY;AAC7B,IAAI,gDAAM;;AAEV,iBAAiB,iEAAY;AAC7B,IAAI,gDAAM;;AAEV,oBAAoB,iEAAY;AAChC,IAAI,mDAAS;AACb;;AAEA;AACA,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT;;AAEO;AACP;AACA;AACA;;AAEO;AACP,IAAI,kDAAQ;AACZ,IAAI,gDAAM;AACV,IAAI,gDAAM;AACV,IAAI,mDAAS;;AAEb;AACA;;AAEO;AACP,IAAI,CAAC;AACL;;AAEA;AACA;AACA;;AAEA,uBAAuB,sEAAkB;;AAEzC;AACA;AACA;;AAEA,6BAA6B,sEAAkB;AAC/C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,YAAY,gDAAM;AAClB,YAAY,gDAAM;;AAElB;;AAEA;;AAEA;AACA;AACA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT,YAAY,CAAC;AACb,SAAS;AACT,KAAK;AACL;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA,IAAI,kDAAQ;AACZ,IAAI,gDAAM;AACV,IAAI,gDAAM;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP,mBAAmB,kDAAQ;AAC3B,cAAc,gDAAM;AACpB,cAAc,gDAAM;;AAEpB;;AAEA,yBAAyB,OAAO,SAAS,2BAA2B,OAAO,EAAE,OAAO,EAAE;;AAEtF,IAAI,mDAAS;AACb,IAAI,mDAAS;;AAEb;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,mDAAS;AACb;;AAEO;AACP,SAAS,2CAAE;AACX,eAAe,MAAM;AACrB;AACA,uBAAuB,sDAAU;;AAEjC;AACA;;AAEA,IAAI,yDAAe;AACnB;;AAEO;AACP,oBAAoB,CAAC;;AAErB;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,sEAAkB;;AAE1C;AACA;;AAEA,QAAQ,gDAAO;AACf;;AAEA;AACA;;AAEA,yBAAyB,sEAAkB;AAC3C;AACA;;AAEA;;AAEA;AACA;;AAEA,sBAAsB,uCAAuC;;AAE7D,QAAQ,gDAAM;AACd,QAAQ,gDAAM;;AAEd;;AAEA;;AAEA;AACA;;AAEA;AACA,QAAQ,gDAAO;AACf;;AAEA,IAAI,gDAAO;AACX,IAAI,gDAAO;;AAEX;AACA;AACA;AACA;AACA;;AAEA,YAAY,gDAAO;AACnB;AACA,UAAU;AACV;AACA;AACA,YAAY,gDAAO;AACnB;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAO;AAC3B,uBAAuB,gDAAM,QAAQ,gDAAM;;AAE3C,QAAQ,gDAAO,wBAAwB,gDAAO;AAC9C,QAAQ,gDAAM;AACd;;AAEA;AACA,QAAQ,gDAAO;AACf,SAAS,gDAAM,QAAQ,gDAAM;AAC7B;AACA;;;;;AAKA,iEAAe,QAAQ,E;;;;;;;;;;;;;;;;;;AChXyB;AACrB;AAC3B;AACA;AACO,qBAAqB,6CAAI,iCAAiC;AACjE;AACA,QAAQ,+CAAM;AACd;AACA,kBAAkB,+CAAM;AACxB,IAAI,oDAAW,CAAC,+CAAM;AACtB,CAAC;AACM,qBAAqB,6CAAI,gCAAgC;AAChE;AACA,OAAO,+CAAM;AACb;AACA,kBAAkB,+CAAM;AACxB,IAAI,oDAAW,CAAC,+CAAM;AACtB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjB4G;AACnD;AAC3B;AACQ;AACH;AACI;AACP;AACV;AACqC;AACjC;AACmD;AACzC;AACrC;AACA;AACO,sBAAsB,6CAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAa;AACrB;AACA;AACA,iBAAiB,8CAAM;AACvB,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB,gBAAgB,gDAAO;AACvB;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,oDAAQ;AACxB,SAAS;AACT;AACA;AACA,sBAAsB,yCAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO,6CAA6C,+CAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC,sBAAsB,wDAAY;AAClC;AACA,YAAY,mDAAU,CAAC,+CAAM,IAAI,+CAAM,IAAI,wDAAY;AACvD;AACA;AACA;AACA,gCAAgC,+CAAM;AACtC;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAM;AACnB,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE,GAAG,EAAE;AAC9B,wBAAwB,wDAAY;AACpC;AACA,sBAAsB,oDAAQ,sBAAsB,sDAAU;AAC9D,iEAAiE,2CAAE,QAAQ,4CAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAS;AACrB;AACA;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAO;AAC7B;AACA;AACA;AACA,UAAU;AACV,qBAAqB,uEAAkB;AACvC,UAAU;AACV,sBAAsB,+CAAM,IAAI,+CAAM;AACtC;AACA;AACA;AACA,mBAAmB,sDAAM;AACzB;AACA;AACA;AACA,YAAY,+CAAM;AAClB,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wDAAY,UAAU;AAC1D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAM;AACrB;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA,YAAY,mDAAU;AACtB;AACA;AACA,YAAY,oDAAW;AACvB;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAU;AACtC;AACA,iCAAiC,uEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gDAAgD,kEAAW;AAC3D,iEAAe,OAAO,E;;;;;;;;;;;;;;;;;;ACnOS;AACJ;AAC3B;AACO,sBAAsB,6CAAI;AACjC,mBAAmB,+CAAM,iBAAiB,+CAAM;AAChD;AACA,iEAAe,SAAS,E;;;;;;;;;;;;;;;;;;;;;;;;;;ACNO;AACgC;AAC3B;AACc;AACjB;AACD;AACD;AACJ;AACiB;AACc;AACP;AACnD;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd,QAAQ,+CAAM;AACd,QAAQ,oDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAM,IAAI,+CAAM;AAChD,cAAc;AACd,yBAAyB,+CAAM;AAC/B,yBAAyB,+CAAM;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,QAAQ,+CAAM;AAC5C;AACA;AACA,cAAc;AACd,uBAAuB,+CAAM;AAC7B,uBAAuB,+CAAM;AAC7B;AACA;AACA;AACA;AACA,YAAY,oDAAU;AACtB;AACA,YAAY,mDAAQ;AACpB;AACA,YAAY,gDAAO;AACnB;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA;AACA,YAAY,+CAAM;AAClB,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAkB;AACpD;AACA,gCAAgC,wBAAwB;AACxD;AACA,kCAAkC,sEAAkB;AACpD;AACA;AACA;AACA,cAAc;AACd,iCAAiC,sEAAkB;AACnD,iCAAiC,sEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAE;AACnB,QAAQ,gDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAU;AAC5C;AACA,kCAAkC,gDAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAkB;AACxD;AACA;AACA;AACA;AACA,wCAAwC,gDAAO;AAC/C;AACA;AACA,kCAAkC,gDAAO;AACzC,gCAAgC,8CAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAK;AACjB;AACA;AACA;AACA,iDAAiD,4CAAI;AACrD;AACA,iEAAe,IAAI,E;;;;;;;;;;;;;;;;;;;AC1OnB;AACwD;AACvB;AACc;AACpB;AAC3B;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kCAAkC,gDAAO;AACzC;AACA;AACA,oBAAoB,+CAAM,iBAAiB,+CAAM;AACjD,oBAAoB,+CAAM,UAAU,+CAAM,eAAe,+CAAM;AAC/D;AACA,qBAAqB,+CAAM;AAC3B,qBAAqB,+CAAM;AAC3B;AACA,kCAAkC,+CAAM;AACxC;AACA,gBAAgB,mDAAU;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,yCAAyC,iEAAU;AACnD,iEAAe,KAAK,E;;;;;;;;;;;;;;;;;;;;;;;;;ACvGsD;AACZ;AAC/B;AACQ;AACC;AACP;AACc;AACpB;AACgB;AACmC;AAC9E;AACA;AACA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAQ;AACpB;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAkB;AACvC,YAAY,wDAAY,qBAAqB,uDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+CAAM,IAAI,+CAAM;AAC7B;AACA;AACA,yBAAyB,+CAAM;AAC/B,+BAA+B,+CAAM;AACrC,0BAA0B,oDAAQ,CAAC,+CAAM,IAAI,+CAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAkB;AACvC,YAAY,wDAAY,qBAAqB,uDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAQ,CAAC,+CAAM,IAAI,+CAAM;AACnD;AACA,qBAAqB,yCAAE;AACvB,QAAQ,gDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+CAAM,IAAI,+CAAM;AACjC;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B,qBAAqB,+CAAM;AAC3B;AACA,6BAA6B,+CAAM;AACnC,mCAAmC,+CAAM;AACzC,8BAA8B,oDAAQ,CAAC,+CAAM,IAAI,+CAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAY;AACpC,0BAA0B,oDAAQ;AAClC;AACA;AACA,gFAAgF,uDAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO,WAAW,gDAAO;AACzC,0BAA0B;AAC1B;AACA;AACA,gBAAgB,+CAAM,gBAAgB,+CAAM;AAC5C;AACA;AACA,gBAAgB,qDAAS;AACzB;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA,8BAA8B,+CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAY;AAC1C,kCAAkC,+CAAU;AAC5C;AACA,mCAAmC,sEAAkB;AACrD,2CAA2C,+CAAM,OAAO,+CAAM;AAC9D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA,iBAAiB,+CAAM;AACvB;AACA;AACA;AACA,wBAAwB,wDAAY;AACpC,0BAA0B,oDAAQ;AAClC;AACA,qEAAqE,uDAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAQ;AACpB;AACA;AACA;AACA;AACA,qDAAqD,oEAAa;AAClE,iEAAe,SAAS,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClOa;AACqB;AACF;AACI;AACA;AAC3B;AACF;AACJ;AAC4B;AACuB;AACtC;AACQ;AACM;AACvB;AACQ;AACO;AACA;AACO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAQ;AAC/B;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAK;AACpC,sBAAsB,2DAAK;AAC3B,wBAAwB,2DAAK;AAC7B,iCAAiC,2DAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAU,CAAC,sDAAC;AACxC,qBAAqB,CAAC;AACtB;AACA;AACA,iCAAiC,iBAAiB;AAClD,sBAAsB,sDAAC;AACvB;AACA,iCAAiC,oBAAoB;AACrD,sBAAsB,sDAAC;AACvB;AACA;AACA,cAAc,2DAAU,CAAC,sDAAC,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2DAAU,CAAC,sDAAC,YAAY;AACpE,8CAA8C,2DAAU,CAAC,sDAAC,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAM;AACd;AACA,4CAA4C,sEAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA,6CAA6C,sEAAkB;AAC/D;AACA;AACA;AACA;AACA,UAAU;AACV,kCAAkC,+CAAM,IAAI,+CAAM;AAClD,iCAAiC,gDAAO,4BAA4B,+CAAM,IAAI,+CAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+CAAM,oCAAoC,+CAAM;AAC9F;AACA,kCAAkC,+CAAM,IAAI,+CAAM;AAClD;AACA;AACA;AACA;AACA,iCAAiC,gDAAO,4BAA4B,+CAAM,IAAI,+CAAM;AACpF;AACA,UAAU;AACV,+CAA+C,+CAAM,qCAAqC,+CAAM;AAChG;AACA,+BAA+B,+CAAM,IAAI,+CAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAE;AACxB;AACA,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,kCAAkC,sEAAkB;AACpD;AACA;AACA;AACA,sEAAsE,gDAAM,6BAA6B,gDAAM;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C,8BAA8B,sEAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAQ;AAC3B,SAAS;AACT,QAAQ,gDAAK;AACb;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAAU,CAAC,+CAAM;AAC7C,6BAA6B,+CAAU,CAAC,+CAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAS,CAAC,+CAAM;AAC5C,6BAA6B,8CAAS,CAAC,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA,kDAAkD,mEAAQ;AAC1D,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;;;;;ACjrBO;AACO;AACY;AACvB;AACmD;AAClB;AACnB;AACzC;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iEAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA,qBAAqB,sEAAkB,6BAA6B,sEAAkB;AACtF;AACA,cAAc,gBAAgB;AAC9B,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,kDAAkD,qDAAQ;AAC1D;AACA;AACA;AACA,YAAY,8CAAS;AACrB,iBAAiB,8CAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,oBAAoB,8CAAS;AAC7B;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,oBAAoB,8CAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yCAAE;AAC5B,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAQ;AAC3B;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpHnB;AACgC;AACJ;AACQ;AACa;AACvB;AACuB;AACb;AACsB;AAC9B;AAC2B;AAC7B;AACA;AACE;AACO;AAC0B;AAC/B;AACmB;AACb;AACV;AACc;AACd;AACM;AACc;AACZ;AAClC;AACA;AACA;AACA;AACA,iEAAe;AACf,WAAW;AACX,SAAS;AACT,aAAa;AACb,WAAW,4DAAY;AACvB,QAAQ;AACR,YAAY,4DAAU;AACtB,aAAa;AACb,YAAY,4DAAU,2DAAS;AAC/B,SAAS;AACT,aAAa,kEAAc;AAC3B,QAAQ;AACR,QAAQ;AACR,SAAS;AACT,WAAW;AACX,eAAe,yEAAa;AAC5B,UAAU;AACV,YAAY,6DAAU;AACtB,aAAa;AACb,QAAQ;AACR,eAAe;AACf,QAAQ;AACR,aAAa;AACb,kBAAkB;AAClB,YAAY;AACZ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtD0F;AACvC;AACrB;AACoB;AACf;AACc;AACjB;AACV;AACwB;AACpB;AAC+B;AACL;AAChB;AACrC;AACA;AACA,mBAAmB,6CAAI;AACvB;AACA;AACA;AACA,qCAAqC,kEAAY;AACjD;AACA,QAAQ,yDAAa;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAM,IAAI,+CAAM;AAC3C;AACA,0CAA0C,+CAAM,QAAQ,+CAAM;AAC9D;AACA;AACA,gBAAgB,+CAAM;AACtB,kCAAkC,gDAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA,gBAAgB,+CAAM,iBAAiB,+CAAM;AAC7C,sBAAsB,mDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAQ;AAC9B,yBAAyB,yCAAE;AAC3B;AACA;AACA;AACA;AACA,sCAAsC,wDAAY;AAClD,wCAAwC,+CAAU;AAClD;AACA,iDAAiD,uEAAkB;AACnE,uDAAuD,+CAAM,OAAO,+CAAM;AAC1E,qBAAqB;AACrB;AACA;AACA;AACA,oCAAoC,+CAAM;AAC1C;AACA,wCAAwC,uEAAkB;AAC1D,sCAAsC,uEAAkB;AACxD;AACA;AACA;AACA,4DAA4D,+CAAM;AAClE,0DAA0D,+CAAM;AAChE;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,gDAAgD;AAChD;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAM;AACzC,mCAAmC,+CAAM;AACzC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,gDAAK;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,yBAAyB,gDAAO;AAChC;AACA;AACA,sBAAsB,+CAAU;AAChC;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAM;AACrC;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM,IAAI,+CAAM;AACzD;AACA;AACA;AACA,qCAAqC,2CAAE,QAAQ,4CAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oDAAQ;AACpB;AACA;AACA;AACA;AACA,gBAAgB,+CAAM,iBAAiB,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAY;AACxC;AACA;AACA,qBAAqB,uDAAW,UAAU,oDAAQ;AAClD;AACA,qBAAqB,+CAAM;AAC3B;AACA,gBAAgB,mDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,2CAA2C,+DAAQ;AACnD,iEAAe,IAAI,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3QkB;AACuB;AACC;AACH;AACS;AACjB;AACjB;AACF;AACI;AACR;AACmB;AACF;AACO;AACO;AACE;AACpB;AACsB;AAC9D;AACA;AACO;AACP;AACA;AACA;AACA,gCAAgC,6CAAI;AACpC;AACA;AACA;AACA;AACA,QAAQ,oEAA2B;AACnC,8CAA8C,kEAAY;AAC1D;AACA,gBAAgB,gDAAK,KAAK,yCAAE;AAC5B,yBAAyB,iDAAQ,4BAA4B,+CAAQ;AACrE;AACA;AACA;AACA,sBAAsB;AACtB;AACA,2BAA2B,+CAAQ;AACnC,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8CAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAO;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gEAAiB;AACnD;AACA,gBAAgB,MAAM,SAAS,sDAAC;AAChC;AACA;AACA;AACA;AACA,UAAU;AACV,gBAAgB,8CAAM;AACtB;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAQ;AAC5B,0BAA0B,iDAAQ;AAClC,0BAA0B,iDAAQ;AAClC;AACA,wBAAwB,iDAAQ,eAAe,iDAAQ;AACvD,sBAAsB,iDAAQ;AAC9B,sBAAsB,iDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iDAAQ;AACtC,8BAA8B,iDAAQ;AACtC;AACA;AACA,aAAa,iDAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA,QAAQ,CAAC,sCAAsC,+DAAgB,CAAC;AAChE;AACA;AACA,uBAAuB,gEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA,YAAY,CAAC,QAAQ,GAAG;AACxB;AACA;AACA;AACA;AACA,QAAQ,2DAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,iDAAQ;AAChG;AACA;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAY,QAAQ,uDAAY;AAC/D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qDAAU,QAAQ,qDAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB,EAAE,6DAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAQ;AAChB,QAAQ,gDAAO;AACf;AACA;AACA,QAAQ,iDAAQ;AAChB,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,iDAAiD,sEAAU,CAAC;AAC5D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,6DAA6D,kEAAW;AACxE,iEAAe,SAAS,E;;;;;;;;;;;;;;;;;;;;;;;;;;AC7biD;AACrC;AACgB;AACrB;AACQ;AACC;AACP;AACF;AACJ;AACqB;AAC8B;AAC9E;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAM;AACnB,0BAA0B,yCAAE;AAC5B;AACA,YAAY,gDAAK;AACjB;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAa;AACrB;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB,+CAAM;AAC3B;AACA,sBAAsB,qDAAS;AAC/B;AACA;AACA,gBAAgB,+CAAM;AACtB,6BAA6B,uEAAkB,CAAC,+CAAM,IAAI,+CAAM;AAChE,kCAAkC,+CAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,oBAAoB,+CAAM;AAC1B;AACA;AACA;AACA,+BAA+B,+CAAM;AACrC,+BAA+B,uEAAkB,CAAC,+CAAM,oBAAoB,+CAAM;AAClF,8BAA8B,gDAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAc,gBAAgB,0BAA0B;AAChE;AACA;AACA,iCAAiC,uEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAc,gBAAgB,yBAAyB;AAC/D;AACA;AACA;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA,YAAY,kDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+CAAM;AAC3C,qCAAqC,+CAAM;AAC3C;AACA,YAAY,oDAAQ;AACpB;AACA;AACA;AACA,8BAA8B,+CAAM,IAAI,+CAAM;AAC9C;AACA;AACA;AACA;AACA,aAAa,8CAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM,uBAAuB,+CAAM,+CAA+C,+CAAM;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+DAAQ;AAChD,iEAAe,KAAK,E;;;;;;;;;;;;;;;;;;;ACrJkC;AACvB;AACJ;AAC3B;AACA;AACO,qBAAqB,6CAAI;AAChC;AACA,qBAAqB,mDAAc;AACnC,qBAAqB,mDAAc,cAAc,8CAAS;AAC1D;AACA,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI,+CAAM;AACV,CAAC;AACM,qBAAqB,6CAAI;AAChC;AACA;AACA;AACA;AACA,qBAAqB,mDAAc;AACnC,qBAAqB,mDAAc,cAAc,8CAAS;AAC1D;AACA,gBAAgB,+CAAM;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI,+CAAM;AACV,CAAC;;;;;;;;;;;;;;;;;;;ACjCoD;AAC1B;AACmB;AAC9C;AACA;AACA,2BAA2B,6CAAI;AAC/B;AACA,wBAAwB,6CAAQ;AAChC;AACA;AACA,qBAAqB,6CAAQ,2BAA2B,mDAAc;AACtE,gCAAgC,6CAAQ;AACxC;AACA;AACA,IAAI,0DAAa;AACjB,CAAC;AACD,iEAAe,cAAc,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBE;AACgC;AAC3B;AACc;AACjB;AACV;AAC0B;AAClB;AACJ;AACmB;AACA;AACY;AACZ;AACL;AACH;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAC;AAC3B;AACA,iBAAiB;AACjB;AACA,0BAA0B,qDAAC;AAC3B;AACA,iBAAiB;AACjB;AACA,gCAAgC,yDAAgB,YAAY,qDAAC;AAC7D;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA;AACA,mBAAmB,+CAAM,WAAW,+CAAM;AAC1C;AACA;AACA,2BAA2B,uEAAkB;AAC7C,sBAAsB,+CAAM;AAC5B;AACA,4BAA4B,sDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAE;AACvC,QAAQ,gDAAK;AACb;AACA;AACA,uBAAuB,+CAAM,WAAW,+CAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA,WAAW,2CAAE,QAAQ,4CAAI;AACzB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,sBAAsB,2CAAE,SAAS,4CAAI;AACrC;AACA;AACA,uCAAuC,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAAU;AACtD,4CAA4C,gDAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAY,OAAO,8CAAS;AAC1D,+BAA+B,gDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB,gBAAgB,gDAAO;AACvB;AACA,oBAAoB,gDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oDAAoD,4CAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,iEAAe,KAAK,E;;;;;;;;;;;;;;;;;;;;AC1VqC;AAC1B;AACJ;AAC3B;AACA;AACO,sBAAsB,6CAAI;AACjC;AACA;AACA;AACA,YAAY,8CAAM;AAClB;AACA,YAAY;AAA4C;AACxD,YAAY;AAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAQ,CAAC,+CAAM,IAAI,+CAAM;AAC/C;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA,YAAY,+CAAM;AAClB;AACA,QAAQ,oDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA;AACA;AACA;AACA,wBAAwB,+CAAM,IAAI,+CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;ACzD+B;AACM;AACG;AACP;AACF;AACJ;AACe;AACgB;AACT;AACjD;AACA;AACA,sBAAsB,6CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAO;AACP;AACA;AACA;AACA,oBAAoB,+CAAM,IAAI,+CAAM;AACpC;AACA,uBAAuB,sDAAU,sBAAsB,6CAAQ,CAAC,KAAK,EAAE,KAAK,EAAE;AAC9E;AACA;AACA;AACA,eAAe,CAAC;AAChB;AACA;AACA,yBAAyB,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,0BAA0B,EAAE,IAAI,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAgB;AAC9C;AACA,iCAAiC;AACjC,sCAAsC;AACtC,MAAM;AACN,sBAAsB,UAAU;AAChC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,IAAI,CAAC;AACL;AACA,IAAI,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAkB;AACrD,gCAAgC,+CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAE;AACpB;AACA,KAAK;AACL,IAAI,gDAAK;AACT,CAAC;AACD;AACA,iEAAe,SAAS,E;;;;;;;;;;;;;;;;;;;;;;;ACzFyB;AACS;AACtB;AACM;AACN;AACH;AACjC;AACA;AACO,wBAAwB,6CAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAa,IAAI;AACzB,iCAAiC,sDAAU;AAC3C;AACA;AACA;AACA,uBAAuB,EAAE,GAAG,EAAE;AAC9B;AACA;AACA,yBAAyB,sDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACO,qDAAqD,kEAAW,EAAE,4CAAI;AACtE,sEAAsE,4CAAI;AACjF;AACA;;;;;;;;;;;;;;;;;;AC3E+B;AACJ;AAC3B;AACA;AACA,wBAAwB,6CAAI;AAC5B;AACA,IAAI,+CAAM;AACV,CAAC;AACD,iEAAe,WAAW,E;;;;;;;;;;;;;;;;;;;;ACRW;AACV;AACA;AACgB;AAC3C;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA,kBAAkB,CAAC;AACnB;AACA,IAAI,mDAAS;AACb,QAAQ,8CAAM;AACd,QAAQ,6CAAI;AACZ;AACA,IAAI,mDAAS;AACb,CAAC;AACD,iEAAe,OAAO,E;;;;;;;;;;;;;;;;;;;;;;;AChBsD;AAC7C;AACQ;AACW;AACU;AACjC;AAC+B;AACrB;AACrC;AACA;AACA,qBAAqB,6CAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAM,IAAI,+CAAM;AAC3C;AACA,+BAA+B,+CAAM,QAAQ,+CAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM,IAAI,+CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAQ;AAC9B,yBAAyB,yCAAE;AAC3B;AACA;AACA,wBAAwB,+CAAM,iBAAiB,+CAAM;AACrD,uCAAuC,qDAAM;AAC7C;AACA;AACA,6CAA6C,sEAAkB;AAC/D,0CAA0C,wDAAY;AACtD,4CAA4C,+CAAU;AACtD,iDAAiD,+CAAM,OAAO,+CAAM;AACpE;AACA,qBAAqB;AACrB;AACA,sCAAsC,wDAAY;AAClD,wCAAwC,+CAAU;AAClD;AACA,+CAA+C,sEAAkB;AACjE,2CAA2C,sEAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB,gDAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAAM,IAAI,+CAAM;AACzD;AACA,qBAAqB,qDAAM;AAC3B;AACA,YAAY,oDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAY;AACxC;AACA;AACA,qBAAqB,uDAAW;AAChC,oBAAoB,oDAAQ;AAC5B,qBAAqB,+CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,mDAAU;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,oDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,E;;;;;;;;;;;;;;;;;;ACrJkC;AAC5B;AAC3B;AACA;AACA,kBAAkB,iDAAQ;AACnB,wBAAwB,6CAAI;AACnC;AACA,QAAQ,iDAAQ;AAChB,QAAQ,iDAAQ;AAChB,MAAM;AACN,sBAAsB,iDAAQ;AAC9B,QAAQ,iDAAQ;AAChB;AACA,IAAI,yDAAc;AAClB,CAAC;AACM,wBAAwB,6CAAI;AACnC;AACA,QAAQ,iDAAQ;AAChB,QAAQ,iDAAQ;AAChB,MAAM;AACN,sBAAsB,iDAAQ;AAC9B,QAAQ,iDAAQ;AAChB;AACA,IAAI,yDAAc;AAClB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBoC;AACiB;AACD;AACtB;AACQ;AACH;AACc;AACjB;AACM;AACP;AACD;AACJ;AAC+B;AACjB;AACzC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAI;AACvB;AACA;AACA;AACA;AACA,0BAA0B,4DAAa,EAAE,4DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA,8BAA8B,mDAAU;AACxC;AACA,YAAY,8CAAM;AAClB;AACA,UAAU;AACV;AACA;AACA;AACA,0BAA0B,CAAC;AAC3B,yCAAyC;AACzC,sCAAsC;AACtC;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,CAAC;AAC3B,2BAA2B,CAAC;AAC5B,2BAA2B,CAAC;AAC5B;AACA,0BAA0B,gDAAM,IAAI,gDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA,yCAAyC,gDAAM;AAC/C,8BAA8B,yCAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAQ;AACtC;AACA;AACA;AACA;AACA,mDAAmD,gDAAM;AACzD;AACA,4BAA4B,gDAAM;AAClC,yDAAyD,+CAAU;AACnE;AACA;AACA,uCAAuC,uEAAkB;AACzD;AACA;AACA;AACA,sBAAsB,+CAAM,OAAO,+CAAM;AACzC;AACA;AACA;AACA,wCAAwC,+CAAM;AAC9C,wCAAwC,+CAAM;AAC9C;AACA,iBAAiB,gDAAM;AACvB,gCAAgC,+CAAU,CAAC,gDAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,gDAAK;AACb;AACA;AACA,YAAY,gDAAO;AACnB;AACA,YAAY,mDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAM;AACvB;AACA;AACA;AACA,gCAAgC,+CAAU,CAAC,gDAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAK;AACjB,SAAS;AACT;AACA;AACA,YAAY,gDAAO;AACnB;AACA,YAAY,mDAAQ;AACpB,SAAS;AACT;AACA;AACA,4CAA4C,4CAAI;AAChD,iEAAe,IAAI,E;;;;;;;;;;;;;;;;;;;;;;;;;;ACpTiC;AACrB;AACE;AACjC;AACA;AACO,eAAe,gDAAO;AAC7B;AACO;AACP,WAAW,gDAAO;AAClB;AACA;AACO;AACP,WAAW,gDAAO;AAClB;AACA;AACO;AACP;AACA;AACA;AACO;AACP,QAAQ,+CAAM;AACd,gBAAgB,+CAAM,SAAS,+CAAM;AACrC;AACA,QAAQ,+CAAM,sBAAsB,+CAAM;AAC1C;AACA,iBAAiB,+CAAM,IAAI,+CAAM,MAAM,+CAAM,SAAS,+CAAM;AAC5D;AACA;AACO,oCAAoC,+CAAM,iBAAiB,+CAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,+CAAU,kBAAkB,gDAAW;AACjE;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iCAAiC,gDAAO;AACxC;AACA;AACO;AACP,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACO;AACP,IAAI,gDAAO;AACX,C;;;;;;;;;;;;;;;;;;;;AC3DqC;AACV;AACqC;AAChE;AACA;AACO,qBAAqB,6CAAI;AAChC;AACA,IAAI,iDAAU;AACd,CAAC;AACM,qBAAqB,6CAAI;AAChC;AACA,IAAI,0DAAa;AACjB,CAAC;AACM,oBAAoB,6CAAI,uCAAuC;AACtE;AACA,IAAI,6DAAgB;AACpB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBoC;AACqB;AACF;AAClB;AACY;AACjB;AACF;AACJ;AACkB;AACa;AAClB;AACQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAO;AACpB;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAkB;AAC3C,2BAA2B,gDAAO;AAClC,uBAAuB,8CAAS;AAChC;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+CAAM;AACd;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,iDAAiD,mEAAU,CAAC;AAC5D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAE;AACxB;AACA,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAQ;AAC3B,SAAS;AACT,QAAQ,gDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,uBAAuB,gDAAO;AAC9B,wBAAwB,gDAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB,EAAE,6DAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAQ;AACnD,iEAAe,IAAI,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtRmD;AACrC;AACsB;AACY;AACX;AACT;AACG;;AAE3C;AACP,IAAI,mDAAY,CAAC,0DAAK;AACtB,IAAI,mDAAY,CAAC,iEAAY;AAC7B,IAAI,qDAAY,GAAG,iEAAY;AAC/B,IAAI,sDAAY,CAAC,0DAAK;AACtB;AACA,QAAQ,0DAAK;AACb,qBAAqB,0DAAK;AAC1B;AACA;;AAEO;AACP,IAAI,6CAAM;AACV,QAAQ,gDAAO;AACf,KAAK;AACL;;AAEO;AACP,uBAAuB,0DAAK;AAC5B,uBAAuB,oEAAuB;;AAE9C;AACA;AACA,IAAI,sDAAe;AACnB;;AAEA;AACO;AACP;;AAEA,IAAI,CAAC;AACL;;;AAGO;AACP;AACA,eAAe,oEAAuB;AACtC;AACA,IAAI,CAAC;AACL;;AAEO;AACP,eAAe,CAAC;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEO;AACP,IAAI,CAAC;AACL,IAAI,CAAC;AACL;AACO;AACP,oBAAoB,CAAC;AACrB,2BAA2B,CAAC;;AAE5B,qBAAqB,0DAAK;AAC1B;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI,CAAC;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,YAAY,CAAC;AACb,YAAY,0DAAK;AACjB;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;;AAEA,QAAQ,CAAC;AACT,QAAQ,CAAC;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5HqH;AACvF;AACiB;AACd;AACF;AACc;AACQ;AACY;AAC5B;AACO;AAC5C;AACO;AACP,kBAAkB,0DAAK;AACvB;AACA;AACO;AACP,oBAAoB,6CAAQ,oCAAoC,6CAAQ;AACxE,oCAAoC,0DAAiB;AACrD;AACA,IAAI,CAAC;AACL;AACA;AACA,QAAQ,0DAAK;AACb;AACA,QAAQ,gDAAO;AACf;AACA;AACA,IAAI,uDAAc;AAClB;AACA;AACA,QAAQ,0DAAK;AACb;AACA,IAAI,gDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,CAAC;AACtB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAM,IAAI,gDAAO,sBAAsB,gDAAO;AAC7D,gBAAgB,gDAAO;AACvB;AACA;AACA,6BAA6B,+CAAM,qBAAqB,+CAAM;AAC9D,mBAAmB,+CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA,QAAQ,8CAAO;AACf,KAAK;AACL;AACA;AACA;AACO;AACP,IAAI,8DAAqB;AACzB;AACA;AACA,IAAI,8CAAS;AACb,YAAY,CAAC,QAAQ,EAAE;AACvB;AACA,oBAAoB,uDAAQ,KAAK,uDAAQ;AACzC;AACA;AACA;AACA;AACA;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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;ACrJO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA,C;;;;;;;;;;;;;;;;;;;AClBuC;AACN;AACgB;AACR;AACzC;AACA;AACO;AACP,iBAAiB,gDAAO;AACxB,eAAe,yDAAmB;AAClC;AACA;AACA,0BAA0B,+CAAU,EAAE,EAAE,sDAAe,GAAG;AAC1D;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACfA,iEAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA,oCAAoC,kBAAkB;AACtD,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,YAAY;AACvC,+BAA+B,YAAY;AAC3C;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;;;;AC5EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,cAAc;;AAE1B;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;;AAEO,gE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvF8C;AACX;AACT;AAC6C;AAC7C;AACe;AACjB;AACA;;AAEyB;AACC;;AAEK;AACpB;AACG;;;AAG7C;AACA,IAAI,oDAAoD;AACxD;AACA,kBAAkB,gJAAkC;AACpD,wBAAwB,gLAAkD;AAC1E,2BAA2B,8JAAyC;AACpE,sBAAsB,sJAAqC;AAC3D;;AAEA,sBAAsB,sDAAS,CAAC,8DAAa,EAAE,8DAAc;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,kBAAkB,+CAAM,QAAQ,+CAAM;;AAEtC,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;AACA;AACA,IAAI,+CAAM;AACV,IAAI,+CAAM;AACV;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAEM;AACP,yBAAyB,sDAAS,CAAC,uEAAW;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,+CAAM;AACxB,mCAAmC,sEAAkB;;AAErD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,yCAAE;AACtB,IAAI,gDAAO;;AAEX;AACA;AACA,yBAAyB,sEAAkB;AAC3C;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,sEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,gDAAO;AACX,IAAI,gDAAO;;AAEX;AACA;;AAEA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;AACA,YAAY,gDAAO;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,0DAAK;AAC9C,6BAA6B,OAAO;AACpC,2BAA2B,0DAAK,mCAAmC,MAAM;;AAEzE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,QAAQ,0DAAK;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,yCAAE;AACzB,QAAQ,gDAAO;;AAEf;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;AAEA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;;AAEf;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,0DAAK;AACb;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAM;AACtB;AACA,oCAAoC,sEAAkB;AACtD;AACA;AACA;AACA;AACA,YAAY,+CAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sEAAkB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;;AAEA;AACA,QAAQ,0DAAK;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,gDAAO;;AAEf;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;;AAEA;AACA;AACA,YAAY,gDAAO;AACnB,YAAY,gDAAO;AACnB;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,sEAAkB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,0DAAK;;AAErB;;AAEA;AACA;AACA;AACA,iDAAiD,sEAAkB;;AAEnE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iDAAiD,sEAAkB;;AAEnE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,kDAAK;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,qDAAQ;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,qDAAQ;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,sEAAkB;;AAE9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA,gCAAgC,sDAAS;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,gDAAO;AACf;;AAEA;AACA;;AAEA,uBAAuB,sEAAkB;AACzC,kBAAkB,+CAAM;;AAExB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,YAAY,IAAI,OAAO,GAAG,oBAAoB,GAAG,0BAA0B;;AAEjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4EAA4E;AAC5E;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,qDAAQ;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,qDAAQ;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,gCAAgC;AAClD,kBAAkB,sBAAsB;AACxC,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,kBAAkB,IAAI,kBAAkB;AAC5E;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,qDAAqD,aAAa,GAAG,mBAAmB;;;AAGxF;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,uDAAU;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,uDAAU;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AA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","sources":["webpack://goroxels-client/./src/css/colorVars.css","webpack://goroxels-client/./src/css/style.css","webpack://goroxels-client/./src/font/pixel/min5.png","webpack://goroxels-client/./src/font/pixel/min5.txt","webpack://goroxels-client/./src/font/pixel/winamp.png","webpack://goroxels-client/./src/font/pixel/winamp.txt","webpack://goroxels-client/./src/img/3rdcf.png","webpack://goroxels-client/./src/img/admin-badge.svg","webpack://goroxels-client/./src/img/arrow.svg","webpack://goroxels-client/./src/img/badges/ sync nonrecursive \\.png$","webpack://goroxels-client/./src/img/badges/brimstone.png","webpack://goroxels-client/./src/img/badges/jimbo.png","webpack://goroxels-client/./src/img/badges/ny24.png","webpack://goroxels-client/./src/img/badges/pepe.png","webpack://goroxels-client/./src/img/badges/pony.png","webpack://goroxels-client/./src/img/badges/scream.png","webpack://goroxels-client/./src/img/badges/star.png","webpack://goroxels-client/./src/img/badges/umum.png","webpack://goroxels-client/./src/img/badges/yoba.png","webpack://goroxels-client/./src/img/badges/z.png","webpack://goroxels-client/./src/img/chunkPlaceholder.png","webpack://goroxels-client/./src/img/cross.svg","webpack://goroxels-client/./src/img/disabled-color.svg","webpack://goroxels-client/./src/img/discord-logo-circle.svg","webpack://goroxels-client/./src/img/dots.svg","webpack://goroxels-client/./src/img/gg-logo.svg","webpack://goroxels-client/./src/img/goroxels.png","webpack://goroxels-client/./src/img/icon-desktop.svg","webpack://goroxels-client/./src/img/icon-phone.svg","webpack://goroxels-client/./src/img/mod-badge.svg","webpack://goroxels-client/./src/img/mouse/mouse-4mb.png","webpack://goroxels-client/./src/img/mouse/mouse-5mb.png","webpack://goroxels-client/./src/img/mouse/mouse-lmb.png","webpack://goroxels-client/./src/img/mouse/mouse-mmb.png","webpack://goroxels-client/./src/img/mouse/mouse-rmb.png","webpack://goroxels-client/./src/img/move-icon.svg","webpack://goroxels-client/./src/img/movie/BrightnessHigh.svg","webpack://goroxels-client/./src/img/movie/BrightnessHighFill.svg","webpack://goroxels-client/./src/img/movie/SoundOff.svg","webpack://goroxels-client/./src/img/movie/SoundOn.svg","webpack://goroxels-client/./src/img/old-wipes/ sync nonrecursive \\.png$","webpack://goroxels-client/./src/img/old-wipes/01.06.20.png","webpack://goroxels-client/./src/img/old-wipes/02.05.22.png","webpack://goroxels-client/./src/img/old-wipes/03.04.23.png","webpack://goroxels-client/./src/img/old-wipes/03.06.19.png","webpack://goroxels-client/./src/img/old-wipes/09.04.18.png","webpack://goroxels-client/./src/img/old-wipes/09.08.19.png","webpack://goroxels-client/./src/img/old-wipes/10.07.17.png","webpack://goroxels-client/./src/img/old-wipes/16.08.25.png","webpack://goroxels-client/./src/img/old-wipes/18.11.19.png","webpack://goroxels-client/./src/img/old-wipes/22.08.18.png","webpack://goroxels-client/./src/img/old-wipes/22.11.18.png","webpack://goroxels-client/./src/img/old-wipes/25.02.19.png","webpack://goroxels-client/./src/img/old-wipes/26.02.20.png","webpack://goroxels-client/./src/img/old-wipes/26.10.23.png","webpack://goroxels-client/./src/img/protectedPattern.png","webpack://goroxels-client/./src/img/stripes.png","webpack://goroxels-client/./src/img/telegram.svg","webpack://goroxels-client/./src/img/toolIcons/clicker.png","webpack://goroxels-client/./src/img/toolIcons/disable-cur.png","webpack://goroxels-client/./src/img/toolIcons/disable.png","webpack://goroxels-client/./src/img/toolIcons/floodfill.png","webpack://goroxels-client/./src/img/toolIcons/line.png","webpack://goroxels-client/./src/img/toolIcons/move.png","webpack://goroxels-client/./src/img/toolIcons/protect.png","webpack://goroxels-client/./src/img/toolIcons/revert.png","webpack://goroxels-client/./src/img/toolIcons/wand-cur.png","webpack://goroxels-client/./src/img/unavailable.png","webpack://goroxels-client/./src/img/user.svg","webpack://goroxels-client/./src/img/user2.png","webpack://goroxels-client/./src/img/vk-logo.svg","webpack://goroxels-client/./src/img/winamp/ sync nonrecursive \\.png$","webpack://goroxels-client/./src/img/winamp/bg.png","webpack://goroxels-client/./src/img/winamp/bg2.png","webpack://goroxels-client/./src/img/winamp/digits.png","webpack://goroxels-client/./src/img/winamp/enableRadioBtn.png","webpack://goroxels-client/./src/img/winamp/hr-slider-btn-small.png","webpack://goroxels-client/./src/img/winamp/slider-btn.png","webpack://goroxels-client/./src/js/Bucket.js","webpack://goroxels-client/./src/js/Chat.js","webpack://goroxels-client/./src/js/Chunk.js","webpack://goroxels-client/./src/js/ChunkManager.js","webpack://goroxels-client/./src/js/MiniWindow.js","webpack://goroxels-client/./src/js/Pattern.js","webpack://goroxels-client/./src/js/Renderer.js","webpack://goroxels-client/./src/js/Socket.js","webpack://goroxels-client/./src/js/TempChunkPlaceholder.js","webpack://goroxels-client/./src/js/Tool.js","webpack://goroxels-client/./src/js/ToolManager.js","webpack://goroxels-client/./src/js/Window.js","webpack://goroxels-client/./src/js/assets.js","webpack://goroxels-client/./src/js/camera.js","webpack://goroxels-client/./src/js/draggableInputs.js","webpack://goroxels-client/./src/js/fxcanvas.js","webpack://goroxels-client/./src/js/history.js","webpack://goroxels-client/./src/js/indexedDb.js","webpack://goroxels-client/./src/js/init.js","webpack://goroxels-client/./src/js/main.js","webpack://goroxels-client/./src/js/me.js","webpack://goroxels-client/./src/js/player.js","webpack://goroxels-client/./src/js/protocol.js","webpack://goroxels-client/./src/js/template.js","webpack://goroxels-client/./src/js/tools/brushSize.js","webpack://goroxels-client/./src/js/tools/clicker.js","webpack://goroxels-client/./src/js/tools/colorSwap.js","webpack://goroxels-client/./src/js/tools/copy.js","webpack://goroxels-client/./src/js/tools/ctrlZ.js","webpack://goroxels-client/./src/js/tools/floodfill.js","webpack://goroxels-client/./src/js/tools/gradient.js","webpack://goroxels-client/./src/js/tools/grid.js","webpack://goroxels-client/./src/js/tools/index.js","webpack://goroxels-client/./src/js/tools/line.js","webpack://goroxels-client/./src/js/tools/mnkbm.js","webpack://goroxels-client/./src/js/tools/mover.js","webpack://goroxels-client/./src/js/tools/nextColor.js","webpack://goroxels-client/./src/js/tools/paletteSwapper.js","webpack://goroxels-client/./src/js/tools/paste.js","webpack://goroxels-client/./src/js/tools/pipettes.js","webpack://goroxels-client/./src/js/tools/pixelInfo.js","webpack://goroxels-client/./src/js/tools/protectors.js","webpack://goroxels-client/./src/js/tools/resetColors.js","webpack://goroxels-client/./src/js/tools/sendCoords.js","webpack://goroxels-client/./src/js/tools/square.js","webpack://goroxels-client/./src/js/tools/templateToggles.js","webpack://goroxels-client/./src/js/tools/text.js","webpack://goroxels-client/./src/js/tools/toolUtils.js","webpack://goroxels-client/./src/js/tools/uiToggles.js","webpack://goroxels-client/./src/js/tools/wand.js","webpack://goroxels-client/./src/js/ui/config.js","webpack://goroxels-client/./src/js/ui/palette.js","webpack://goroxels-client/./src/js/ui/toggles.js","webpack://goroxels-client/./src/js/user.js","webpack://goroxels-client/./src/js/utils/camera.js","webpack://goroxels-client/./src/js/utils/conversions.js","webpack://goroxels-client/./src/js/utils/cssColorsList.js","webpack://goroxels-client/./src/js/utils/math.js","webpack://goroxels-client/./src/js/utils/screenshot.js","webpack://goroxels-client/./src/js/utils/shapes.js","webpack://goroxels-client/./src/js/utils/strings.js","webpack://goroxels-client/./src/js/utils/webGL.js","webpack://goroxels-client/./src/js/winamp/player.js","webpack://goroxels-client/./src/js/windows.js","webpack://goroxels-client/./src/video/as.webm","webpack://goroxels-client/./src/video/brush.webm","webpack://goroxels-client/./src/video/brush2.webm","webpack://goroxels-client/./src/video/clicker.webm","webpack://goroxels-client/./src/video/clickerMouse.webm","webpack://goroxels-client/./src/video/ctrlZ.webm","webpack://goroxels-client/./src/video/flood.webm","webpack://goroxels-client/./src/video/line.webm","webpack://goroxels-client/./src/video/patternDemo.webm","webpack://goroxels-client/./src/video/phoneDrawing.mp4","webpack://goroxels-client/./src/video/toolC.webm","webpack://goroxels-client/./src/workers/index.js","webpack://goroxels-client/webpack/bootstrap","webpack://goroxels-client/webpack/runtime/amd define","webpack://goroxels-client/webpack/runtime/chunk loaded","webpack://goroxels-client/webpack/runtime/compat get default export","webpack://goroxels-client/webpack/runtime/define property getters","webpack://goroxels-client/webpack/runtime/get javascript chunk filename","webpack://goroxels-client/webpack/runtime/hasOwnProperty shorthand","webpack://goroxels-client/webpack/runtime/make namespace object","webpack://goroxels-client/webpack/runtime/publicPath","webpack://goroxels-client/webpack/runtime/jsonp chunk loading","webpack://goroxels-client/webpack/before-startup","webpack://goroxels-client/webpack/startup","webpack://goroxels-client/webpack/after-startup"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","// extracted by mini-css-extract-plugin\nexport {};","export default __webpack_public_path__ + \"/font/min5.png\";","export default __webpack_public_path__ + \"/font/min5.txt\";","export default __webpack_public_path__ + \"/font/winamp.png\";","export default __webpack_public_path__ + \"/font/winamp.txt\";","export default __webpack_public_path__ + \"/img/3rdcf.png\";","export default __webpack_public_path__ + \"/img/admin-badge.svg\";","export default __webpack_public_path__ + \"/img/arrow.svg\";","var map = {\n\t\"./brimstone.png\": \"./src/img/badges/brimstone.png\",\n\t\"./jimbo.png\": \"./src/img/badges/jimbo.png\",\n\t\"./ny24.png\": \"./src/img/badges/ny24.png\",\n\t\"./pepe.png\": \"./src/img/badges/pepe.png\",\n\t\"./pony.png\": \"./src/img/badges/pony.png\",\n\t\"./scream.png\": \"./src/img/badges/scream.png\",\n\t\"./star.png\": \"./src/img/badges/star.png\",\n\t\"./umum.png\": \"./src/img/badges/umum.png\",\n\t\"./yoba.png\": \"./src/img/badges/yoba.png\",\n\t\"./z.png\": \"./src/img/badges/z.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/img/badges sync \\\\.png$\";","export default __webpack_public_path__ + \"/img/brimstone.png\";","export default __webpack_public_path__ + \"/img/jimbo.png\";","export default __webpack_public_path__ + \"/img/ny24.png\";","export default __webpack_public_path__ + \"/img/pepe.png\";","export default __webpack_public_path__ + \"/img/pony.png\";","export default __webpack_public_path__ + \"/img/scream.png\";","export default __webpack_public_path__ + \"/img/star.png\";","export default __webpack_public_path__ + \"/img/umum.png\";","export default __webpack_public_path__ + \"/img/yoba.png\";","export default __webpack_public_path__ + \"/img/z.png\";","export default __webpack_public_path__ + \"/img/chunkPlaceholder.png\";","export default __webpack_public_path__ + \"/img/cross.svg\";","export default __webpack_public_path__ + \"/img/disabled-color.svg\";","export default __webpack_public_path__ + \"/img/discord-logo-circle.svg\";","export default __webpack_public_path__ + \"/img/dots.svg\";","export default __webpack_public_path__ + \"/img/gg-logo.svg\";","export default __webpack_public_path__ + \"/img/goroxels.png\";","export default __webpack_public_path__ + \"/img/icon-desktop.svg\";","export default __webpack_public_path__ + \"/img/icon-phone.svg\";","export default __webpack_public_path__ + \"/img/mod-badge.svg\";","export default __webpack_public_path__ + \"/img/mouse-4mb.png\";","export default __webpack_public_path__ + \"/img/mouse-5mb.png\";","export default __webpack_public_path__ + \"/img/mouse-lmb.png\";","export default __webpack_public_path__ + \"/img/mouse-mmb.png\";","export default __webpack_public_path__ + \"/img/mouse-rmb.png\";","export default __webpack_public_path__ + \"/img/move-icon.svg\";","export default __webpack_public_path__ + \"/img/BrightnessHigh.svg\";","export default __webpack_public_path__ + \"/img/BrightnessHighFill.svg\";","export default __webpack_public_path__ + \"/img/SoundOff.svg\";","export default __webpack_public_path__ + \"/img/SoundOn.svg\";","var map = {\n\t\"./01.06.20.png\": \"./src/img/old-wipes/01.06.20.png\",\n\t\"./02.05.22.png\": \"./src/img/old-wipes/02.05.22.png\",\n\t\"./03.04.23.png\": \"./src/img/old-wipes/03.04.23.png\",\n\t\"./03.06.19.png\": \"./src/img/old-wipes/03.06.19.png\",\n\t\"./09.04.18.png\": \"./src/img/old-wipes/09.04.18.png\",\n\t\"./09.08.19.png\": \"./src/img/old-wipes/09.08.19.png\",\n\t\"./10.07.17.png\": \"./src/img/old-wipes/10.07.17.png\",\n\t\"./16.08.25.png\": \"./src/img/old-wipes/16.08.25.png\",\n\t\"./18.11.19.png\": \"./src/img/old-wipes/18.11.19.png\",\n\t\"./22.08.18.png\": \"./src/img/old-wipes/22.08.18.png\",\n\t\"./22.11.18.png\": \"./src/img/old-wipes/22.11.18.png\",\n\t\"./25.02.19.png\": \"./src/img/old-wipes/25.02.19.png\",\n\t\"./26.02.20.png\": \"./src/img/old-wipes/26.02.20.png\",\n\t\"./26.10.23.png\": \"./src/img/old-wipes/26.10.23.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/img/old-wipes sync \\\\.png$\";","export default __webpack_public_path__ + \"/img/01.06.20.png\";","export default __webpack_public_path__ + \"/img/02.05.22.png\";","export default __webpack_public_path__ + \"/img/03.04.23.png\";","export default __webpack_public_path__ + \"/img/03.06.19.png\";","export default __webpack_public_path__ + \"/img/09.04.18.png\";","export default __webpack_public_path__ + \"/img/09.08.19.png\";","export default __webpack_public_path__ + \"/img/10.07.17.png\";","export default __webpack_public_path__ + \"/img/16.08.25.png\";","export default __webpack_public_path__ + \"/img/18.11.19.png\";","export default __webpack_public_path__ + \"/img/22.08.18.png\";","export default __webpack_public_path__ + \"/img/22.11.18.png\";","export default __webpack_public_path__ + \"/img/25.02.19.png\";","export default __webpack_public_path__ + \"/img/26.02.20.png\";","export default __webpack_public_path__ + \"/img/26.10.23.png\";","export default __webpack_public_path__ + \"/img/protectedPattern.png\";","export default __webpack_public_path__ + \"/img/stripes.png\";","export default __webpack_public_path__ + \"/img/telegram.svg\";","export default __webpack_public_path__ + \"/img/clicker.png\";","export default __webpack_public_path__ + \"/img/disable-cur.png\";","export default __webpack_public_path__ + \"/img/disable.png\";","export default __webpack_public_path__ + \"/img/floodfill.png\";","export default __webpack_public_path__ + \"/img/line.png\";","export default __webpack_public_path__ + \"/img/move.png\";","export default __webpack_public_path__ + \"/img/protect.png\";","export default __webpack_public_path__ + \"/img/revert.png\";","export default __webpack_public_path__ + \"/img/wand-cur.png\";","export default __webpack_public_path__ + \"/img/unavailable.png\";","export default __webpack_public_path__ + \"/img/user.svg\";","export default __webpack_public_path__ + \"/img/user2.png\";","export default __webpack_public_path__ + \"/img/vk-logo.svg\";","var map = {\n\t\"./bg.png\": \"./src/img/winamp/bg.png\",\n\t\"./bg2.png\": \"./src/img/winamp/bg2.png\",\n\t\"./digits.png\": \"./src/img/winamp/digits.png\",\n\t\"./enableRadioBtn.png\": \"./src/img/winamp/enableRadioBtn.png\",\n\t\"./hr-slider-btn-small.png\": \"./src/img/winamp/hr-slider-btn-small.png\",\n\t\"./slider-btn.png\": \"./src/img/winamp/slider-btn.png\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/img/winamp sync \\\\.png$\";","export default __webpack_public_path__ + \"/img/bg.png\";","export default __webpack_public_path__ + \"/img/bg2.png\";","export default __webpack_public_path__ + \"/img/digits.png\";","export default __webpack_public_path__ + \"/img/enableRadioBtn.png\";","export default __webpack_public_path__ + \"/img/hr-slider-btn-small.png\";","export default __webpack_public_path__ + \"/img/slider-btn.png\";","export default class Bucket{\n    constructor(delay, max){\n        this._allowance = 0;\n\n        this.delay = delay;\n        this.max = max;\n\n        this.lastCheck = Date.now();\n    }\n\n    get allowance () {\n        if(this.delay === 0) return Infinity;\n        \n        this._allowance += (Date.now() - this.lastCheck) / this.delay;\n\n        this.lastCheck = Date.now();\n\n        if(this._allowance > this.max) this._allowance = this.max;\n\n        return this._allowance\n    }\n\n    set allowance(c){\n        this._allowance = c;\n    }\n\n    spend(count){\n        if(this.delay === 0) return true;\n\n        let allow = this.allowance;\n\n        if(allow < count) return false;\n\n        this.allowance  = allow - count;\n\n        return true\n    }\n}","import { canvasName, downloaded, game, resolveWhenConfigDownloaded } from './config';\nimport { chat as chatEl, chatInput } from './ui/elements';\nimport globals from './globals';\nimport { translate as t_ } from './translate';\nimport cssColors from './utils/cssColorsList'\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\nimport { htmlspecialchars } from './utils/misc';\n\n// currently chat supports only one channel\n// but socket is designed to handle many\n\nfunction pad(pad, str, padLeft) {\n    if (typeof str === 'undefined')\n        return pad;\n    if (padLeft) {\n        return (pad + str).slice(-pad.length);\n    } else {\n        return (str + pad).substring(0, pad.length);\n    }\n}\nfunction padZeros(str, count = 2) {\n    return (str.toString()).padStart(count, '0');\n}\n\nconst colorRegEx = new RegExp(/\\[(#?[A-Z0-9]{1,8})*?\\]/gi);\n// https : / / host.com/img .png       ? q=321123\nconst imgRegEx = new RegExp(/http?s:\\/\\/.+?\\.(png|jpg|jpeg|gif)(\\?\\S+)?/i);\nconst goroxelsLinkRegEx = new RegExp(`^https?://${location.host}/.*`);\n\nclass Chat {\n    constructor() {\n        this.element = $('#chat');\n\n        this.logElems = {};\n\n        this.colorsEnabled = !JSON.parse(getOrDefault('disableColors', false));\n\n        this.muted = JSON.parse(getLS('muted')) || [];\n\n        this.channel = undefined;\n\n        this.initChatEvents();\n    }\n\n    loadChannelElements() {\n        [...$('#chatLog').children()].map(el => {\n            let channel = el.dataset.channel;\n            if (channel === 'local') {\n                channel = canvasName;\n            }\n            this.logElems[channel] = $(el);\n        })\n    }\n\n    // mobile version of hide/show\n    mobileShow() {\n        this.element.css('top', '0');\n    }\n\n    mobileHide() {\n        this.element.css('top', '-100vh');\n    }\n\n    setColors(state) {\n        this.colorsEnabled = state;\n\n        $('.chatColored').toggleClass('noColor', !state);\n    }\n\n    parseColors(str) {\n        // colors should be formatted like: [RED]test or [#FF0000]te[]st\n\n        let colorEntries = 0;\n\n        let regIter = str.matchAll(colorRegEx);\n        while (true) {\n            let {\n                value: entry,\n                done\n            } = regIter.next();\n            if (done) break;\n\n            let color = entry[1];\n\n            if (color) {\n                // test for \"#\" and mathing A-F a-f hex alphabet\n                if (color.startsWith('#') && !/[G-Zg-z]/.test(color)) {\n                    color = pad(color.slice(-1).repeat(6 + 1), color);\n                } else if (!cssColors[color]) continue;\n\n                str = str.replace(entry[0],\n                    `<div class=\"chatColored${this.colorsEnabled ? '' : ' noColor'}\" style=\"color:${color}\">`);\n                colorEntries++;\n            } else { // empty braces\n                if (colorEntries > 0) {\n                    str = str.replace(entry[0], '</div>');\n                    colorEntries--;\n                } else {\n                    // \"[\" and \"]\"\n                    str = str.replace(entry[0], '&#91;&#93;');\n                }\n            }\n        }\n\n        if (colorEntries > 0) str += '</div>'.repeat(colorEntries);\n\n        return str\n    }\n    parseCoords(str) {\n        return str.replace(/\\((\\d{1,5}), ?(\\d{1,5})\\)/g,\n            `<a class=\"cordgo\" onclick=\"camera.centerOn($1, $2)\">$&</a>`)\n    }\n    parseImage(str) {\n        let matching = str.match(imgRegEx);\n\n        if (matching) {\n            let src = matching[0];\n            str = str.replace(src,\n                `<span class=\"imageLink\" onclick=\"globals.chat.toggleImage(this)\">${src}</span>`)\n        }\n\n        return str\n    }\n    toggleImage(target) {\n        const element = $(target);\n        const parent = element.parent();\n\n        const exists = !!$('img', parent).length;\n        if (exists) {\n            $('.imageLink', parent).css('cursor', 'zoom-in')\n            $('img', parent).remove();\n        } else {\n            $('.imageLink', parent).css('cursor', 'zoom-out');\n            const img = $(`<img src=\"${element.text()}\" class=\"chatImg\" onclick=\"globals.chat.toggleImage(this)\">`);\n            img.on('load', this.scroll.bind(this, this.channel));\n            parent.append(img);\n        }\n    }\n    parseGoroxelsLink(text) {\n        const firstArg = text.split(' ')[0];\n        if (!firstArg) return text;\n\n        const match = text.match(goroxelsLinkRegEx);\n        if (!match) return text;\n\n        return text.replace(match[0], `<a href=\"${match[0]}\">${match[0]}</a>`);\n    }\n\n    parseBB(str) {\n        // function does not checks for brackets order validity\n        let openedTags = [];\n\n        let regIter = str.matchAll(/\\[(\\/?[bi])\\]/gi);\n        while (true) {\n            let {\n                value: entry,\n                done\n            } = regIter.next();\n            if (done) break;\n\n            let tag = entry[1];\n            str = str.replace(entry[0],\n                `<${tag}>`);\n            if (!tag.startsWith('/'))\n                openedTags.push(tag);\n            else {\n                openedTags = openedTags.splice(openedTags.indexOf(tag.slice(1)));\n            }\n        }\n\n        while (openedTags.length) {\n            str += `</${openedTags.shift()}>`\n        }\n\n        return str\n    }\n\n    addMessage(message) {\n        $('.showChat').addClass('showChat-notify');\n        $('.chatNotif').addClass('active');\n\n        const channel = message.ch;\n\n        if (message.server)\n            return this.addServerMessage(message.msg, channel);\n\n        let text = htmlspecialchars(message.msg),\n            nick = htmlspecialchars(message.nick);\n\n        const realNick = nick;\n\n        if (nick === 'Goroh') {\n            nick = `<span style=\"text-shadow:0 0 3px\">[#0]${nick}</span>`\n        }\n\n        try {\n            text = this.parseColors(text);\n            text = this.parseBB(text);\n            text = this.parseCoords(text);\n            text = this.parseGoroxelsLink(text);\n            text = this.parseImage(text);\n\n            nick = this.parseColors(nick);\n        } catch (e) {\n            console.log(e);\n        }\n\n        const isMuted = ~this.muted.indexOf(realNick);\n\n        let timeFormatted = '', fullDateFormatted = '';\n        if (message.time) {\n            const date = new Date(message.time);\n            const dd = padZeros(date.getDate());\n            const MM = padZeros(date.getMonth() + 1);\n            const yy = date.getFullYear() - 2000;\n\n            \n            const hh = padZeros(date.getHours());\n            const mm = padZeros(date.getMinutes());\n            const ss = padZeros(date.getSeconds());\n            \n            timeFormatted = `[${hh}:${mm}]`;\n            fullDateFormatted = `${dd}.${MM}.${yy} [${hh}:${mm}:${ss}]`;\n        }\n\n        const msgEl = $(\n            `<div class=\"chatMessage\" ${isMuted ? 'style=\"display:none\"' : ''}>\n            <span class=\"messageTime\" title=\"${fullDateFormatted}\">${timeFormatted}</span>\n            <div class=\"messageNick\" data-nick=\"${realNick}\">${nick}:</div>\n            <div class=\"messageText\">${text}</div>\n        </div>`);\n\n        $('.messageNick', msgEl).on('click', function () {\n            const visibleNick = this.innerText.slice(0, -1);\n            chatInput[0].value += visibleNick + ', ';\n            chatInput.trigger('focus');\n        })\n\n        this.logElems[channel].append(msgEl);\n\n        this.afterAddingMessage(channel);\n    }\n\n    addLocalMessage(text, channel) {\n        text = this.parseColors(text);\n        text = this.parseBB(text);\n        text = this.parseCoords(text);\n        text = this.parseGoroxelsLink(text);\n        text = this.parseImage(text);\n\n        const msgEl = $(\n            `<div class=\"chatMessage\">\n                <div class=\"messageText\">${text}</div>\n            </div>`)\n\n        this.logElems[channel].append(msgEl);\n\n        this.afterAddingMessage(channel);\n    }\n\n\n\n    switchChannel(channel) {\n        if (this.channel === channel) {\n            return;\n        }\n\n        const channelAlias = channel;\n        if (channel === 'local') {\n            channel = canvasName;\n        }\n\n        for (let ch of Object.values(this.logElems)) {\n            ch.hide();\n        }\n        this.logElems[channel].show();\n\n        $(`#chatChannels>div`).removeClass('selected');\n        $(`#chatChannels>div[data-channel=\"${channelAlias}\"]`).addClass('selected');\n\n        this.scroll(channel, true);\n\n        this.channel = channel;\n    }\n\n    addServerMessage(text, channel) {\n        this.addLocalMessage(text, channel);\n    }\n\n    afterAddingMessage(channel) {\n        const el = this.logElems[channel];\n        if (el.children().length > game.chatLimit) {\n            el.children()[0].remove();\n        }\n        this.scroll(channel);\n    }\n\n    // handles messages to send\n    handleMessage(message) {\n        if (message.startsWith('/')) {\n            this.handleCommand(message);\n        } else {\n            if (!globals.socket.connected) {\n                chatInput.val(message);\n                return;\n            }\n            globals.socket.sendChatMessage(message, this.channel);\n        }\n    }\n\n    sendWhisper(target, message) {\n        globals.socket.sendChatWhisper(message, this.channel, target);\n    }\n\n    // handles chat commands\n    handleCommand(command) {\n        let args = command.split(' ');\n\n        const cmd = args[0];\n        args = args.slice(1);\n\n        switch (cmd) {\n            case '/mute': {\n                const nick = args.join(' ');\n                this.mute(nick);\n\n                break\n            }\n            case '/unmute': {\n                const nick = args.join(' ');\n                this.unmute(nick);\n\n                break\n            }\n            case '/w': {\n                if (args.length < 2) {\n                    return this.addLocalMessage('Usage: /w &lt;targetAccountId&gt; &lt;message&gt;');\n                }\n                const id = args[0];\n                const msg = args.slice(1).join(' ');\n\n                if (globals.socket.connected) {\n                    this.sendWhisper(id, msg);\n                    this.addLocalMessage(`${t_('chat.you')} -> id${id}: <i>${msg}</i>`, this.channel);\n                    chatInput.val(`/w ${id} `);\n                }\n\n                break\n            }\n            case '/help': {\n                const commands =\n                    `/mute ${t_('chat.muteDesc')}<br>` +\n                    `/unmute ${t_('chat.unmuteDesc')}<br>` +\n                    `/w ${t_('chat.wDesc')}`;\n\n                this.addLocalMessage(commands, this.channel);\n            }\n        }\n    }\n\n    mute(nick) {\n        const pref = '<b>mute:</b> ';\n\n        if (!nick.length || nick.length > 32) {\n            return this.addLocalMessage(pref + t_('Wrong nick length'))\n        }\n        if (~this.muted.indexOf(nick)) {\n            return this.addLocalMessage(pref + t_('Player is already muted'))\n        }\n\n        this.muted.push(nick);\n        setLS('muted', JSON.stringify(this.muted));\n\n        $('.messageNick').each((_, el) => {\n            if (el.dataset.nick === nick) {\n                el.parentElement.style.display = 'none';\n            }\n        })\n    }\n\n    unmute(nick) {\n        let pref = '<b>unmute:</b> ', index;\n\n        if (!nick.length || nick.length > 32) {\n            return this.addLocalMessage(pref + t_('Wrong nick length'))\n        }\n        if (!~(index = this.muted.indexOf(nick))) {\n            return this.addLocalMessage(pref + t_('Player is not muted'))\n        }\n\n        this.muted.splice(index, 1);\n        setLS('muted', JSON.stringify(this.muted));\n\n        $('.messageNick').each((_, el) => {\n            if (el.dataset.nick === nick) {\n                el.parentElement.style.display = 'block';\n            }\n        })\n    }\n\n    initChatEvents() {\n        chatInput.on('input', () => {\n            const value = chatInput.val();\n            if (imgRegEx.test(value) || goroxelsLinkRegEx.test(value)) {\n                chatInput.css('color', 'white');\n            } else {\n                chatInput.css('color', '');\n            }\n        })\n    }\n\n    // this function scrolls only if player scrolled chat log to the end\n    scroll(channel = 'global', force = false) {\n        const el$ = this.logElems[channel];\n        const el = el$.parent()[0];\n        const lastElemHeight = el$.children().slice(-1).innerHeight() || 0;\n        // 2 is message margin and 5 is just for fun\n        const scrolled = (el.scrollHeight - el.scrollTop - el.clientHeight - lastElemHeight) <= 2 + 5;\n        if (scrolled || force) {\n            el.scrollBy(0, 999);\n        }\n    }\n}\n\nconst chat = new Chat();\n\nexport function initChat() {\n    $(document).on('keydown', e => {\n        if (globals.lockInputs) return;\n        if (e.key !== 'Enter') return;\n\n        if ($('#chatInput').is(':focus') || globals.mobile) {\n            // send if focused\n            const message = chatInput.val();\n            if (!message.length)\n                return chatInput.trigger('blur');\n\n            chatInput.val('');\n\n            chat.handleMessage(message);\n        } else {\n            // or focus if not\n            $('#chatInput').trigger('focus');\n        }\n    });\n\n    $('#chatChannels>div').on('click', (e) => {\n        const ch = e.target.dataset.channel;\n        chat.switchChannel(ch);\n        setLS('chatChannel', ch);\n    });\n\n    resolveWhenConfigDownloaded().then(() => {\n        chat.loadChannelElements();\n        chat.switchChannel(getLS('chatChannel') || 'global');\n    })\n\n    initChatHeightWorkaround();\n}\n\n\n\nexport function toggleChat() {\n    $('.chatNotif').removeClass('active');\n\n    if (chatEl.css('display') === 'none') {\n        chatEl.show();\n        chatEl.css('left', '');\n\n        $('.chatNotif').hide();\n    } else {\n        chatEl.css('left', -chatEl.width() - 30);\n        setTimeout(() => chatEl.hide(), 500);\n\n        $('.chatNotif').show();\n    }\n}\n\nexport function initMobileChatToggle() {\n    $('.showChat').on('click', () => {\n        $('.showChat').removeClass('showChat-notify');\n        chat.mobileShow()\n    });\n    $('#hideChat').on('click', () => {\n        $('.showChat').removeClass('showChat-notify');\n        chat.mobileHide()\n    });\n}\n\nfunction initChatHeightWorkaround() {\n    // -webkit-fill-available does not work since\n    // the best way to define height that i know \n    // for the moment is through the script\n\n    function fixChatHeight() {\n        document.documentElement.style.setProperty('--gorox-chat-height', $(window).height() + 'px');\n    }\n\n    $(window).on('resize', fixChatHeight);\n    fixChatHeight();\n}\n\nexport function fixChatPosition() {\n    const paletteHeight = $('#palette').innerHeight();\n    $('#chat').css('bottom', paletteHeight + 4);\n}\n\nexport function toggleEmojis(state) {\n    state ? $('#emotions').show() : $('#emotions').hide();\n}\n\nexport function updateEmojis(list) {\n    const container = $('#emotions');\n    let html = '';\n\n    for (let el of list) {\n        html += `<div class=\"emotion\">${el}</div>`;\n    }\n\n    container.html(html);\n\n    $('div', container).on('click', e => {\n        $('#chatInput')[0].value += e.target.innerText;\n        $('#chatInput').trigger('focus');\n    })\n}\n\nexport default globals.chat = chat;","import Pattern from './Pattern';\nimport {\n    chunkSize,\n    bgrPalette,\n    game\n} from './config'\nimport protectedPatternUrl from '../img/protectedPattern.png';\nimport { getLS } from './utils/localStorage';\n\nexport default class Chunk {\n    constructor(x, y, buffer) {\n        this.x = x;\n        this.y = y;\n\n        this.width = chunkSize;\n        this.height = chunkSize;\n\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.canvas.height = chunkSize;\n\n        this.ctx = this.canvas.getContext('2d');\n\n        this.imgData = this.ctx.createImageData(chunkSize, chunkSize);\n        this.view = new Uint32Array(this.imgData.data.buffer);\n\n        // protected\n\n        // chunksized means the canvas with sizes of the chunk, filled with \"protected\" pattern\n        this.protectedPatternChunkSized = null;\n        this._protectedPattern = new Pattern(protectedPatternUrl);\n        this._protectedPattern.onload = () => {\n            this.needRender = true;\n            // pattern shift is an offset, to shift\n            // the texture for current chunk, because it might not\n            // be dividable by chunk size (pattern misjoint between chunks in result)\n            const patternShift = [\n                (this.x * this.width) % this._protectedPattern.canvas.width,\n                (this.y * this.height) % this._protectedPattern.canvas.height\n            ]\n\n            if(getLS('protectDebug') === '1'){\n                const canv = this.protectedPatternChunkSized = document.createElement('canvas');\n                canv.width = this.width; canv.height = this.height;\n                const canvCtx = canv.getContext('2d');\n                canvCtx.fillStyle = 'rgb(0,255,0)';\n                canvCtx.fillRect(0, 0, this.width, this.height);\n            }else{\n                this.protectedPatternChunkSized = this._protectedPattern.createFilledCanvas(this.width, this.height, patternShift[0], patternShift[1]);\n            }\n        }\n\n        this.pCanvas = document.createElement('canvas');\n        this.pCanvas.width = this.pCanvas.height = chunkSize;\n\n        this.pCtx = this.pCanvas.getContext('2d');\n        this.pImgData = this.pCtx.createImageData(chunkSize, chunkSize);\n        this.pView = new Uint32Array(this.pImgData.data.buffer);\n\n        this.needRender = true;\n\n        this.fromBuffer(buffer);\n    }\n\n\n    render() {\n        if (this.needRender) {\n            this.needRender = false;\n            this.ctx.putImageData(this.imgData, 0, 0);\n\n            if (game.showProtected) {\n                if(getLS('protectDebug') === '1'){\n                    this.ctx.globalAlpha = 1;\n                }else{\n                    this.ctx.globalAlpha = 0.7;\n                }\n\n                this.pCtx.putImageData(this.pImgData, 0, 0);\n                if(this.protectedPatternChunkSized !== null){\n                    this.pCtx.globalCompositeOperation = 'source-in';\n                    this.pCtx.drawImage(this.protectedPatternChunkSized, 0, 0);\n                    this.pCtx.globalCompositeOperation = 'source-over'; // back to default\n                }\n\n                this.ctx.drawImage(this.pCanvas, 0, 0);\n\n                this.ctx.globalAlpha = 1;\n            }\n        }\n    }\n\n    fromBuffer(buf) {\n        let col, isProtected;\n        for (let i = 0; i < buf.byteLength; i++) {\n            col = buf[i];\n            isProtected = col & 0x80;\n\n            isProtected && (this.pView[i] = 0xFFFF0000);\n            this.view[i] = bgrPalette[col & 0x7F];\n        }\n    }\n\n    get(x, y) {\n        return this.view[x + y * chunkSize]\n    }\n\n    set(x, y, c) {\n        const i = x + y * chunkSize\n\n        this.view[i] = c;\n\n        this.needRender = true;\n    }\n    setProtect(x, y, state) {\n        const i = x + y * chunkSize;\n        this.pView[i] = state ? 0xFFFF0000 : 0;\n\n        this.needRender = true;\n    }\n\n    getProtect(x, y) {\n        const i = x + y * chunkSize;\n        return !!this.pView[i];\n    }\n}","import globals from './globals';\nimport Chunk from './Chunk';\nimport {\n    bgrPalette,\n    argbToId,\n    boardWidth, boardHeight, chunkSize, canvasId\n} from './config';\nimport {\n    boardToChunk\n} from './utils/conversions'\nimport TempChunkPlaceholder from './TempChunkPlaceholder';\nimport { apiRequest } from './utils/api';\nimport { getLS, setLS } from './utils/localStorage';\nimport { isChunkVisible } from './utils/camera';\n\nconst CHUNK_LOADING_THREADS = 5;\nconst CHUNK_CACHE_NAME = 'chunks-cache-v1';\nconst cacheApiSupported = ('caches' in window);\n\nexport default class ChunkManager {\n    constructor() {\n        this.chunks = new Map();\n\n        this.loadingChunks = new Set();\n\n        this.checkQueue = [];\n        this._checkInterval = null;\n        this.checking = false;\n        this.chunkHashes = null;\n\n        // globals.socket.on('chunk', (cx, cy, cdata) => {\n        //     let key = this.getChunkKey(cx, cy);\n        //     if (this.loadingChunks.has(key)){\n        //         this.loadingChunks.delete(key);\n        //     }\n\n        //     let chunk = new Chunk(cx, cy, cdata);\n        //     this.chunks.set(key, chunk);\n\n        //     globals.renderer.needRender = true;\n        // })\n\n        globals.socket.on('place', (x, y, col) => {\n            this.setChunkPixel(x, y, col);\n\n            globals.renderer.needRender = true;\n        })\n\n        globals.socket.on('protect', (x, y, state) => {\n            this.setProtect(x, y, state);\n\n            globals.renderer.needRender = true;\n        });\n\n        this.init();\n    }\n\n    init() {\n        this.loadSavedChunkHashes();\n        this.initCheckInterval();\n    }\n\n    loadSavedChunkHashes() {\n        this.chunkHashes = JSON.parse(getLS(`chunkHashes`, true)) ?? {};\n    }\n    saveChunkHashes() {\n        setLS(`chunkHashes`, JSON.stringify(this.chunkHashes), true);\n    }\n\n    initCheckInterval() {\n        this._checkInterval = setInterval(async () => {\n            if (!this.checkQueue.length || this.checking) return;\n            this.checking = true;\n\n            // console.log(this.checkQueue.size);\n\n            try {\n                // converting to array to remove checked chunks\n                const asArr = this.checkQueue//[...this.checkQueue];\n                await this.checkChunks(asArr.splice(0, 32).map(this.fromChunkKey));\n\n                // this.checkQueue = new Set(asArr);\n            } finally {\n                this.checking = false;\n            }\n        }, 1);\n    }\n\n    async checkChunks(chunkList) {\n        // some chunks may not have hash\n        let chunksListFinal = [];\n        let hashList = [];\n        for (let [cx, cy] of chunkList) {\n            if (!isChunkVisible(cx, cy)) continue;\n            if (this.loadingChunks.has(this.getChunkKey(cx, cy))) continue;\n\n            const hash = this.chunkHashes[`${cx},${cy}`];\n            if (typeof hash === 'string' && hash.length >= 16) {\n                // this is intentional: the array is flattened\n                chunksListFinal.push(cx, cy);\n                hashList.push(hash);\n            } else {\n                this.requestChunk(cx, cy);\n            }\n        }\n\n        if (!hashList.length) return;\n\n        const chunksFormatted = JSON.stringify(chunksListFinal);\n        const hashesFormatted = JSON.stringify(hashList);\n\n        const params = new URLSearchParams();\n        params.set('canvas', canvasId);\n        params.set('chunks', chunksFormatted);\n        params.set('hashes', hashesFormatted);\n\n        const resp = await apiRequest(`/chunks/check?${params.toString()}`);\n\n        const respData = await resp.json();\n        if (respData.errors) return;\n\n        if (!Array.isArray(respData)) {\n            throw new Error('Server returned unknown shit: ' + respData);\n        }\n\n        for (let i = 0; i < chunksListFinal.length; i += 2) {\n            const [cx, cy] = [chunksListFinal[i], chunksListFinal[i + 1]];\n\n            const isActual = respData[i / 2];\n            if (isActual) {\n                this.loadChunkFromCache(cx, cy);\n            } else {\n                delete this.chunkHashes[`${cx},${cy}`];\n                this.saveChunkHashes();\n\n                this.requestChunk(cx, cy);\n            }\n        }\n    }\n\n    clearChunks() {\n        this.chunks.clear();\n    }\n\n    getChunkKey(x, y) {\n        return x << 16 | y\n    }\n\n    fromChunkKey(key) {\n        return [\n            key >> 16,\n            key & 0xFFFF\n        ]\n    }\n\n    reloadChunks(chunksToReload) {\n        if (!chunksToReload) {\n            this.clearChunks();\n        } else {\n            for (const { x: cx, y: cy } of chunksToReload) {\n                this.chunks.delete(this.getChunkKey(cx, cy));\n            }\n        }\n    }\n\n    async requestChunk(x, y) {\n        let key = this.getChunkKey(x, y);\n\n        if (!this.loadingChunks.has(key) &&\n            this.loadingChunks.size < CHUNK_LOADING_THREADS) {\n\n            this.loadingChunks.add(key);\n\n            try {\n                const resp = await apiRequest(`/chunks/get?canvas=${canvasId}&x=${x}&y=${y}`, {\n                    credentials: 'omit'\n                });\n\n                const newHash = resp.headers.get('X-Compressed-Hash');\n                if (newHash && cacheApiSupported) {\n                    this.chunkHashes[`${x},${y}`] = newHash;\n                    this.saveChunkHashes();\n\n                    const cache = await caches.open(CHUNK_CACHE_NAME);\n                    await cache.put(`${canvasId}-${x}-${y}`, resp.clone());\n                }\n\n                // use pako only if chunk got from socket\n                // const cdataCompressed = await resp.arrayBuffer();\n                // const cdata = Pako.inflate(cdataCompressed);\n\n                await this.loadChunkFromResp(x, y, resp);\n            } finally {\n                if (this.loadingChunks.has(key)) {\n                    this.loadingChunks.delete(key);\n                }\n            }\n            // globals.socket.requestChunk(x, y);\n        }\n    }\n\n    async loadChunkFromCache(x, y) {\n        const chunkKey = this.getChunkKey(x, y);\n        if (this.loadingChunks.has(chunkKey)) return;\n\n        this.loadingChunks.add(chunkKey);\n\n        try {\n            const cache = await caches.open(CHUNK_CACHE_NAME);\n            const resp = await cache.match(`${canvasId}-${x}-${y}`);\n            if (!resp) {\n                delete this.chunkHashes[`${x},${y}`];\n                this.saveChunkHashes();\n\n                this.loadChunk(x, y);\n                return;\n            }\n\n            await this.loadChunkFromResp(x, y, resp, true);\n\n        } finally {\n            this.loadingChunks.delete(chunkKey);\n        }\n    }\n\n    async loadChunkFromResp(x, y, resp, cached = false) {\n        const cdata = await resp.arrayBuffer();\n\n        let chunk = new Chunk(x, y, new Uint8Array(cdata));\n        this.chunks.set(this.getChunkKey(x, y), chunk);\n\n        if (!cached) {\n            chunk.render(); // workaround because TempChunkPlaceholder getting zeroes until chunk is rendered once\n            new TempChunkPlaceholder(x, y).save(chunk.canvas);\n        }\n\n        globals.renderer.needRender = true;\n    }\n\n    reRenderAll() {\n        for (const [_, chunk] of this.chunks) {\n            chunk.needRender = true;\n        }\n    }\n\n    loadChunk(x, y) {\n        if (!cacheApiSupported) {\n            // old method (threaded chunk queue)\n            this.requestChunk(x, y);\n            return;\n        }\n\n        // new method (bulk chunk check for updates)\n        const chunkKey = this.getChunkKey(x, y);\n        if (this.checkQueue.includes(chunkKey) || this.checking || this.loadingChunks.has(chunkKey)) {\n            return;\n        }\n\n        this.checkQueue.push(this.getChunkKey(x, y));\n    }\n\n    clearLoadingChunks() {\n        this.loadingChunks = new Set;\n    }\n\n    hasChunk(x, y) {\n        let key = this.getChunkKey(x, y);\n\n        return this.chunks.has(key);\n    }\n\n    getChunk(x, y) {\n        let key = this.getChunkKey(x, y);\n\n        if (!this.chunks.has(key)) {\n            return 0\n        }\n        return this.chunks.get(key)\n    }\n\n    getChunkPixel(x, y) {\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\n        let chunk = this.getChunk(cx, cy);\n\n        if (!chunk || x < 0 || y < 0) return -1\n\n        let argb = chunk.get(offx, offy);\n\n        return argbToId[argb]\n    }\n\n    setChunkPixel(x, y, col) {\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\n\n        let key = this.getChunkKey(cx, cy);\n        if (this.chunks.has(key)) {\n            this.chunks.get(key).set(offx, offy, bgrPalette[col])\n        }\n    }\n\n    setProtect(x, y, state) {\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\n\n        let key = this.getChunkKey(cx, cy);\n        if (this.chunks.has(key)) {\n            this.chunks.get(key).setProtect(offx, offy, state)\n        }\n    }\n\n    getProtect(x, y) {\n        let [cx, cy, offx, offy] = boardToChunk(x, y);\n        let chunk = this.getChunk(cx, cy);\n        if (!chunk) return -1\n\n        return chunk.getProtect(offx, offy);\n    }\n\n    // for the screenshot function\n    dumpAll() {\n        const canvas = document.createElement('canvas');\n        canvas.width = boardWidth;\n        canvas.height = boardHeight;\n\n        const ctx = canvas.getContext('2d');\n\n        this.chunks.forEach(chunk => {\n            if (!chunk.canvas) return;\n\n            const offX = chunk.x * chunkSize,\n                offY = chunk.y * chunkSize;\n\n            ctx.drawImage(chunk.canvas, offX, offY)\n        })\n        return canvas\n    }\n\n\n    dumpZone(startX, startY, w, h) {\n        const canvas = document.createElement('canvas');\n        canvas.width = w;\n        canvas.height = h;\n\n        const ctx = canvas.getContext('2d');\n\n        const startChunkX = Math.floor(startX / chunkSize),\n            startChunkY = Math.floor(startY / chunkSize),\n            endChunkX = Math.floor((startX + w) / chunkSize),\n            endChunkY = Math.floor((startY + h) / chunkSize);\n\n        for (let cx = startChunkX; cx <= endChunkX; cx++) {\n            for (let cy = startChunkY; cy <= endChunkY; cy++) {\n                const chunk = this.getChunk(cx, cy);\n                if (!chunk || !chunk.canvas) continue;\n\n                const offX = (chunk.x * chunkSize) - startX,\n                    offY = (chunk.y * chunkSize) - startY;\n\n                ctx.drawImage(chunk.canvas, offX, offY);\n            }\n        }\n\n        return canvas;\n    }\n}","import EventEmitter from 'events';\nimport { translate as t } from './translate';\n\nexport default class MiniWindow extends EventEmitter {\n    // 0=0 1=ok, 2=ok+cancel\n    constructor(title = '', closeButtons = 1, movable=false) {\n        super();\n\n        this.title = title;\n\n        this._closeButtons = closeButtons;\n\n        this.element = null;\n        this.bodyElement = null;\n\n        this.closed = false;\n\n        this._create();\n        if(movable){\n            this.makeMovable();\n        }\n    }\n\n    _create() {\n        const html = $(`\n        <div class=\"miniWindow\">\n            <div class=\"miniWindowTitle\">\n                ${this.title}\n            </div>\n            <div class=\"miniWindowBody\">\n            </div>\n            <div class=\"miniWindowButtons\">\n            </div>\n        </div>\n        `);\n\n        const buttons = [];\n        if (this._closeButtons >= 1) {\n            const okButton = $(`<button>${t('OK')}</button>`);\n            okButton.on('click', this.buttonHandler.bind(this, 'ok'));\n            buttons.push(okButton);\n        }\n        if (this._closeButtons >= 2) {\n            const cancelButton = $(`<button>${t('Cancel')}</button>`);\n            cancelButton.on('click', this.buttonHandler.bind(this, 'cancel'));\n            buttons.push(cancelButton);\n        }\n\n        buttons.forEach(b => $('.miniWindowButtons', html).append(b));\n\n        this.element = html;\n        this.bodyElement = $('.miniWindowBody', html);\n    }\n\n    moveTo(x, y) {\n        const rect = this.element[0].getBoundingClientRect();\n        const w = rect.width,\n            h = rect.height;\n\n        this.x = Math.max(-w + 10, x);\n        this.y = Math.max(-h + 10, y);\n\n        this.x = Math.min(window.innerWidth - 10, this.x);\n        this.y = Math.min(window.innerHeight - 10, this.y);\n    }\n\n    moveBy(x, y) {\n        this.moveTo(this.x + x, this.y + y);\n    }\n\n    makeMovable() {\n        this.element.find('.miniWindowTitle').on('pointerdown', e => {\n            let self = this;\n            let lastX = e.clientX;\n            let lastY = e.clientY;\n            \n            const $doc = $(document);\n            $doc.on('pointermove', moved)\n\n            function moved(e) {\n                e = e.originalEvent;\n                let movedX = e.clientX - lastX;\n                let movedY = e.clientY - lastY;\n\n                lastX = e.clientX;\n                lastY = e.clientY;\n\n                self.moveBy(movedX, movedY);\n            }\n\n            $doc.one('pointerup pointerleave', () => {\n                $doc.off('pointermove', moved);\n            });\n        });\n\n        $(this.body).on('pointerdown', e => {\n            e.stopPropagation();\n        })\n    }\n\n    buttonHandler(buttonName) {\n        const event = {\n            _cancelledClose: false,\n            cancelClose: function () { this._cancelledClose = true }\n        }\n\n        switch (buttonName) {\n            case 'ok':\n                this.emit('okClicked', event);\n                break;\n            case 'cancel':\n                this.emit('cancelClicked', event);\n        }\n\n        if (!event._cancelledClose) {\n            this.close();\n        }\n    }\n\n    center() {\n        if (!this.element || this.closed) {\n            return;\n        }\n\n        const $window = $(window);\n        const windowWidth = $window.width();\n        const windowHeight = $window.height();\n\n        const elementWidth = this.element.outerWidth();\n        const elementHeight = this.element.outerHeight();\n\n        const left = Math.max(0, (windowWidth - elementWidth) / 2);\n        const top = Math.max(0, (windowHeight - elementHeight) / 2);\n\n        this.element.css({\n            position: 'fixed',\n            left: left + 'px',\n            top: top + 'px',\n            transform: 'none'\n        });\n    }\n\n    get x() {\n        return parseInt(this.element.css('left'));\n    }\n    set x(value) {\n        this.element.css('left', value + 'px');\n    }\n\n    get y() {\n        return parseInt(this.element.css('top'));\n    }\n    set y(value) {\n        this.element.css('top', value + 'px');\n    }\n\n    get w(){\n        return this.element[0].getBoundingClientRect().width;\n    }\n    get h(){\n        return this.element[0].getBoundingClientRect().height;\n    }\n\n    pos() {\n\n    }\n\n    close() {\n        this.removeAllListeners();\n        this.element.remove();\n        this.closed = true;\n    }\n}\n\nexport class SelectMiniWindow extends MiniWindow {\n    constructor(selects, callback, title) {\n        if (!selects.length) throw new Error('no selects, no way to close the window!');\n\n        super(title, 0);\n\n        this.selects = selects;\n        this.callback = callback;\n        this._sel_create();\n    }\n\n    _sel_create() {\n        for (const select of this.selects) {\n            const selectEl = $(`<button>${select.text}</button>`);\n            selectEl.one('click', () => this.onChosen(select.id));\n\n            this.bodyElement.append(selectEl);\n        }\n    }\n\n    onChosen(id) {\n        this.close();\n\n        this.callback(id);\n    }\n}","export default class Pattern{\n    constructor(url){\n        this.url = url;\n        this.loaded = false;\n\n        this.canvas = null\n\n        this._load()\n    }\n\n    _load(){\n        const canvas = document.createElement('canvas');\n        \n        const img = new Image();\n        img.src = this.url;\n\n        img.onload = () => {\n            canvas.width = img.width;\n            canvas.height = img.height;\n\n            canvas.getContext('2d').drawImage(img, 0, 0);\n\n            this.canvas = canvas;\n\n            this.loaded = true;\n            this.onload();\n        }\n    }\n\n    createFilledCanvas(width, height, offsetX, offsetY){\n        const ctx = this.canvas.getContext('2d');\n        const pattern = ctx.createPattern(this.canvas, 'repeat');\n\n        const filledCanvas = document.createElement('canvas');\n        filledCanvas.width = width;\n        filledCanvas.height = height;\n\n        const filledCtx = filledCanvas.getContext('2d');\n        \n        filledCtx.fillStyle = pattern;\n        \n        // this \"save restore\" shit is copied from stackoverflow\n        // it's needed to actually shift the pattern\n        filledCtx.save();\n        filledCtx.translate(offsetX, offsetY);\n        filledCtx.fillRect(-offsetX, -offsetY, width, height);\n        filledCtx.restore();\n\n        return filledCanvas;\n    }\n\n    onload(){}\n}","import ChunkPlaceholder from '../img/chunkPlaceholder.png';\nimport camera from './camera';\nimport { chunkSize, hexPalette } from './config';\nimport globals from './globals';\nimport Pattern from './Pattern';\nimport { getVisibleChunks } from './utils/camera';\nimport {\n    halfMap,\n    insanelyLongMobileBrowserCheck\n} from './utils/misc';\nimport template from './template';\nimport shapes from './utils/shapes';\nimport player from './player';\nimport TempChunkPlaceholder from './TempChunkPlaceholder';\n\nconst isMobile = insanelyLongMobileBrowserCheck();\n\n\nexport default class Renderer {\n    /**\n     * \n     * @param {CanvasRenderingContext2D} ctx \n     */\n    constructor(ctx) {\n        this.ctx = ctx;\n        this.canvas = this.ctx.canvas;\n\n        this.chunkPlaceholderPattern = new Pattern(ChunkPlaceholder);\n        this.chunkPlaceholderPattern.onload = () => {\n            this.needRender = true;\n        }\n        this.chunkPreviews = {};\n\n        this.needRender = true;\n\n        this.preRendered = {\n            brush: {\n                canvas: undefined,\n                ctx: undefined,\n                imageData: undefined,\n\n                circle: undefined,\n            }\n        }\n\n        this.preRender();\n        this.initAndroidGcChecker();\n    }\n\n    preRender() {\n        this.preRenderBrush();\n    }\n\n    preRenderBrush() {\n        // TODO make it render only before brush used\n        // because it renders on every zoom\n        const size = player.brushSize,\n            zoom = camera.zoom;\n\n        if (zoom < 1) return\n\n        const canvas = document.createElement('canvas');\n        canvas.width = canvas.height = zoom * (size+2);\n        const ctx = canvas.getContext('2d');\n\n        let r = Math.floor(size / 2);\n        \n        let circle\n        if(size === 2){\n            r = 0;\n            circle = [[0,0],[1,0],[0,1],[1,1]]\n        }else{\n            circle = shapes.filledCircle(0, 0, r+1);\n        }\n        let circleMatrix = [];\n        for (let y = 0; y < size + 1; y++) {\n            circleMatrix.push((new Array(size + 1)).fill(0))\n        }\n\n        circle.forEach(([x, y]) => {\n            circleMatrix[x + r][y + r] = 1;\n        })\n\n        const lineW = zoom / 8;\n        const halfLineW = lineW / 2;\n\n        ctx.beginPath();\n        ctx.lineWidth = lineW;\n        ctx.strokeStyle = hexPalette[player.color];\n        ctx.lineCap = 'butt';\n\n        for (let x = 0; x < size; x++) {\n            for (let y = 0; y < size; y++) {\n                if (isBound(x, y)) continue;\n\n                let upper = isBound(x, y - 1),\n                    left = isBound(x - 1, y),\n                    right = isBound(x + 1, y),\n                    bottom = isBound(x, y + 1);\n\n                if (upper) {\n                    // the margin is for join neighbouring lines\n                    const margin = !isBound(x + 1, y) ? lineW : 0;\n\n                    ctx.moveTo(x * zoom, y * zoom + halfLineW);\n                    ctx.lineTo((x + 1) * zoom + margin, y * zoom + halfLineW);\n                }\n                if (left) {\n                    const margin = !isBound(x, y - 1) ? lineW : 0;\n\n                    ctx.moveTo(x * zoom + halfLineW, y * zoom - margin);\n                    ctx.lineTo(x * zoom + halfLineW, (y + 1) * zoom);\n                }\n                if (right) {\n                    const margin = !isBound(x, y + 1) ? lineW : 0;\n                    \n                    ctx.moveTo((x + 1) * zoom - halfLineW, y * zoom);\n                    ctx.lineTo((x + 1) * zoom - halfLineW, (y + 1) * zoom + margin);\n                }\n                if (bottom) {\n                    const margin = !isBound(x - 1, y) ? lineW : 0;\n\n                    ctx.moveTo((x + 1) * zoom, (y + 1) * zoom - halfLineW);\n                    ctx.lineTo(x * zoom - margin, (y + 1) * zoom - halfLineW);\n                }\n            }\n        }\n\n        ctx.stroke();\n        ctx.closePath();\n\n        function isBound(x, y) {\n            if (x < 0 || x >= size || y < 0 || y >= size) return true;\n\n            return !circleMatrix[x][y];\n        }\n\n        this.preRendered.brush.canvas = canvas;\n        this.preRendered.brush.ctx = canvas;\n        this.preRendered.brush.imageData = canvas;\n        this.preRendered.brush.circle = circle;\n    }\n\n    initAndroidGcChecker() {\n        setInterval(() => {\n            this.checkAndroidGc();\n        }, 1000);\n    }\n\n    // check chunks for being cleared by aggressive android gc\n    checkAndroidGc() {\n        if (!globals.mobile) return;\n        const bad = this.ctx.imageSmoothingEnabled;\n        if (bad) {\n            console.log('detected broken render, repairing');\n\n            // workaround\n            window.onresize();\n\n            globals.chunkManager.reRenderAll();\n        }\n    }\n\n    requestRender() {\n        if (this.needRender) {\n            this.needRender = false;\n\n            this.render()\n        }\n\n        globals.fxRenderer.render();\n    }\n\n    correctSmoothing() {\n        if (isMobile) return;\n\n        if (camera.zoom < 1) {\n            this.ctx.imageSmoothingEnabled = true;\n            this.ctx.canvas.style.imageRendering = 'auto'\n        } else {\n            this.ctx.imageSmoothingEnabled = false;\n            this.ctx.canvas.style.imageRendering = 'pixelated'\n        }\n    }\n\n    render() {\n        // smooth when zoom < 1, pixelated otherwise\n        this.correctSmoothing();\n\n        let visibleChunks = getVisibleChunks();\n\n        // clear veiwport\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        let camX = camera.x + halfMap[0] - ((this.canvas.width >> 1) / camera.zoom);\n        let camY = camera.y + halfMap[1] - ((this.canvas.height >> 1) / camera.zoom);\n\n        let zoom = camera.zoom;\n\n        if (zoom === 1) {\n            // for Firefox, to render normally at least on zoom 1\n            camX = Math.floor(camX)\n            camY = Math.floor(camY)\n        }\n\n        this.ctx.save();\n        this.ctx.translate(Math.floor(-camX * zoom), Math.floor(-camY * zoom));\n        this.ctx.scale(zoom, zoom);\n\n        visibleChunks.forEach(chunkCord => {\n            let [cx, cy] = chunkCord;\n\n            let offX = cx * chunkSize;\n            let offY = cy * chunkSize;\n\n\n            if (!globals.chunkManager.hasChunk(cx, cy)) {\n                globals.chunkManager.loadChunk(cx, cy);\n\n                // search for chunk preview placeholder\n                let chunkPreview = this.chunkPreviews[`${cx}-${cy}`];\n                if (!chunkPreview) {\n                    // create one if not found (one-time op)\n                    chunkPreview = this.chunkPreviews[`${cx}-${cy}`] = {\n                        loaded: false,\n                        data: null\n                    };\n                    new TempChunkPlaceholder(cx, cy).load().then(imgData => {\n                        chunkPreview.data = imgData;\n                        chunkPreview.loaded = true;\n                        this.needRender = true;\n                    });\n                } else if (chunkPreview.loaded && chunkPreview.data !== null) {\n                    // or, render it if it's loaded and found in db\n                    this.ctx.drawImage(chunkPreview.data, offX, offY, chunkSize, chunkSize);\n\n                    // also render default placeholder over it, to clarify we are dealing with preview\n                    if (this.chunkPlaceholderPattern.loaded) {\n                        this.ctx.globalAlpha = 0.5;\n                        this.ctx.drawImage(this.chunkPlaceholderPattern.canvas, offX, offY, chunkSize, chunkSize);\n                        this.ctx.globalAlpha = 1;\n                    }\n                } else {\n\n                    // fallback to default placeholder if available\n                    if (this.chunkPlaceholderPattern.loaded)\n                        this.ctx.drawImage(this.chunkPlaceholderPattern.canvas, offX, offY, chunkSize, chunkSize);\n                }\n\n                return\n            }\n\n            const chunk = globals.chunkManager.getChunk(cx, cy);\n\n            chunk.render();\n            this.ctx.drawImage(chunk.ctx.canvas, offX, offY);\n        });\n\n        this.ctx.restore();\n    }\n}\n\n","import EventEmitter from 'events';\nimport pako from 'pako'\n\nimport {\n    OPCODES,\n    STRING_OPCODES\n} from './protocol';\nimport {\n    canvasId,\n    canvasName,\n    allColors\n} from './config'\nimport globals from './globals'\nimport User from './user';\nimport chat from './Chat';\nimport { captchaModal } from './windows';\nimport Window, { Modal } from './Window';\nimport player, { updatePlaced } from './player';\nimport { translate as t } from './translate';\nimport { htmlspecialchars } from './utils/misc';\nimport workers from '../workers';\n\nexport default class Socket extends EventEmitter {\n    constructor(port) {\n        super();\n\n        const scheme = location.protocol.startsWith('https') ? 'wss' : 'ws';\n        const host = location.hostname || 'localhost';\n        this.url = `${scheme}://${host}:${port}`;\n\n        this.pendingPixels = {};\n\n        this.connectedOnce = false;\n\n        this.reconnectFactor = 1;\n\n        this.keepAliveInterval = null;\n        this.alive = false;\n\n        this.serverJitter = 0;\n\n        this.connect();\n    }\n\n    get connected() {\n        return this.socket && this.socket.readyState === WebSocket.OPEN\n    }\n\n    connect() {\n        this.socket = new WebSocket(this.url);\n        this.socket.binaryType = 'arraybuffer';\n\n        this.socket.onopen = () => {\n            this.sendChatSubscribe('global', this.connectedOnce);\n            this.sendChatSubscribe(canvasName, this.connectedOnce);\n            this.sendCanvas(canvasId);\n\n            this.emit('opened');\n            console.log('Socket has been connected');\n\n            if (!this.connectedOnce) this.connectedOnce = true;\n\n            clearInterval(this.keepAliveInterval);\n            this.keepAliveInterval = setInterval(() => {\n                if (!this.connected) return;\n                if (!this.alive) return this.close();\n                this.alive = false;\n            }, 45000);\n        }\n\n        this.socket.onmessage = this.onmessage.bind(this);\n\n        this.socket.onclose = () => {\n            this.emit('closed');\n            clearInterval(this.keepAliveInterval);\n\n            Object.values(globals.users).forEach(u => u.close(u.id));\n            globals.users = {};\n\n            globals.chunkManager.clearLoadingChunks();\n\n            const reconnectDelay = Math.min(this.reconnectFactor * 1000 - Math.random() * 1000, 10_000);\n            setTimeout(() => {\n                console.log('reconnect');\n                this.reconnect();\n                this.reconnectFactor *= 1.5;\n            }, reconnectDelay);\n        }\n    }\n\n    close() {\n        this.socket.close();\n    }\n\n    reconnect() {\n        this.socket.onmessage = null;\n        this.socket.onopen = null;\n        this.socket.onclose = null;\n\n        this.connect();\n    }\n\n    onmessage({\n        data: message\n    }) {\n        if (typeof message === 'string') {\n            this.onStringMessage(message);\n        } else {\n            // must be ping\n            if (!message.byteLength) return;\n\n            this.onBinaryMessage(message);\n        }\n    }\n\n    onStringMessage(msg) {\n        let decoded;\n        try {\n            decoded = JSON.parse(msg);\n        } catch (e) {\n            console.log('onStringMessage message decoding error: ' + e, 'message: ' + msg);\n            return\n        }\n\n        switch (decoded.c) {\n            case STRING_OPCODES.userJoin: {\n                const {\n                    nick: name,\n                    userId,\n                    id,\n                    registered,\n                    role\n                } = decoded;\n\n                let sameUser;\n                if (name) {\n                    sameUser = Object.values(globals.users).find(u => u.name === name);\n                }\n\n                if (sameUser) {\n                    globals.users[id] = sameUser;\n                    sameUser.newConnection(id);\n                } else {\n                    const user = globals.users[id] = new User(name, id, userId, registered, role);\n                    user.loadBadges()\n                        .then(user.updateBadges.bind(user))\n                        .catch(e => console.error('failed to load badges', e));\n                }\n\n                break\n            }\n\n            case STRING_OPCODES.userLeave: {\n                const id = decoded.id;\n\n                if (globals.users[id]) globals.users[id].close(id);\n\n                break\n            }\n\n            case STRING_OPCODES.error: {\n                decoded.errors.forEach(error => {\n                    if (error === 'error.captcha') {\n                        if (!Window.Exists('Captcha'))\n                            captchaModal();\n                    }\n                    let msg;\n                    if (typeof error === 'object') {\n                        msg = t('socketErr.' + error.msg) + error.data ?? '';\n                    } else {\n                        msg = t('socketErr.' + error);\n                    }\n                    toastr.error(msg, t('Error from the Socket:'), {\n                        preventDuplicates: true,\n                        timeOut: 30000,\n                    });\n                });\n\n                break;\n            }\n\n            case STRING_OPCODES.chatMessage: {\n                chat.addMessage(decoded)\n\n                break\n            }\n\n            case STRING_OPCODES.alert: {\n                // todo  \n                if (decoded.type === 0) {\n                    toastr.info(decoded.msg, 'ALERT', {\n                        timeOut: 1000 * 60 * 5,\n                        extendedTimeOut: 1000 * 60 * 5\n                    });\n                } else {\n                    const safeMsg = htmlspecialchars(decoded.msg);\n                    const m = new Modal;\n                    m.init();\n                    const mBody = $(\n                        `<div style=\"margin:0;padding:5px;text-align:center;\">\n                            <h1>ADMIN:</h1>\n                            <p>${safeMsg}</p>\n                            <button style=\"padding: 8px;\">OK</button>\n                        </div>`)\n                    m.contEl.appendChild(mBody[0]);\n\n                    $('button', mBody).on('click', () => {\n                        m.close();\n                    });\n                }\n                break\n            }\n\n            case STRING_OPCODES.me: {\n                player.id = decoded.id;\n                break\n            }\n\n            case STRING_OPCODES.reload: {\n                location.reload();\n                break\n            }\n\n            case STRING_OPCODES.reloadChunks: {\n                const toReload = decoded.chunks;\n                globals.chunkManager.reloadChunks(toReload);\n                break\n            }\n        }\n    }\n\n    onBinaryMessage(msg) {\n        const dv = new DataView(msg);\n\n        switch (dv.getUint8(0)) {\n            case OPCODES.captcha: {\n                captchaModal();\n                break\n            }\n            case OPCODES.chunk: {\n                const cx = dv.getUint8(1);\n                const cy = dv.getUint8(2);\n\n                const chunkData = pako.inflate(dv.buffer.slice(3));\n\n                this.emit('chunk', cx, cy, chunkData);\n\n                break\n            }\n\n            case OPCODES.place: {\n                const x = dv.getUint16(1);\n                const y = dv.getUint16(3);\n                const col = dv.getUint8(5);\n\n                const id = dv.getUint32(5);\n\n                this.onIncomingPixel([x, y, col], id);\n                break\n            }\n\n            case OPCODES.online: {\n                const count = dv.getUint16(1);\n\n                this.emit('online', count);\n                break\n            }\n\n            case OPCODES.pixels: {\n                const isProtect = !!dv.getUint8(1),\n                    uid = dv.getUint32(2, false);\n                let x, y, col;\n                for (let i = 6; i < dv.byteLength; i += 5) {\n                    x = dv.getUint16(i);\n                    y = dv.getUint16(i + 2);\n                    col = dv.getUint8(i + 4);\n\n                    if (col > allColors.length) continue;\n\n                    if (isProtect) {\n                        this.emit('protect', x, y, col);\n                    } else {\n                        this.emit('place', x, y, col, uid);\n                    }\n                }\n\n                const user = globals.users[uid];\n                if (user) user.updateCoords(col, x, y);\n\n                break\n            }\n\n            case OPCODES.ping: {\n                this.alive = true;\n                this.reconnectFactor = 1;\n\n                const serverTime = Number(dv.getBigUint64(1, false));\n                this.serverJitter = Date.now() - serverTime;\n\n                this.socket.send(new Uint8Array([OPCODES.ping]));\n                break\n            }\n\n            case OPCODES.placeBatch: {\n                const PIXEL_LENGTH = 9;\n\n                const totalPixels = (dv.byteLength - 1) / PIXEL_LENGTH;\n                if (totalPixels % 1 !== 0) {\n                    console.warn('TotalPixels length is not integer');\n                }\n\n                for (let off = 1; off < dv.byteLength; off += PIXEL_LENGTH) {\n                    const x = dv.getUint16(off);\n                    const y = dv.getUint16(off + 2);\n                    const c = dv.getUint8(off + 4);\n                    const placerId = dv.getUint32(off + 5);\n\n                    if (c > allColors.length) continue;\n\n                    this.onIncomingPixel([x, y, c], placerId);\n                }\n                break\n            }\n\n            case OPCODES.updateRadio: {\n                const type = dv.getUint8(1);\n                this.emit('radio', type);\n                break\n            }\n\n            case OPCODES.pastePixels: {\n                const startX = dv.getInt16(1);\n                const startY = dv.getInt16(3);\n                const width = dv.getInt16(5);\n\n                const u8a = new Uint8Array(dv.buffer, 7);\n                workers.compressWorker.decompress(u8a).then(decompressed => {\n                    for (let i = 0; i < decompressed.length; i++) {\n                        const x = startX + (i % width);\n                        const y = startY + Math.floor(i / width);\n                        const col = decompressed[i];\n\n                        this.emit('place', x, y, col, 0);\n                    }\n                }).catch(err => {\n                    console.error('cannot decompress pastePixels data:', err);\n                });\n\n                break;\n            }\n        }\n    }\n\n    onIncomingPixel([x, y, col], id) {\n        const user = globals.users[id];\n        if (user) user.updateCoords(col, x, y);\n\n        const key = x + ',' + y;\n        let timeout = this.pendingPixels[key];\n        if (timeout) {\n            clearTimeout(timeout);\n            delete this.pendingPixels[key];\n        }\n\n        this.emit('place', x, y, col, id);\n\n        // does not work, id is not player id\n        // TODO: remove this? \n        if (id === player.id)\n            updatePlaced(player.placedCount++);\n    }\n\n    requestChunk(x, y) {\n        let dv = new DataView(new ArrayBuffer(1 + 1 + 1));\n        dv.setUint8(0, OPCODES.chunk);\n        dv.setUint8(1, x);\n        dv.setUint8(2, y);\n\n        this.socket.send(dv.buffer)\n    }\n\n    sendPixel(x, y, c) {\n        let dv = new DataView(new ArrayBuffer(1 + 5))\n\n        dv.setUint8(0, OPCODES.place);\n        dv.setUint16(1, x);\n        dv.setUint16(3, y);\n        dv.setUint8(5, c);\n\n        this.socket.send(dv.buffer);\n    }\n\n    sendPixels(pixels, isProtect = false) {\n        let dv = new DataView(new ArrayBuffer(6 + pixels.length * 5))\n\n        dv.setUint8(0, OPCODES.pixels);\n        dv.setUint8(1, isProtect ? 1 : 0); // isProtect\n        for (let i = 0; i < pixels.length; i++) {\n            let offset = i * 5 + 6;\n            const [x, y, col] = pixels[i];\n\n            dv.setUint16(offset, x);\n            dv.setUint16(offset + 2, y);\n            dv.setUint8(offset + 4, col);\n        }\n\n        this.socket.send(dv.buffer)\n    }\n\n    sendCanvas(id) {\n        const dv = new DataView(new ArrayBuffer(2));\n        dv.setUint8(0, OPCODES.canvas);\n        dv.setUint8(1, id);\n\n        this.socket.send(dv.buffer);\n    }\n\n    sendChatSubscribe(channel, isReconnect) {\n        const packet = {\n            c: STRING_OPCODES.subscribeChat,\n            ch: channel,\n            reconnect: isReconnect\n        }\n\n        this.socket.send(JSON.stringify(packet));\n    }\n\n    sendChatMessage(text, channel, whisper = false) {\n        const packet = {\n            c: STRING_OPCODES.chatMessage,\n            msg: text,\n            ch: channel\n        }\n\n        if (whisper) packet.whisper = whisper;\n\n        this.socket.send(JSON.stringify(packet));\n    }\n\n    sendChatWhisper(text, channel, whisperId) {\n        return this.sendChatMessage(text, channel, whisperId);\n    }\n\n    sendAlert(to, text, isModal = false) {\n        const packet = {\n            c: STRING_OPCODES.alert,\n            to,\n            msg: text,\n            type: isModal ? 1 : 0\n        }\n\n        this.socket.send(JSON.stringify(packet));\n    }\n}","// this class is for loading/getting saved chunk placeholder,\n// based on the previous loaded chunk image\n\nimport { canvasId, chunkSize } from './config.js';\nimport * as idxDb from './indexedDb.js'\nimport { resizeCanvas } from './utils/misc';\n\nexport default class TempChunkPlaceholder {\n    constructor(chunkX, chunkY) {\n        this.x = chunkX;\n        this.y = chunkY;\n    }\n\n    // load from localStorage\n    async load() {\n        return new Promise((res, rej) => {\n            const dbKey = `${canvasId}-${this.x}-${this.y}`;\n            idxDb.addInitCallback(async () => {\n                try {\n                    const chunkData = await this._loadFromDb(dbKey);\n                    const chunkCanvas = this._fromData(chunkData);\n\n                    res(chunkCanvas);\n                } catch (error) {\n                    rej(error);\n                }\n            })\n        })\n    }\n\n    async _loadFromDb(dbKey) {\n        return new Promise((res, rej) => {\n            let transaction = idxDb.database.transaction(\"chunkPlaceholders\", \"readonly\");\n\n            let request = transaction.objectStore(\"chunkPlaceholders\").get(dbKey);\n    \n            request.onsuccess = function () {\n                const chunk = request.result;\n\n                if(chunk === undefined) return res(null);\n                return res(chunk);\n            };\n    \n            request.onerror = function (event) {\n                rej(request.error);\n            };\n    \n            transaction.onabort = function () {\n                rej(request.error);\n            };\n        })\n    }\n\n    _fromData(savedChunk){\n        const canvas = document.createElement('canvas');\n\n        if(savedChunk){\n            canvas.width = savedChunk.width;\n            canvas.height = savedChunk.height;\n    \n            const ctx = canvas.getContext('2d');\n            \n            const imageData = ctx.createImageData(canvas.width, canvas.height);\n            imageData.data.set(savedChunk.data);\n    \n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return resizeCanvas(canvas, chunkSize, chunkSize);\n    }\n\n    async save(chunkCanvas){\n        return new Promise((res, rej) => {\n            const dbKey = `${canvasId}-${this.x}-${this.y}`;\n            idxDb.addInitCallback(async () => {\n                try {\n                    await this._saveToDb(dbKey, chunkCanvas);\n\n                    res();\n                } catch (error) {\n                    rej(error);\n                }\n            })\n        })\n    }\n\n    async _saveToDb(dbKey, chunkCanvas){\n        return new Promise((res, rej) => {\n            // 50x50 is hardcoded size for all previews\n            const resizedChunkCanvas = resizeCanvas(chunkCanvas, 50, 50);\n            const resizedImgData = resizedChunkCanvas.getContext('2d').getImageData(0, 0, 50, 50);\n\n            let transaction = idxDb.database.transaction(\"chunkPlaceholders\", \"readwrite\");\n\n            let request = transaction.objectStore(\"chunkPlaceholders\").put({\n                'chunk_key': dbKey,\n\n                width: resizedImgData.width,\n                height: resizedImgData.height,\n                data: resizedImgData.data,\n            });\n    \n            request.onsuccess = function () {\n                res();\n            };\n    \n            request.onerror = function (event) {\n                rej(request.error);\n            };\n    \n            transaction.onabort = function () {\n                rej(request.error);\n            };\n        })\n    }\n}","import EventEmitter from 'events'\nimport { ROLE } from './constants';\n\nexport default class Tool extends EventEmitter{\n    constructor(name, defaultKey=null, iconURL=null, minRole=ROLE.GUEST){\n        super();\n\n        this.name = name;\n        this.icon = iconURL;\n\n        this.defaultKey = defaultKey;\n        this.key = defaultKey ? defaultKey.toString() : undefined;\n\n        this.requiredRole = minRole;\n    }\n}","import EventEmitter from 'events';\nimport globals from './globals';\nimport tools from './tools';\nimport camera from './camera';\nimport player from './player';\nimport {\n    screenToBoardSpace\n} from './utils/conversions';\nimport {\n    insanelyLongMobileBrowserCheck,\n    stringifyKeyEvent,\n    decodeKey\n} from './utils/misc';\nimport { getLS, setLS } from './utils/localStorage';\nimport me from './me';\nimport { coords as coordsEl } from './ui/elements';\n\nimport downArrow from '../img/arrow.svg';\n\nconst coords = coordsEl[0];\n\nfunction updatePlayerCoords(clientX, clientY) {\n    let [newX, newY] = screenToBoardSpace(clientX, clientY);\n\n    if (newX === player.x && newY === player.y) {\n        return\n    }\n\n    player.x = newX;\n    player.y = newY;\n\n    coords.innerText = `(${player.x}, ${player.y})`\n\n    if (player.color != -1 && camera.zoom > 1)\n        globals.renderer.needRender = true;\n}\n\nconst isMobile = insanelyLongMobileBrowserCheck();\n\nexport default class ToolManager extends EventEmitter {\n    constructor() {\n        super();\n\n        this.tools = tools;\n        this.tool = tools.mover;\n\n        this._keyBinds = {};\n        this._colorBinds = {};\n        this.activeTools = {};\n\n        this.addTools();\n        this.loadBinds();\n        this.initEvents();\n\n        this.ctrlDown = false;\n        this.altDown = false;\n\n        this.toolChangeBlocked = false;\n\n        me.callOnLoaded(this.filterTools.bind(this));\n    }\n\n    filterTools() {\n        Object.keys(this.tools).forEach(name => {\n            if (this.tools[name].requiredRole > me.role) {\n                delete this._keyBinds[this.tools[name].key];\n\n                if (isMobile) {\n                    $(`#tool_${name}`).remove();\n                }\n            }\n        })\n    }\n\n    addTools() {\n        const toolsEl = document.getElementById('tools');\n        let hiddenToolsEl = null;\n\n        Object.keys(this.tools).forEach(name => {\n            const tool = this.tools[name];\n\n            if (isMobile) {\n                if (!tool.icon) return;\n\n                let el = document.createElement('div');\n                el.classList = 'toolContainer';\n                el.id = `tool_${name}`;\n                let img = document.createElement('img');\n                img.className = 'toolIcon';\n                img.src = tool.icon;\n\n                el.appendChild(img);\n\n                if(toolsEl.childElementCount >= 5){\n                    if(!hiddenToolsEl){\n                        hiddenToolsEl = document.createElement('div');\n                        hiddenToolsEl.style.display = 'none';\n\n                        const showAllButton = document.createElement('div');\n                        showAllButton.className = 'showAllToolsButton';\n                        const showAllImg = document.createElement('img');\n                        showAllImg.src = downArrow;\n\n                        showAllButton.append(showAllImg);\n\n                        showAllButton.addEventListener('click', e => {\n                            const state = parseInt(showAllButton.dataset.state ?? 0);\n                            hiddenToolsEl.style.display = state ? 'none' : '';\n                            showAllImg.style.transform = state ? '' : 'rotate(180deg)';\n                            showAllButton.dataset.state = state ? '0' : '1';\n                        });\n\n                        toolsEl.append(hiddenToolsEl, showAllButton);\n                    }\n\n                    hiddenToolsEl.append(el);\n                }else{\n                    toolsEl.appendChild(el);\n                }\n\n                el.addEventListener('pointerdown', this.selectTool.bind(this, tool));\n\n                if (tool.name === 'mover')\n                    this.selectTool(tool);\n            } else {\n                if (player)\n                    this._keyBinds[tool.key] = tool;\n            }\n        })\n    }\n\n    getToolKey(tool) {\n        for (const [key, value] of Object.entries(this.tools)) {\n            if (tool === value) return key;\n        }\n\n        return null;\n    }\n\n    selectTool(tool) {\n        if (this.toolChangeBlocked) return;\n\n        let oldToolEl = document.getElementsByClassName('toolContainer selected')[0]\n        if (oldToolEl)\n            oldToolEl.className = 'toolContainer';\n\n        const toolKey = this.getToolKey(tool);\n        const curToolEl = document.getElementById(`tool_${toolKey}`);\n        curToolEl.classList = ['toolContainer selected'];\n\n        this.tool.emit('deselected');\n        this.tool = tool;\n        this.tool.emit('selected');\n    }\n\n    blockToolChange() {\n        this.toolChangeBlocked = true;\n    }\n\n    unblockToolChange() {\n        this.toolChangeBlocked = false;\n    }\n\n    initEvents() {\n        let em = globals.eventManager;\n\n        if (isMobile) {\n            em.on('zoom', zoom => {\n                camera.zoom *= zoom + 1;\n                camera.checkZoom();\n                globals.renderer.needRender = true;\n                globals.fxRenderer.needRender = true;\n            });\n\n            em.on('mousedown', e => {\n                updatePlayerCoords(e.clientX, e.clientY);\n            });\n\n            em.on('mousemove', e => {\n                updatePlayerCoords(e.clientX, e.clientY);\n            });\n\n            let events = [\n                ['mousedown', 'down'],\n                ['mousemove', 'move'],\n                ['mouseup', 'up']\n            ];\n\n            events.forEach(event => {\n                const [realEvent, myEvent] = event;\n                em.on(realEvent, e => {\n                    let tool = this.tool;\n                    if (e && e.gesture) {\n                        this.tool.emit('_gesture');\n                        tool = this.tools.mover;\n                    }\n                    if (!tool) return\n\n                    // emit to selected tool\n                    tool.emit(myEvent, e);\n                    // emit to other subscribers\n                    this.emit(myEvent, e);\n                });\n            });\n        } else {\n            em.on('mouseup', e => {\n                // if (e.button === 2) {\n                //     player.switchColor(-1);\n                //     player.switchSecondColor(-1);\n                // }\n            });\n            em.on('mousemove', e => {\n                updatePlayerCoords(e.clientX, e.clientY);\n                this.tool.emit('move', e);\n                this.emit('move', e);\n                \n            });\n\n            const keydown = (e) => {\n                if(globals.lockInputs) return;\n\n                let str = stringifyKeyEvent(e);\n                if (!str) return;\n\n                const tool = this._keyBinds[str];\n\n                if (tool) {\n                    // TODO\n                    this.tool = tool; // , \n                    // ?   mousemove  down\n                    //    up\n                    tool.emit('down', e);\n                }\n            }\n            em.on('keydown', keydown);\n            em.on('mousedown', keydown);\n\n\n            const keyup = (e) => {\n                if(globals.lockInputs) return;\n\n                let strEvKey = stringifyKeyEvent(e);\n                if (!strEvKey) return;\n\n                const tool = this._keyBinds[strEvKey];\n\n                for (let name of Object.keys(this.tools)) {\n                    const tool2 = this.tools[name];\n\n                    if (!tool2.key || tool2 === tool)\n                        continue;\n\n                    const tool2keyDecoded = decodeKey(tool2.key);\n\n                    if (strEvKey === tool2.key || \n                        // make up event on single Alt, because after that keyup on the \n                        // primary key will no longer match the tool key string (i.e. up=\"V\" vs key=\"ALT+V\")\n                        \n                        (strEvKey.startsWith('Alt') && tool2keyDecoded.alt) || \n                        (strEvKey.startsWith('Ctrl') && tool2keyDecoded.ctrl)) {\n                            tool2.emit('up', e)\n                        }\n                }\n\n                if (tool) {\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    tool.emit('up', e);\n                }\n            }\n            em.on('keyup', keyup);\n            em.on('mouseup', keyup);\n\n            em.on('wheel', e => {\n                const oldZoom = camera.zoom;\n                camera.zoomTo(e.deltaY);\n\n                const dx = e.clientX - window.innerWidth / 2;\n                const dy = e.clientY - window.innerHeight / 2;\n\n                camera.moveBy((dx / oldZoom), (dy / oldZoom));\n                camera.moveBy(-(dx / camera.zoom), -(dy / camera.zoom));\n\n                if (localStorage.getItem('iHaveProblems') === 'yes') {\n                    camera.x = Math.round(camera.x); camera.y = Math.round(camera.y);\n                    globals.renderer.needRender = true;\n                }\n            });\n        }\n\n        function specKeysHandlers(e) {\n            this.ctrlDown = e.ctrlKey;\n            this.altDown = e.altKey;\n        }\n\n        em.on('keydown', specKeysHandlers.bind(this));\n        em.on('keyup', specKeysHandlers.bind(this));\n\n        // TODO: add listener directly to ToolManager, istead of tool itself, avoiding cyclic check\n        em.on('tick', e => {\n            Object.keys(this.tools).forEach(name => {\n                const tool = this.tools[name];\n                if (tool.listenerCount('tick') > 0) {\n                    tool.emit('tick', e);\n                }\n            });\n        });\n    }\n\n    changeKey(tool, key, deleteOld=true) {\n        if(deleteOld){\n            const oldKey = tool.key;\n            delete this._keyBinds[oldKey];\n        }\n\n        tool.key = key;\n        this._keyBinds[key] = tool\n    }\n\n    loadBinds() {\n        const str = getLS('keyBinds');\n        let newBinds;\n        try {\n            newBinds = JSON.parse(str);\n            if (!newBinds)\n                return;\n        } catch {\n            toastr.error('Error on parsing key binds from local storage');\n            localStorage.removeItem('keyBinds');\n            return\n        }\n\n        // clearing keybinds ahead of time\n        // it's not safe to delete them in for loop\n        this._keyBinds = {};\n        let toolname;\n        for (let key of Object.keys(newBinds)) {\n            if (toolname = this.findByName(key)){\n                this.changeKey(this.tools[toolname], newBinds[key], false);                \n            }\n        }\n    }\n\n    saveBinds() {\n        let toSave = {};\n\n        for (const tool of Object.values(tools)) {\n            if (!tool.key) continue;\n\n            toSave[tool.name] = tool.key;\n        }\n\n        setLS('keyBinds', JSON.stringify(toSave));\n    }\n\n    findByName(name) {\n        const keys = Object.keys(this.tools);\n        return keys.find(key => this.tools[key].name === name)\n    }\n\n    initColorBinds() {\n\n    }\n\n    loadColorBinds() {\n\n    }\n}","// copied from template 3.0\n// copyright GOROX\n\nimport jQuery from 'jquery';\nimport closeSVG from '../img/cross.svg'\nimport { translate as t } from './translate';\n\nlet windows = [];\nwindow.windows = windows;\n\nexport default class Window {\n    static Exists(title) {\n        return windows.some(x => x.title === title)\n    }\n    static Find(title) {\n        return windows.find(x => x.title === title)\n    }\n    constructor(config) {\n        // all values also will be loaded from config few lines below\n\n        // title can be passed instead of config\n        if (typeof config == 'string')\n            config = { title: config }\n\n        this.created = false;\n\n        this.x = 0;\n        this.y = 0;\n\n        this.title = \"\";\n\n        this.parent = document.body;\n\n        // do not set to false if closeable\n        this.moveable = true;\n        this.closeable = true;\n        this.closed = false;\n\n        this.center = false;\n\n        // here\n        Object.assign(this, config);\n\n        if (Window.Exists(this.title)) {\n            this.oldWindow = Window.Find(this.title);\n            return\n        }\n\n        this.created = true;\n\n        if (!this.block) { // for static windows like chat\n            this.block = this.createParentBlock();\n            this.moveTo(this.x, this.y); // user defined coordinates\n            this.parent.appendChild(this.block);\n        }\n\n        if (this.center) {\n            this.moveToCenter();\n            // :    \n            setTimeout(() => this.moveToCenter());\n        }\n\n        this.addFeatures();\n\n        windows.push(this);\n    }\n\n    get width() {\n        return this.element?.getBoundingClientRect().width;\n    }\n\n    get height() {\n        return this.element?.getBoundingClientRect().height;\n    }\n\n    get left() {\n        return this.x;\n    }\n    get right() {\n        return this.x + this.width;\n    }\n    get top() {\n        return this.y;\n    }\n    get bottom() {\n        return this.y + this.height;\n    }\n\n    updateTitle(newTitle, temp = false) {\n        if (!temp) {\n            this.title = newTitle;\n        }\n        const head = $('.windowTitle', this.element);\n\n        // this makes \".innerHtml = ...\" of method below purposeless\n        // since html is not saved here\n        head.text(newTitle);\n    }\n\n    createParentBlock() {\n        let el = document.createElement('div');\n        el.className = 'window';\n        this.element = el;\n\n        let head = document.createElement('div');\n        head.className = 'windowHeader'\n        head.innerHTML = '<h3 class=\"windowTitle\">' + this.title + '</h3>';\n        el.appendChild(head);\n\n        if (this.closeable) {\n            const closer = document.createElement('div');\n            closer.className = 'closeWindow';\n            closer.innerHTML = '<div></div>';\n\n            closer.addEventListener('pointerdown', event => {\n                // prevent window moving\n                event.stopPropagation();\n            });\n            closer.addEventListener('click', () => this.close());\n            head.appendChild(closer);\n        }\n\n        let body = document.createElement('div');\n        body.className = 'windowBody';\n        el.appendChild(body);\n        this.body = body;\n\n        return el\n    }\n\n    moveTo(x, y) {\n        const rect = this.block.getBoundingClientRect();\n        const w = rect.width,\n            h = rect.height;\n\n        this.x = Math.max(-w + 10, x);\n        this.y = Math.max(-h + 10, y);\n\n        this.x = Math.min(window.innerWidth - 10, this.x);\n        this.y = Math.min(window.innerHeight - 10, this.y);\n\n        this.block.style.left = this.x + 'px';\n        this.block.style.top = this.y + 'px';\n    }\n\n    moveBy(x, y) {\n        this.moveTo(this.x + x, this.y + y);\n    }\n\n    moveToCenter() {\n        let windowWidth = window.innerWidth,\n            windowHeight = window.innerHeight;\n\n        let blockWidth = this.block.offsetWidth,\n            blockHeight = this.block.offsetHeight;\n\n        this.moveTo(\n            windowWidth / 2 - blockWidth / 2,\n            windowHeight / 2 - blockHeight / 2\n        );\n    }\n\n    addFeatures() {\n        if (this.moveable) {\n            $(this.block).on('pointerdown', e => {\n                let self = this;\n                let lastX = e.clientX;\n                let lastY = e.clientY;\n\n                jQuery(document).on('pointermove', moved)\n\n                function moved(e) {\n                    e = e.originalEvent;\n                    let movedX = e.clientX - lastX;\n                    let movedY = e.clientY - lastY;\n\n                    lastX = e.clientX;\n                    lastY = e.clientY;\n\n                    self.moveBy(movedX, movedY);\n                }\n\n                jQuery(document).one('pointerup pointerleave', () => {\n                    jQuery(document).off('pointermove', moved);\n                });\n            });\n\n            $(this.body).on('pointerdown', e => {\n                e.stopPropagation();\n            })\n        }\n\n        // for window be in screen after\n        // screen rotation\n        window.addEventListener('orientationchange', () => {\n            setTimeout(() => {\n                this.moveTo(this.x, this.y);\n            }, 500);\n        })\n    }\n\n    close() {\n        jQuery(this.block).remove();\n        this.closed = true;\n        windows.splice(windows.indexOf(this), 1);\n    }\n}\n\nlet Modal_exists = false;\nexport class Modal {\n    static get isRunning() {\n        return Modal_exists\n    }\n    static set isRunning(val) {\n        return Modal_exists = val;\n    }\n\n    constructor() {\n        if (Modal.isRunning)\n            throw new Error('Modal is running');\n\n        this.body = null;\n\n    }\n    \n    init() {\n        const els =\n        $(`<div class=\"modalBg\">\n            <div class=\"modalCont\">\n            </div>\n            </div>`);\n            \n            this.bgEl = els[0];\n        this.contEl = this.bgEl.children[0];\n        \n        $(document.body).append(els);\n\n        Modal.isRunning = true;\n    }\n\n    close() {\n        Modal.isRunning = false;\n        this.bgEl.remove();\n    }\n}\n\nexport class ConfirmModal extends Modal {\n    constructor(msg, cb = null) {\n        super();\n\n        this.msg = msg;\n        this.cb = cb;\n\n        this.init();\n    }\n\n    init() {\n        super.init();\n\n        const mBody = $(\n            `<div style=\"margin:0;padding:5px;text-align:center;color:var(--light-text)\">\n                <p>${this.msg}</p>\n                <button class='confirmBtn' style=\"padding: 8px;\">${t('OK')}</button>\n                <button class='cancelBtn' style=\"padding: 8px;\">${t('Cancel')}</button>\n            </div>`)\n        this.contEl.appendChild(mBody[0]);\n\n        $('button', mBody).on('click', () => {\n            this.close();\n        });\n\n        $('.confirmBtn', mBody).on('click', () => {\n            if (this.cb) this.cb(true);\n        });\n        $('.cancelBtn', mBody).on('click', () => {\n            if (this.cb) this.cb(false);\n        });\n    }\n}","import '../css/colorVars.css'\nimport '../css/style.css'\nimport '../../node_modules/toastr/build/toastr.css'\n\nimport '../img/vk-logo.svg';\nimport '../img/discord-logo-circle.svg';\nimport '../img/gg-logo.svg';\nimport '../img/stripes.png';\nimport '../img/dots.svg';\nimport '../img/goroxels.png';\nimport '../img/move-icon.svg';\n\nimport '../img/telegram.svg';\n\nimport '../video/clickerMouse.webm'\nimport '../video/clicker.webm'\nimport '../video/as.webm'\nimport '../video/toolC.webm'\nimport '../video/brush.webm'\nimport '../video/brush2.webm'\nimport '../video/line.webm'\nimport '../video/flood.webm'\nimport '../img/unavailable.png'\nimport '../video/ctrlZ.webm'\nimport '../video/patternDemo.webm'\nimport '../video/phoneDrawing.mp4'\nimport '../img/3rdcf.png'\n\nexport default {}","import globals from './globals'\nimport {\n    boardWidth,\n    boardHeight\n} from './config'\nimport EventEmitter from 'events';\nimport { getOrDefault, setLS } from './utils/localStorage';\n\nconst camera = {\n    x: null, y: null,\n    zoom: null,\n    minX: null, minY: null, \n    maxX: null, maxY: null,\n\n    minZoom: 0.1,\n    maxZoom: 64,\n\n    // when it's needed to disable moving\n    noMoving: false,\n\n    init(){\n        Object.assign(this, {\n            x: +getOrDefault('posX', 0, true),\n            y: +getOrDefault('posY', 0, true),\n\n            zoom: +getOrDefault('zoom', 1, true),\n\n            minX: -boardWidth/2,\n            minY: -boardHeight/2,\n            maxX: boardWidth/2,\n            maxY: boardHeight/2,\n        })\n        if(isNaN(this.x) || isNaN(this.y) || isNaN(this.zoom)){\n            this.x = 0;\n            this.y = 0;\n            this.zoom = 1;\n        }\n    },\n\n    centerOn(x, y){\n        globals.renderer.needRender = true;\n        globals.fxRenderer.needRender = true;\n        if(this.noMoving) return;\n        \n        this.x = x - this.maxX;\n        this.y = y - this.maxY;\n\n        this.clampPos();\n    },\n\n    moveBy(movx, movy){\n        globals.renderer.needRender = true;\n        if(this.noMoving) return;\n\n        this.x += movx;\n        this.y += movy;\n\n        this.clampPos();\n    },\n\n    clampPos(){\n        this.x = Math.min(Math.max(this.x, this.minX), this.maxX);\n        this.y = Math.min(Math.max(this.y, this.minY), this.maxY);\n    },\n\n    zoomTo(dir){\n        if(dir < 0){\n            this.zoom = this.zoom * 2 | 0 || 1;\n        }else{\n            this.zoom = this.zoom / 2;\n        }\n        this.checkZoom();\n\n        this.emit('zoom', this.zoom);\n\n        globals.renderer.needRender = true;\n        globals.fxRenderer.needRender = true;\n\n        globals.renderer.preRender();\n    },\n\n    checkZoom(){\n        this.zoom = Math.min(Math.max(this.zoom, this.minZoom), this.maxZoom)\n    }, \n\n    disableMove(){\n        this.noMoving = true;\n    },\n\n    enableMove(){\n        this.noMoving = false;\n    },\n\n    __proto__: new EventEmitter\n}\n\nlet lastX, lastY, lastZ;\nsetInterval(() => {\n    const newX = camera.x,\n        newY = camera.y,\n        newZ = camera.zoom;\n\n    if(lastX != newX) setLS('posX', newX, true);\n    if(lastY != newY) setLS('posY', newY, true);\n    if(lastZ != newZ) setLS('zoom', newZ, true);\n\n    lastX = newX; lastY = newY; lastZ = newZ;\n}, 3000);\n\nexport default (window.camera = camera);","export function initDraggableInputs() {\n    const DRAG_THRESHOLD = 5;\n\n    document.querySelectorAll('input[type=number].valueDrag').forEach(input => {\n        input.style.cursor = 'ew-resize';\n\n        let startX = 0;\n        let startValue = 0;\n        let dragging = false;\n        let armed = false;\n\n        const step = () => {\n            let s = parseFloat(input.step);\n            return isNaN(s) || s <= 0 ? 1 : s;\n        };\n\n        const min = () => {\n            let m = parseFloat(input.min);\n            return isNaN(m) ? -Infinity : m;\n        };\n\n        const max = () => {\n            let m = parseFloat(input.max);\n            return isNaN(m) ? Infinity : m;\n        };\n\n        input.addEventListener('mousedown', e => {\n            if (e.button !== 0) return;\n            armed = true;\n            dragging = false;\n            startX = e.clientX;\n            startValue = parseFloat(input.value) || 0;\n            e.preventDefault();\n        });\n\n        document.addEventListener('mousemove', e => {\n            if (!armed) return;\n            let dx = e.clientX - startX;\n\n            if (!dragging && Math.abs(dx) >= DRAG_THRESHOLD) {\n                dragging = true;\n\n                input.blur();\n                document.body.style.userSelect = 'none';\n                document.body.style.cursor = 'ew-resize';\n            }\n\n            if (dragging) {\n                let val = startValue + dx * step();\n                val = Math.min(max(), Math.max(min(), val));\n                input.value = val;\n                input.dispatchEvent(new Event('input', { bubbles: true }));\n            }\n        });\n\n        document.addEventListener('mouseup', e => {\n            if (!armed) return;\n            if (dragging) {\n                input.dispatchEvent(new Event('change', { bubbles: true }));\n            }\n            \n            if(e.target === input){\n                $(input).trigger('focus');\n            }\n\n            document.body.style.userSelect = '';\n            document.body.style.cursor = '';\n            armed = false;\n            dragging = false;\n        });\n    });\n}","import globals from './globals';\n\nexport const FX_STATE = {\n    IN_PROCESS: 0, // to force renderer to render\n    FINISHED: 1, // render when it's needed (next canvas update)\n    REMOVED: 2 // don't render and delete\n}\n\nexport class FX {\n    constructor(renderFunc) {\n        this.renderFunc = renderFunc;\n\n        this.removed = false;\n    }\n\n    render(ctx) {\n        return this.renderFunc(ctx);\n    }\n\n    remove() {\n        this.removed = true;\n    }\n}\n\nexport class FXRenderer {\n    constructor() {\n        // three layers\n        this.fxList = [[], [], []];\n        this.ctx = globals.fxCtx;\n\n        this.needRender = true;\n        this.needClear = false;\n    }\n\n    add(fx, layer = 0) {\n        this.fxList[layer].push(fx);\n\n        this.needRender = true;\n    }\n\n    /*\n      You can request it by returning zero in rendering\n      functions or explicitly \n    */\n    requestRender() {\n        this.needRender = true;\n    }\n\n    render() {\n        if (!this.needRender) return;\n\n        this.ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n        this.needRender = false;\n\n        for (let layer = 0; layer < this.fxList.length; layer++) {\n            this.fxList[layer].forEach(fx => {\n                try {\n                    if (fx.removed) return this.remove(fx);\n\n                    let r = fx.render(this.ctx);\n\n\n                    if (r == FX_STATE.REMOVED) {\n                        this.remove(fx);\n                    } else if (r == FX_STATE.IN_PROCESS) {\n                        this.needRender = true;\n                    }\n                } catch (error) {\n                    console.error(error);\n                }\n\n            })\n        }\n    }\n\n    remove(fx) {\n        for (let layer = 0; layer < this.fxList.length; layer++) {\n            let idx = this.fxList[layer].indexOf(fx);\n            if (idx != -1) {\n                this.fxList[layer][idx].remove();\n                this.fxList[layer].splice(idx, 1);\n                this.needRender = true;\n                break\n            }\n        }\n\n    }\n}\n\n// fxRenderer is loaded later then tools/template\n// so here is the workaround\nlet _deferredFX = [];\nexport function addFX(fx, layer) {\n    if (globals.fxRenderer) {\n        globals.fxRenderer.add(fx, layer);\n    } else _deferredFX.push([fx, layer]);\n}\n\nexport function removeFX(fx) {\n    globals.fxRenderer.remove(fx);\n}\nlet fxi = setInterval(() => {\n    if (globals.fxRenderer) {\n        clearInterval(fxi);\n        for (let [fx, layer] of _deferredFX) {\n            addFX(fx, layer);\n        }\n        _deferredFX = [];\n    }\n}, 5);","import camera from \"./camera\";\nimport { boardHeight, boardWidth } from \"./config\";\nimport { FX } from \"./fxcanvas\";\nimport { boardToScreenSpace } from \"./utils/conversions\";\n\n// require wipes dynamically, parsing the file name of each\nconst requireOldWipe = require.context('../img/old-wipes', false, /\\.png$/);\n\nconst namePathEntries = requireOldWipe.keys().map(key => {\n    const module = requireOldWipe(key);\n    const path = module.default;\n    const fname = path.match(/([\\.\\d]+)\\.png$/)[1];\n\n    return [fname, path];\n}).sort(([name1], [name2]) => {\n    // sort by date\n    const [day1, month1, year1] = name1.split('.').map(Number);\n    const [day2, month2, year2] = name2.split('.').map(Number);\n    \n    if (year1 !== year2) return year2 - year1;\n    if (month1 !== month2) return month2 - month1;\n    return day2 - day1;\n});\n\nexport const wipes = Object.fromEntries(namePathEntries);\n\nlet historyFx = null, fxCtx = null, prevCameraState;\nexport let curHistoryCanvasUrl = null;\nexport async function showHistoryCanvas(name) {\n    unloadHistoryCanvas();\n\n\n    curHistoryCanvasUrl = wipes[name]\n    const canvasImg = await loadHistoryCanvas(curHistoryCanvasUrl);\n\n    // saving and changing camera borders\n    // (the thing that helps you not get lost when moving canvas)\n    prevCameraState = cloneCameraProps(camera);\n\n    camera.minX = -canvasImg.width / 2;\n    camera.minY = -canvasImg.height / 2;\n    camera.maxX = canvasImg.width / 2;\n    camera.maxY = canvasImg.height / 2;\n\n    camera.x = 0;\n    camera.y = 0;\n    camera.zoom = camera.minZoom;\n\n    globals.renderer.needRender = true;\n\n    // need to center it in the current canvas, otherwise \n    // even camera borders change will not help\n    const canvasStartX = boardWidth/2 - canvasImg.width/2;\n    const canvasStartY = boardHeight/2 - canvasImg.height/2;\n\n    historyFx = new FX(ctx => {\n        if (fxCtx === null) {\n            fxCtx = ctx;\n            // hiding real canvas\n            ctx.canvas.style.backgroundColor = 'gray';\n        }\n\n        const zoom = camera.zoom\n        const topLeftPos = boardToScreenSpace(canvasStartX, canvasStartY);\n\n        ctx.drawImage(canvasImg, ...topLeftPos, canvasImg.width * zoom, canvasImg.height * zoom);\n\n        return 1;\n    });\n\n    globals.fxRenderer.add(historyFx, 1);\n}\n\nasync function loadHistoryCanvas(path) {\n    return new Promise((res, rej) => {\n        const img = new Image();\n\n        img.style.imageRendering = 'pixelated';\n\n        img.onload = () => res(img);\n        img.onerror = rej;\n\n        img.src = path;\n    });\n}\n\nfunction cloneCameraProps(){\n    const { x, y, zoom, minX, minY, maxX, maxY } = camera;\n    return { x, y, zoom, minX, minY, maxX, maxY };\n}\n\nexport function unloadHistoryCanvas() {\n    curHistoryCanvasUrl = null;\n\n    globals.fxRenderer.remove(historyFx);\n    if (fxCtx) {\n        fxCtx.canvas.style.backgroundColor = '';\n        fxCtx = null;\n    }\n    if (prevCameraState) {\n        const { x, y, zoom, minX, minY, maxX, maxY } = prevCameraState;\n        Object.assign(camera, { x, y, zoom, minX, minY, maxX, maxY });\n    }\n}\n\nfunction sortDates(dates) {\n    return dates.sort((a, b) => {\n        const [dayA, monthA, yearA] = a.split('.').map(Number);\n        const [dayB, monthB, yearB] = b.split('.').map(Number);\n        \n        const dateA = new Date(2000 + yearA, monthA - 1, dayA);\n        const dateB = new Date(2000 + yearB, monthB - 1, dayB);\n        \n        return dateA - dateB;\n    });\n}","export let initiated = false;\nexport let database = null;\n\nlet deferredCallbacks = [];\n\nexport function init() {\n    let openRequest = indexedDB.open(\"db\", 1);\n\n    function onDone(){\n        initiated = true;\n        execCallbacks();\n    }\n\n    openRequest.onupgradeneeded = function () {\n        database = openRequest.result;\n        if (!database.objectStoreNames.contains('chunkPlaceholders')) {\n            database.createObjectStore('chunkPlaceholders', { keyPath: 'chunk_key' });\n        }\n\n        onDone();\n    };\n\n    openRequest.onsuccess = () => {\n        database = openRequest.result;\n        onDone();\n    };\n}\n\nfunction execCallbacks(){\n    deferredCallbacks.forEach(cb => {\n        try {\n            cb(database);   \n        } catch (error) {\n            console.error(error);\n        }\n    })\n    deferredCallbacks.length = 0;\n}\n\nexport function addInitCallback(cb) {\n    if (initiated) {\n        cb(database);\n        return;\n    }\n\n    deferredCallbacks.push(cb);\n}","import { initChat, initMobileChatToggle } from \"./Chat\";\nimport { initDraggableInputs } from \"./draggableInputs\";\nimport globals from \"./globals\";\nimport player from \"./player\";\nimport { importTemplateFromUrl, initHandlers, initTemplateMobileMove, initTemplateMoveByMouse, loadValues } from \"./template\";\nimport { initCoordsClick, initUISettings } from \"./ui/config\";\nimport { initPalette } from \"./ui/palette\";\nimport { initMobileMenuToggler } from \"./ui/toggles\";\nimport { initMenuResizer } from \"./ui/config\";\nimport { getLS, setLS } from \"./utils/localStorage\";\nimport { startWinampRadio } from \"./winamp/player\";\nimport { initButtons, initHelpButton, initOnlineViewer } from \"./windows\";\nimport { FX, FX_STATE } from \"./fxcanvas\";\n\nimport soundOnSvg from '../img/movie/SoundOn.svg';\nimport soundOffSvg from '../img/movie/SoundOff.svg';\nimport dimOnSvg from '../img/movie/BrightnessHigh.svg';\nimport dimOffSvg from '../img/movie/BrightnessHighFill.svg';\nimport { boardToScreenSpace } from \"./utils/conversions\";\nimport { mapRange } from \"./utils/math\";\nimport config from \"../../../shared/config\";\nimport { canvasId } from \"./config\";\n\nexport function initInputs() {\n    loadValues();\n    initHandlers();\n    initButtons();\n    initChat();\n    initDraggableInputs();\n}\n\nexport function initOtherCoolFeatures() {\n    initTemplateMobileMove();\n\n    importTemplateFromUrl();\n\n    initTemplateMoveByMouse();\n    // initModMenu();\n    initMobileMenuToggler();\n    initPalette();\n    initUISettings();\n    initMobileChatToggle();\n    initHelpButton();\n    player.init();\n    initCoordsClick();\n    initOnlineViewer();\n    initMenuResizer();\n    // show tooltip animation instead\n    // showHelpIfFirstTime();\n    startWinampRadio();\n\n    initDraggableInputs();\n    initHelpHint();\n\n    initMovieShit();\n}\n\nfunction initModMenu() {\n    initSliding();\n    initSendAlerts();\n\n    function initSliding() {\n        $('#modMenu .title').on('click', e => {\n            const m = $('#modMenu');\n            if (m.data('state') === 'open') {\n                m.data('state', 'close');\n                m.css('right', '');\n            } else {\n                m.data('state', 'open');\n                m.css('right', $('#modMenu .body').css('width'));\n            }\n        })\n    }\n\n    function initSendAlerts() {\n        $('#sendAlerts').on('click', () => {\n            const val = $('#sendAlertsText').val();\n            if (val.length == 0 || val.length > 2000) return;\n\n            $('#sendAlertsText').val('');\n            globals.socket.sendAlert('all', val);\n        })\n    }\n}\n\nfunction initHelpHint() {\n    if (getLS('helpHintShown', false) === '1') {\n        return;\n    }\n    setLS('helpHintShown', '1', false);\n\n    const infoHint = $(\n        `<div style=\"position: absolute;\n            border-radius: 50%;\n            z-index: 999999;\n            left: 50%;\n            top: 50%;\n            width: 30px;\n            height: 30px;\n            background-color: var(--primary);\n            border: 3px solid var(--dark);\n            display: flex;\n            \n            align-items: center;\n            justify-content: center;\">\n\n            <span style=\"\n                color: white;\n                font-weight: bold;\n                font-size: 20px;\n            \">i</span>\n        </div>`);\n    infoHint.css('transform', 'scale(3)').css('border-spacing', '3px');\n\n    document.body.appendChild(infoHint[0]);\n    setTimeout(() => {\n        infoHint.animate({\n            'border-spacing': 1\n        }, {\n            duration: 200,\n            step: (now, tween) => {\n                infoHint.css('transform', `scale(${now})`);\n            },\n            complete: () => {\n                infoHint.animate({\n                    top: '-10%',\n                    left: '-10%',\n                    opacity: 0.5\n                }, 1000, 'swing', () => infoHint.remove());\n            }\n        });\n    }, 500);\n}\n\nfunction initMovieShit() {\n    if (canvasId !== config.telek.canvas) return;\n\n    function createSvgToggleButton({\n        bounds,\n        svgOnUrl,\n        svgOffUrl,\n        isEnabledRef,\n        onToggle\n    }) {\n        let svgOn = null;\n        let svgOff = null;\n        let enabledAt = 0;\n\n        loadSvgText(svgOnUrl).then(t => svgOn = t);\n        loadSvgText(svgOffUrl).then(t => svgOff = t);\n\n        function draw(ctx) {\n            const svg = isEnabledRef() ? svgOn : svgOff;\n            if (!svg) return FX_STATE.FINISHED;\n\n            const rect = getIconBoardBounds(bounds);\n\n            let fxState = FX_STATE.FINISHED;\n\n            if (isEnabledRef()) {\n                const passed = Date.now() - enabledAt;\n                if (passed < 1000) fxState = FX_STATE.IN_PROCESS;\n\n                ctx.globalAlpha =\n                    passed < 1000\n                        ? mapRange(1000 - passed, 0, 1000, 0.3, 1)\n                        : 0.3;\n            } else {\n                ctx.globalAlpha = 1;\n            }\n\n            drawSvgOnCanvas(ctx, svg, rect, ctx.globalAlpha);\n            ctx.globalAlpha = 1;\n\n            return fxState;\n        }\n\n        function hitTest(cx, cy) {\n            const rect = getIconBoardBounds(bounds);\n            return isCursorUnderBounds(cx, cy, rect);\n        }\n\n        function toggle() {\n            onToggle();\n            if (isEnabledRef()) enabledAt = Date.now();\n            globals.fxRenderer.needRender = true;\n        }\n\n        return {\n            draw, hitTest, toggle,\n            get enabledAt() { return enabledAt }\n        };\n    }\n\n    let audioCreated = false;\n    let audioEnabled = false;\n    let audio = null;\n    let lastAudioName = null;\n\n    let dimEnabled = false;\n\n    const origOnStringMessage = globals.socket.onStringMessage;\n\n    globals.socket.onStringMessage = (msg) => {\n        origOnStringMessage.call(globals.socket, msg);\n\n        if (!audioEnabled) return;\n\n        const msgParsed = JSON.parse(msg);\n\n        if (msgParsed.c !== 'transmit' || msgParsed.data.code !== 'sync') return;\n\n        const serverTime = msgParsed.data.payload.pts;\n        const audioName = msgParsed.data.payload.name + '.mp3';\n\n        if (!audioCreated || audioName !== lastAudioName) {\n            audioCreated = true;\n            lastAudioName = audioName;\n            createMovieAudio(serverTime);\n        } else {\n            syncAudio(serverTime);\n        }\n    }\n\n    function createMovieAudio(initialOffset = 0) {\n        unloadAudio();\n\n        audio = new Audio('/audio/' + lastAudioName);\n        audio.currentTime = initialOffset;\n\n        audio.play();\n    }\n\n    const MAX_RATE_DELTA = 0.005;\n    let targetRate = 1;\n    let currentRate = 1;\n    function syncAudio(serverTime) {\n        const myTime = audio.currentTime;\n        const diff = serverTime - myTime;\n        const diffAbs = Math.abs(diff);\n\n        if (diffAbs > 5) {\n            targetRate = 1;\n            audio.currentTime = serverTime;\n            audio.playbackRate = 1;\n            return;\n        }\n\n        if (diffAbs > 0.05) {\n            targetRate = 1 + clamp(diff * 0.1, -MAX_RATE_DELTA, MAX_RATE_DELTA);\n        } else {\n            targetRate = 1;\n        }\n\n        currentRate += (targetRate - currentRate) * 0.05;\n        audio.playbackRate = currentRate;\n\n        console.log('pbRate=' + audio.playbackRate);\n    }\n\n    function clamp(v, min, max) {\n        return Math.max(min, Math.min(max, v));\n    }\n\n    // ---------- fx part\n    async function loadSvgText(url) {\n        const res = await fetch(url);\n        if (!res.ok) throw new Error(`Failed to fetch SVG: ${res.status}`);\n        const svgText = await res.text();\n        return svgText;\n    }\n\n    const svgCache = new Map();\n\n    async function getSvgImage(svgString) {\n        let record = svgCache.get(svgString);\n\n        if (record) {\n            //    \n            await record.ready;\n            return record.img;\n        }\n\n        const img = new Image();\n        const blob = new Blob([svgString], { type: 'image/svg+xml' });\n        const url = URL.createObjectURL(blob);\n\n        const ready = (async () => {\n            img.src = url;\n            await img.decode();\n            URL.revokeObjectURL(url);\n        })();\n\n        svgCache.set(svgString, { img, ready });\n\n        await ready;\n        return img;\n    }\n\n    async function drawSvgOnCanvas(ctx, svgString, rect, alpha = 1) {\n        try {\n            const img = await getSvgImage(svgString);\n\n            ctx.save();\n\n            ctx.shadowColor = 'rgba(255,255,255,1)';\n            ctx.shadowBlur = 5;\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n\n            ctx.globalCompositeOperation = 'source-over';\n\n            ctx.globalAlpha = alpha;\n            ctx.drawImage(img, rect.x, rect.y, rect.width, rect.height);\n\n            ctx.restore();\n        } catch (err) {\n            console.error(err, svgString);\n        }\n    }\n\n\n    const telekX = config.telek.x;\n    const telekY = config.telek.y;\n    const telekSize = config.telek.size;\n    let soundIconBounds = new DOMRect(\n        telekX + telekSize + 3,\n        telekY,\n        32, 32\n    );\n    let dimIconBounds = new DOMRect(\n        telekX + telekSize + 2,\n        telekY + 20,\n        32, 32\n    );\n    const soundButton = createSvgToggleButton({\n        bounds: soundIconBounds,\n        svgOnUrl: soundOnSvg,\n        svgOffUrl: soundOffSvg,\n        isEnabledRef: () => audioEnabled,\n        onToggle: toggleAudioState\n    });\n\n    const dimButton = createSvgToggleButton({\n        bounds: dimIconBounds,\n        svgOnUrl: dimOnSvg,\n        svgOffUrl: dimOffSvg,\n        isEnabledRef: () => dimEnabled,\n        onToggle: toggleDim\n    });\n\n    function getIconBoardBounds(icon) {\n        const [x, y] = boardToScreenSpace(icon.x, icon.y);\n        return {\n            x, y,\n            width: icon.width,\n            height: icon.height\n        }\n    }\n    function getTelekBoardBounds() {\n        const [x1, y1] = boardToScreenSpace(telekX, telekY, false);\n        const [x2, y2] = boardToScreenSpace(telekX + telekSize, telekY + telekSize, false);\n\n        return {\n            x: Math.ceil(x1), y: Math.ceil(y1),\n            width: x2 - x1 - 1,\n            height: y2 - y1 - 1\n        }\n    }\n\n    globals.fxRenderer.add(new FX(ctx => {\n        let state = FX_STATE.FINISHED;\n\n        state = Math.min(state, soundButton.draw(ctx));\n        state = Math.min(state, dimButton.draw(ctx));\n\n        if (dimEnabled) {\n            const telekBounds = getTelekBoardBounds();\n\n            const sinceEnabled = Date.now() - dimButton.enabledAt;\n            const curOpacity = sinceEnabled > 1000 ? 1 : sinceEnabled / 1000;\n\n            ctx.fillStyle = 'black';\n            ctx.globalAlpha = mapRange(curOpacity, 0, 1, 0, 0.8);\n            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            ctx.clearRect(telekBounds.x, telekBounds.y, telekBounds.width, telekBounds.height);\n            ctx.globalAlpha = 1;\n        }\n\n        return state;\n    }), 2);\n\n    document.addEventListener('pointerdown', e => {\n        const cx = e.clientX;\n        const cy = e.clientY;\n\n        if (soundButton.hitTest(cx, cy) || dimButton.hitTest(cx, cy)) {\n            player.suspendColors();\n        }\n    });\n\n    document.addEventListener('pointerup', () => {\n        setTimeout(() => player.restoreColors());\n    });\n\n    document.addEventListener('click', e => {\n        const cx = e.clientX;\n        const cy = e.clientY;\n\n        if (soundButton.hitTest(cx, cy)) {\n            e.preventDefault();\n            e.stopPropagation();\n            soundButton.toggle();\n            return;\n        }\n\n        if (dimButton.hitTest(cx, cy)) {\n            e.preventDefault();\n            e.stopPropagation();\n            dimButton.toggle();\n        }\n    });\n\n    function isCursorUnderBounds(cx, cy, bounds) {\n        return (cx >= bounds.x && cx < bounds.x + bounds.width &&\n            cy >= bounds.y && cy < bounds.y + bounds.height)\n    }\n\n    function unloadAudio() {\n        if (audio) {\n            audio.pause();\n            audio.src = '';\n            audio.load();\n            audio.currentTime = 0;\n\n            audio = null;\n        }\n    }\n\n    function toggleAudioState() {\n        audioEnabled = !audioEnabled;\n        if (!audioEnabled) {\n            unloadAudio();\n            audioCreated = false;\n        }\n\n        globals.fxRenderer.needRender = true;\n    }\n\n    function toggleDim() {\n        dimEnabled = !dimEnabled;\n\n        globals.fxRenderer.needRender = true;\n    }\n}","import _ from './assets';\n\nimport Socket from './Socket';\nimport globals from './globals';\nimport ChunkManager from './ChunkManager';\nimport Renderer from './Renderer';\nimport { FXRenderer } from './fxcanvas';\nimport player, { updateMe } from './player';\nimport ToolManager from './ToolManager';\nimport { calculateColumnSize, initHalfmap } from './utils/misc';\n\nimport * as config from './config';\nimport { init as initTranslate, translate } from './translate';\nimport camera from './camera';\nimport { Modal } from './Window';\nimport { getLS, setLS } from './utils/localStorage';\nimport * as indexedDb from './indexedDb';\nimport { initInputs, initOtherCoolFeatures } from './init';\nimport { toggleTopMenu } from './ui/toggles';\nimport { fixColorsWidth } from './ui/config';\nimport { fixChatPosition } from './Chat';\nimport { fxCanvas, mainCanvas } from './ui/elements';\n\n(async () => {    \n    indexedDb.init();\n    await config.download();\n\n    window.onresize = () => {\n        mainCanvas[0].width = window.innerWidth;\n        mainCanvas[0].height = window.innerHeight;\n\n        fxCanvas[0].width = window.innerWidth;\n        fxCanvas[0].height = window.innerHeight;\n\n        const fxCtx = fxCanvas[0].getContext('2d');\n\n        ctx.imageSmoothingEnabled = fxCtx.imageSmoothingEnabled = false;\n        ctx.webkitImageSmoothingEnabled = fxCtx.webkitImageSmoothingEnabled = false;\n        ctx.mozImageSmoothingEnabled = fxCtx.mozImageSmoothingEnabled = false;\n        ctx.msImageSmoothingEnabled = fxCtx.msImageSmoothingEnabled = false;\n        ctx.oImageSmoothingEnabled = fxCtx.oImageSmoothingEnabled = false;\n\n        renderer.needRender = true;\n        fxRenderer.needRender = true;\n\n        if (!globals.mobile) {\n            calculateColumnSize();\n        }\n\n        fixColorsWidth();\n        fixChatPosition();\n    }\n\n\n    window.oncontextmenu = function (e) {\n        if (e.target === mainCanvas[0] ||\n            e.target.classList[0] === 'paletteColor' ||\n            (e.path && e.path[1].classList[0] === 'paletteColor')) {\n            e.preventDefault();\n        }\n    }\n\n    camera.init();\n    initHalfmap();\n\n    const ctx = mainCanvas[0].getContext('2d');\n    ctx.imageSmoothingEnabled = false;\n\n    const wsPort = location.protocol === 'https:' ? 443 : (location.port || 80);\n    const socket = new Socket(wsPort);\n    globals.socket = socket;\n\n    const chunkManager = new ChunkManager();\n    globals.chunkManager = chunkManager;\n\n    const renderer = window.renderer = new Renderer(ctx);\n    globals.renderer = renderer;\n\n    const fxRenderer = new FXRenderer();\n    globals.fxRenderer = fxRenderer;\n\n    globals.toolManager = new ToolManager(document.getElementById('board'));\n\n    globals.player = player;\n\n    const renderLoop = () => {\n        requestAnimationFrame(() => {            \n            renderer.requestRender();\n            renderLoop();\n        })\n    }\n    renderLoop();\n\n    window.onresize();\n\n    socket.on('opened', () => { });\n    socket.on('online', count => {\n        $('.online').text(count);\n    });\n    socket.on('closed', () => {\n        $('.online').text('offline');\n    })\n\n    window.globals = globals;\n\n    // create nsfw modal\n    config.callOnLoad(() => {\n        if (config.canvasName !== 'nsfw') return;\n        if (getLS('modal18') == 'accepted') return;\n\n        const m = new Modal;\n        m.init();\n        const mBody = $(\n            `<div style=\"margin:0;padding:5px;text-align:center;\">\n                <h1>${translate('WARNING')}</h1>\n                <p>${translate('This canvas may contain illustrations, inappropriate for people under age of 18, including:')}\n                <br>${translate('Gore, furry, porn, hate, anime and all possible variations of these.')}</p>\n                <p><b>${translate('Are you 18 y.o. and fully understanding what are you doing?')}</b></p>\n                <button style=\"padding: 8px;\">${translate('I am 18 years old and I take responsibility for my psyche on myself')}</button>\n            </div>`)\n        m.contEl.appendChild(mBody[0]);\n\n        $('button', mBody).on('click', () => {\n            m.close();\n            setLS('modal18', 'accepted');\n        });\n    });\n\n    updateMe();\n    initTranslate();\n    initInputs();\n    initOtherCoolFeatures();\n    // now hides by default\n    if(globals.mobile)\n        toggleTopMenu();\n})();","import { ROLE } from './constants'\nimport { apiRequest } from './utils/api';\n\nlet loaded = false;\nlet cbs = [];\n\nexport default {\n    registered: false,\n    name: null,\n    id: null,\n    role: ROLE.GUEST,\n    update(newMe){\n        this.registered = newMe.registered;\n        if(newMe.registered){\n            this.name = newMe.name;\n            this.role = newMe.role;\n            this.id = newMe.id;\n        }\n\n        this.updateRoleRelatedHtml();\n    },\n\n    updateRoleRelatedHtml(){\n        $('.minrole-admin').hide();\n        $('.minrole-mod').hide();\n        $('.minrole-trusted').hide();\n        $('.minrole-user').hide();\n\n        switch(this.role){\n            case ROLE.ADMIN:\n                $('.minrole-admin').show();\n            case ROLE.MOD:\n                $('.minrole-mod').show();\n            case ROLE.TRUSTED:\n                $('.minrole-trusted').show();\n            case ROLE.USER:\n                $('.minrole-user').show();\n        }\n    },\n\n    checkCanGetUserInfo(){\n        return this.registered && this.role >= ROLE.TRUSTED\n    },\n\n    async load(){\n        const response = await apiRequest('/me');\n        const user = await response.json();\n\n        this.update(user);\n\n        loaded = true;\n        this.callStacked();\n    },\n\n    callOnLoaded(cb){\n        if(this.loaded)\n            return cb();\n        cbs.push(cb);\n    },\n    callStacked(){\n        cbs.forEach(cb => cb());\n        cbs = [];\n    }\n}","import Bucket from './Bucket';\nimport { cooldown } from './config';\nimport { chatInput } from './ui/elements';\nimport globals from './globals';\nimport me from './me';\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\nimport { ROLE, ROLE_I } from './constants';\nimport { translate as t } from './translate';\n\nconst player = {\n    x: 0,\n    y: 0,\n    color: -1,\n    brushSize: 1,\n    secondCol: -1,\n    id: -1,\n    suspendedClrs: null,\n    init() {\n        this.loadColors();\n        this.switchColor(this.color, true);\n        this.switchSecondColor(this.secondCol, true);\n    },\n    loadColors() {\n        this.color = +getOrDefault('color1', -1, true);\n        this.secondCol = +getOrDefault('color2', -1, true);\n    },\n    switchColor(id, initial = false) {\n        if (this.secondCol === id && id !== -1) {\n            this.switchSecondColor(-1);\n        }\n\n        if (this.color === id && !initial)\n            id = this.color = -1;\n        else\n            this.color = id;\n        globals.fxRenderer.needRender = true;\n        globals.renderer.preRender();\n\n        $('.paletteColor.selected').removeClass('selected');\n        if (id !== -1) {\n            $('#col' + id).addClass('selected');\n        }\n\n        setLS('color1', id, true);\n    },\n    switchSecondColor(id, initial) {\n        if (this.color === id && id !== -1) {\n            this.switchColor(-1);\n        }\n        if (this.secondCol === id && !initial)\n            id = this.secondCol = -1;\n        else\n            this.secondCol = id;\n        globals.fxRenderer.needRender = true;\n        globals.renderer.preRender();\n\n        $('.paletteColor.selectedSecond').removeClass('selectedSecond');\n        if (id !== -1) {\n            $('#col' + id).addClass('selectedSecond');\n        }\n\n        setLS('color2', id, true);\n    },\n    swapColors() {\n        const temp = this.color;\n        this.switchColor(this.secondCol);\n        this.switchSecondColor(temp);\n    },\n    resetColors() {\n        this.switchColor(-1);\n        this.switchSecondColor(-1);\n    },\n\n    // suspend/restore is a workaround to\n    // temporarily disable drawing by mouse/tools\n    suspendColors() {\n        this.suspendedClrs = [this.color, this.secondCol];\n        this.resetColors();\n    },\n    restoreColors() {\n        if (!this.suspendedClrs) return;\n\n        this.switchColor(this.suspendedClrs[0]);\n        this.switchSecondColor(this.suspendedClrs[1]);\n\n        this.suspendedClrs = null;\n    },\n\n    bucket: null,\n    updateBucket([delay, max]) {\n        this.bucket = new Bucket(delay, max);\n    },\n    placed: [],\n    maxPlaced: isNaN(+localStorage['maxPlaced']) ? 5000 : +localStorage['maxPlaced'],\n    placedCount: +getLS('placedCount', true) || 0\n}\n\nexport async function updateMe() {\n    await me.load();\n\n    player.updateBucket(getMyCooldown());\n    if (me.registered) {\n        chatInput.removeAttr('disabled');\n        chatInput.val('');\n\n        $('#loginButtons,.authBtn').hide();\n        $('#chatNick,#chatChannels').show();\n        $('#chatNick').text(me.name);\n        $('#chatHeader').addClass('logged');\n    } else {\n        chatInput.attr('disabled');\n        chatInput.val(t('login to chat'));\n\n        // $('#chatNick').text('CHAT');\n        $('#chatNick,#chatChannels').hide();\n        $('#loginButtons,.authBtn').show();\n        $('#chatHeader').removeClass('logged');\n    }\n}\n\nfunction getMyCooldown() {\n    const cooldowns = cooldown;\n\n    if (ROLE_I[me.role] == 'ADMIN') return [0, 32]\n    return cooldowns[ROLE_I[me.role]] || cooldown.GUEST;\n}\n\nexport function placePixels(pixels, store = true, isCtrlZ = false) {\n    // does not check pixels, excluding for wand\n\n    // check to allow place only on selected color, if selected\n    let outPixels = [];\n    if (!isCtrlZ && globals.wandSelectedColor !== null) {\n        const allowedCol = globals.wandSelectedColor;\n\n        let someValid = false;\n        for (let i = 0; i < pixels.length; i++) {\n            const boardCol = globals.chunkManager.getChunkPixel(...pixels[i]);\n            if (boardCol === allowedCol) {\n                outPixels.push(pixels[i]);\n                someValid = true;\n            }\n        }\n\n        if (!someValid) return;\n\n        globals.fxRenderer.needRender = true;\n    }else{\n        outPixels = pixels;\n    }\n\n    if (store) {\n        outPixels.forEach(([x, y, c]) => {\n            player.placed.push([x, y, globals.chunkManager.getChunkPixel(x, y)]);\n        })\n    }\n    globals.socket.sendPixels(outPixels, false);\n}\n\nexport function placePixel(x, y, col, store = true, isCtrlZ = false) {\n    const oldCol = globals.chunkManager.getChunkPixel(x, y),\n        isProtected = globals.chunkManager.getProtect(x, y);\n\n    const wandColor = globals.wandSelectedColor;\n    if (!isCtrlZ && wandColor !== null && oldCol !== wandColor) return;\n\n    if (oldCol !== col && (!isProtected || me.role >= ROLE.TRUSTED) && globals.socket.connected) {\n        if (store) {\n            player.placed.push([x, y, globals.chunkManager.getChunkPixel(x, y)]);\n\n            if (player.placed.length > player.maxPlaced * 2) {\n                player.placed = player.placed.slice(-player.maxPlaced);\n            }\n        }\n\n        globals.chunkManager.setChunkPixel(x, y, col);\n        globals.fxRenderer.needRender = true;\n\n        globals.socket.sendPixel(x, y, col);\n\n        globals.socket.pendingPixels[x + ',' + y] = setTimeout(() => {\n            globals.chunkManager.setChunkPixel(x, y, oldCol);\n            globals.renderer.needRender = true;\n        }, 3000)\n    } else {\n        if (isProtected && me.role < ROLE.TRUSTED) {\n            toastr.error(t('error.protected_pixel'), t('Error!'), {\n                preventDuplicates: true,\n                timeOut: 750\n            })\n        }\n    }\n}\n\nexport function updateBrush(size) {\n    player.brushSize = +size;\n    globals.fxRenderer.needRender = true;\n\n    globals.renderer.preRenderBrush();\n\n    $('#brushSizeCounter').text(size - 1);\n}\n\nexport function togglePlaced(state) {\n    state ? $('#placedPixels').show() : $('#placedPixels').hide();\n}\n\nexport function updatePlaced(count, handCount) {\n    // FIXME: move it to interval?\n    $('#placedPixels').text(count);\n    if (handCount)\n        $('#placedPixels').attr('title', handCount);\n}\n\nlet lastPlaced = player.placedCount;\nsetInterval(() => {\n    if (lastPlaced !== player.placedCount) {\n        setLS('placedCount', player.placedCount, true);\n        lastPlaced = player.placedCount;\n    }\n}, 3000);\n\nexport default player;","// change utils/recorder if changes\n\nexport const OPCODES = {\n    chunk:       0x0,\n    place:       0x1,\n    online:      0x2,\n    canvas:      0x3,\n    pixels:      0x4,\n    captcha:     0x5,\n    ping:        0x6,\n    placeBatch:  0x7,\n    updateRadio: 0x8,\n    pastePixels: 0x9\n}\n\nexport const STRING_OPCODES = {\n    error: 'e',\n    userJoin: 'u',\n    userLeave: 'l',\n    subscribeChat: 's',\n    chatMessage: 'c',\n    alert: 'a',\n    me: 'm',\n    reload: 'r',\n    reloadChunks: 'rc'\n}\n\n// max coords is up to 4096\nexport function packPixel(x, y, col) {\n    return (x << 12 | y) << 7 | col\n}\n\nexport function unpackPixel(num) {\n    return [\n        num >>> 19,\n        num >>> 7 & 0xFFF,\n        num & 0b1111111\n    ]\n}","import camera from './camera';\nimport {\n    halfMap,\n    loadImage\n} from './utils/misc'\n\nlet winWid = window.innerWidth / 2,\n    winHei = window.innerHeight / 2;\n\nwindow.addEventListener('resize', () => {\n    winWid = window.innerWidth / 2;\n    winHei = window.innerHeight / 2;\n})\n\nimport {\n    urlInput,\n    xInput,\n    yInput,\n    opacInput,\n    chatInput\n} from './ui/elements';\nimport { boardToScreenSpace, screenToBoardSpace } from './utils/conversions';\nimport globals from './globals';\nimport { addFX, FX } from './fxcanvas';\nimport { getOrDefault, setLS } from './utils/localStorage';\nimport me from './me';\nimport { apiRequest } from './utils/api';\nimport { templatesWindow } from './windows';\nimport player from './player';\n\nconst widthRegEx = /w(?:idth)?=(\\d+)$/;\n\nexport class TemplateFx {\n    constructor() {\n\n    }\n}\n\n// singletone atm\nclass Template {\n    constructor() {\n        this.x = 0;\n        this.y = 0;\n\n        this.templateImg;\n        this.templateResizeW = null;\n\n        this._lastUrl = null;\n\n        addFX(new FX(this.renderFx.bind(this)));\n    }\n\n    get url() {\n        return urlInput.val()\n    }\n\n    get opacity() {\n        return +opacInput.val()\n    }\n\n    set opacity(val) {\n        opacInput.val(val);\n    }\n\n    renderFx(ctx) {\n        if (!this.templateImg) return 1;\n\n        ctx.imageSmoothingEnabled = false;\n\n        const [posX, posY] = boardToScreenSpace(this.x, this.y);\n        const zoom = camera.zoom;\n\n        let canvasW, canvasH;\n        // patternized or not\n        if (this.templateResizeW) {\n            canvasW = this.templateResizeW;\n            // sometimes AR does not align template properly\n            // so we need to divide by the pattern size(7) manually\n            if (this.templateImg.width / this.templateResizeW === 7) {\n                canvasH = Math.floor(this.templateImg.height / 7);\n            } else {\n                const ar = this.templateImg.width / this.templateImg.height;\n                canvasH = Math.floor(this.templateResizeW / ar);\n            }\n        } else {\n            canvasW = this.templateImg.width;\n            canvasH = this.templateImg.height;\n        }\n\n        const oldOpac = ctx.globalAlpha;\n        ctx.globalAlpha = this.opacity;\n\n        ctx.drawImage(this.templateImg, posX, posY, canvasW * zoom | 0, canvasH * zoom | 0);\n\n        ctx.globalAlpha = oldOpac;\n        return 1;\n    }\n\n    update() {\n        this.updatePosition();\n        this.updateImage();\n    }\n\n    updatePosition() {\n        this.x = parseInt(xInput.val(), 10);\n        this.y = parseInt(yInput.val(), 10);\n\n        globals.fxRenderer.requestRender();\n    }\n\n    static parseImageUrl(url) {\n        let width = null;\n        let match;\n        if (match = url.match(widthRegEx)) {\n            width = +match[1];\n        }\n\n        if (url.startsWith('GRX')) {\n            const file = url.match(/f=(.+\\.png)/)[1];\n            url = `/api/template/img?t=orig&f=${file}`;\n        }\n\n        return {\n            url, width\n        }\n    }\n\n    async updateImage() {\n        if (this.url === this._lastUrl) {\n            return;\n        }\n\n        const {\n            url: parsedUrl, width: parsedWidth\n        } = Template.parseImageUrl(this.url);\n\n        this.templateImg = await loadImage(parsedUrl);\n        this._lastUrl = this.url;\n\n        this.templateResizeW = parsedWidth;\n\n        globals.fxRenderer.requestRender();\n    }\n\n    get isPatterns() {\n        return !isNaN(this.templateResizeW) &&\n            this.templateImg.width % 7 == 0 &&\n            this.templateImg.height % 7 == 0;\n    }\n}\nconst template = new Template();\n\nexport function loadValues() {\n    const urlVal = getOrDefault('template.url', 'https://i.imgur.com/4GQIMQ7.png', true);\n    urlInput.val(urlVal);\n\n    const xVal = getOrDefault('template.x', 0, true);\n    xInput.val(parseInt(xVal, 10));\n\n    const yVal = getOrDefault('template.y', 0, true);\n    yInput.val(parseInt(yVal, 10));\n\n    const opacVal = getOrDefault('template.opac', 0.5, true);\n    opacInput.val(parseFloat(opacVal));\n}\n\nfunction saveTemplate() {\n    setLS('template.x', template.x, true);\n    setLS('template.y', template.y, true);\n    setLS('template.url', template.url, true);\n    setLS('template.opac', template.opacity, true);\n}\n\nexport function updateTemplate() {\n    template.update();\n    saveTemplate();\n}\n\nexport function initHandlers() {\n    urlInput.on('input', updateTemplate);\n    xInput.on('input', updateTemplate);\n    yInput.on('input', updateTemplate);\n    opacInput.on('input', updateTemplate);\n\n    updateTemplate();\n}\n\nexport function initTemplateMoveByMouse() {\n    $(document).on('mousedown', e => {\n        if (!e.ctrlKey) return;\n\n        // preventing default movement\n        e.stopPropagation();\n        e.preventDefault();\n\n        let lastCord = screenToBoardSpace(e.clientX, e.clientY).map(x => x |= 0);\n\n        function mousemove(e) {\n            e.stopPropagation();\n            e.preventDefault();\n\n            const boardPos = screenToBoardSpace(e.clientX, e.clientY);\n            boardPos[0] |= 0;\n            boardPos[1] |= 0;\n\n            let [lastX, lastY] = boardPos;\n\n            if (lastX === lastCord[0] && lastY === lastCord[1])\n                return;\n\n            // console.log(lastX, lastY, boardPos, lastCord)\n\n            xInput.val(template.x -= lastCord[0] - lastX);\n            yInput.val(template.y -= lastCord[1] - lastY);\n\n            template.updatePosition();\n\n            lastCord = boardPos;\n\n            saveTemplate();\n        }\n        $(document).on('mousemove', mousemove);\n        $(document).one('mouseup mouseleave', () => {\n            $(document).off('mousemove', mousemove);\n        })\n    })\n}\n\nexport function importTemplateFromUrl() {\n    const urlParams = new URLSearchParams(window.location.search);\n    const tUrl = urlParams.get('t_url');\n    const tX = urlParams.get('t_x');\n    const tY = urlParams.get('t_y');\n    if (!tUrl || !tX || !tY) return\n\n    urlInput.val(decodeURIComponent(tUrl));\n    xInput.val(+tX);\n    yInput.val(+tY);\n\n    updateTemplate();\n    removeAllSearchParams();\n}\n\nfunction removeAllSearchParams() {\n    const url = new URL(window.location);\n    url.search = '';\n    window.history.replaceState(null, '', url);\n}\n\nexport function shareTemplate() {\n    const imgUrl = urlInput.val();\n    const x = xInput.val();\n    const y = yInput.val();\n\n    const curUrl = location.origin + location.pathname;\n\n    const importUrl = `${curUrl}?t_url=${encodeURIComponent(imgUrl)}&t_x=${x}&t_y=${y}`;\n\n    chatInput.val(importUrl);\n    chatInput.trigger('focus');\n\n    // to trigger input events, such as white text color for links\n    const inputEvent = new Event('input', {\n        bubbles: true,\n        cancelable: true\n    });\n    chatInput[0].dispatchEvent(inputEvent);\n}\n\nexport async function showTemplates() {\n    if (!me.registered) {\n        return toastr.error('needs_login_to_use_templates');\n    }\n    const resp = await apiRequest('/template/list');\n\n    const respData = await resp.json();\n    if (respData.errors) return;\n\n    templatesWindow(respData);\n}\n\nexport function initTemplateMobileMove() {\n    const moveBtn = $('#manualMoveBtn');\n\n    let isMovingEnabled = false;\n\n    let lastPressCord;\n    // let pointerId;\n    function mousedown(e) {\n        if (!isMovingEnabled) return;\n\n        lastPressCord = screenToBoardSpace(e.clientX, e.clientY).map(x => x |= 0);\n\n        // sometimes mouseup's not emitted\n        mouseup();\n\n        globals.eventManager.on('mousemove', mousemove);\n    }\n\n    function mousemove(e) {\n        if (e.gesture) return;\n\n        const boardPos = screenToBoardSpace(e.clientX, e.clientY);\n        boardPos[0] |= 0;\n        boardPos[1] |= 0;\n\n        let [lastX, lastY] = boardPos;\n\n        if (lastX === lastPressCord[0] && lastY === lastPressCord[1])\n            return;\n\n        console.log({ lastX, lastY, boardPos, lastPressCord })\n\n        xInput.val(template.x -= lastPressCord[0] - lastX);\n        yInput.val(template.y -= lastPressCord[1] - lastY);\n\n        template.updatePosition();\n\n        lastPressCord = boardPos;\n\n        saveTemplate();\n    }\n\n    function mouseup() {\n        globals.eventManager.off('mousemove', mousemove);\n    }\n\n    globals.eventManager.on('mousedown', mousedown);\n    globals.eventManager.on('mouseup', mouseup);\n\n    moveBtn.on('click', () => {\n        if (isMovingEnabled) {\n            moveBtn.removeClass('active');\n            // just to be sure\n            mouseup();\n\n            globals.toolManager.unblockToolChange();\n            restoreTool();\n        } else {\n            moveBtn.addClass('active');\n            saveAndResetTool();\n            globals.toolManager.blockToolChange();\n        }\n\n        isMovingEnabled = !isMovingEnabled;\n    });\n\n    // workaround, because to just cancel events \n    // (to prevent tools doing their job during the placement) \n    // we need to rewrite whole eventManager\n    let savedTool, savedColors;\n    function saveAndResetTool() {\n        savedTool = globals.toolManager.tool;\n        savedColors = [player.color, player.secondCol];\n\n        globals.toolManager.selectTool(globals.toolManager.tools['clicker']);\n        player.resetColors();\n    }\n\n    function restoreTool() {\n        globals.toolManager.selectTool(savedTool);\n        [player.color, player.secondCol] = savedColors;\n    }\n}\n\n\n\n\nexport default template;","import player, { updateBrush } from '../player';\r\nimport Tool from '../Tool';\r\n\r\n\r\nexport const incBrush = new Tool('+brush size', 'BracketRight'); // [\r\nincBrush.on('down', () => {\r\n    if (player.brushSize >= 100) return;\r\n    // 1,2,3,5,7,9,...\r\n    const delta = player.brushSize >= 3 ? 2 : 1;\r\n    updateBrush(player.brushSize + delta);\r\n});\r\nexport const decBrush = new Tool('-brush size', 'BracketLeft'); // ]\r\ndecBrush.on('down', () => {\r\n    if(player.brushSize === 1) return;\r\n\r\n    const delta = player.brushSize <= 4 ? 1 : 2;\r\n    updateBrush(player.brushSize - delta);\r\n});\r\n","import { onToolManager, mobile, renderFX, getColByCord, getPixel, getProtect, getCurCol } from \"./toolUtils\";\r\nimport clickerIcon from '../../img/toolIcons/clicker.png';\r\nimport camera from '../camera';\r\nimport { hexPalette } from '../config';\r\nimport { ROLE } from '../constants';\r\nimport { addFX, FX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport me from '../me';\r\nimport player, { placePixel, placePixels } from '../player';\r\nimport Tool from '../Tool';\r\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\r\nimport shapes from '../utils/shapes';\r\n\r\n\r\nexport class Clicker extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this._pendingPixels = {};\r\n\r\n        this.minZoom = 2;\r\n\r\n        this.on('down', this.down);\r\n        this.on('up', this.up);\r\n        this.on('move', this.move);\r\n        this.on('leave', this.up);\r\n        this.on('_gesture', this.ongesture);\r\n\r\n        onToolManager(() => {\r\n            // mobile is already subscribed to pointer events\r\n            // so this will duplicate them\r\n            if (!mobile) {\r\n                globals.eventManager.on('mousedown', this.mousedown.bind(this));\r\n                globals.toolManager.on('move', this.move.bind(this));\r\n                globals.eventManager.on('mouseup', this.mouseup.bind(this));\r\n            }\r\n        });\r\n\r\n        this.clrInterval = setInterval(() => {\r\n            if (this.clearPending())\r\n                renderFX();\r\n        }, 250);\r\n\r\n        // pending pixels debug visualizer\r\n        this.fx = new FX(this.render.bind(this));\r\n        // addFX(this.fx);\r\n    }\r\n\r\n    // mouse zone\r\n    mousedown(e) {\r\n        if (e.button !== 0) return;\r\n        this.screenPos = [e.clientX, e.clientY];\r\n    }\r\n    mouseup(e) {\r\n        if (globals.toolManager.tools['mover'].key !== 'LMB' || camera.zoom <= 1) return;\r\n\r\n        if (e.button !== 0 || !this.screenPos) return;\r\n        const dx = Math.abs(e.clientX - this.screenPos[0]);\r\n        const dy = Math.abs(e.clientY - this.screenPos[1]);\r\n        if (dx > 5 || dy > 5) return;\r\n\r\n        const [x, y] = [player.x, player.y];\r\n        const color = getColByCord(x, y);\r\n        if (this.checkPixel(x, y) && ~color)\r\n            placePixel(player.x, player.y, getColByCord(x, y));\r\n    }\r\n    // end of mouse zone\r\n    down(e) {\r\n        if (this.mouseIsDown || camera.zoom < this.minZoom) return;\r\n\r\n        this.lastPos = [player.x, player.y];\r\n        this.screenPos = [e.clientX, e.clientY];\r\n\r\n\r\n\r\n        this.mouseIsDown = true;\r\n\r\n        if (!mobile)\r\n            this.emit('move', {});\r\n        else {\r\n            this.pointerId = e.pointerId;\r\n        }\r\n    }\r\n    up(e) {\r\n        if (this.mouseIsDown) {\r\n            if (mobile)\r\n                this.emit('move', e, true);\r\n            this.mouseIsDown = false;\r\n        }\r\n    }\r\n\r\n    ongesture() {\r\n        this.mouseIsDown = false;\r\n        this.lastPos = null;\r\n    }\r\n\r\n    checkPixel(x, y) {\r\n        const key = `${x},${y}`;\r\n        const myColor = getColByCord(x, y);\r\n\r\n        const pixel = getPixel(x, y), isProtected = getProtect(x, y);\r\n        if (pixel === myColor || pixel === -1 || (isProtected && me.role < ROLE.TRUSTED)) return;\r\n\r\n        if (this._pendingPixels[key] && this._pendingPixels[key][0] === myColor) return;\r\n        this._pendingPixels[key] = [myColor, Date.now()];\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    */\r\n    move(e, isUp = false) {\r\n        if (e.gesture) {\r\n            // if gesture is started, we reset mousedown state\r\n            this.ongesture();\r\n            return;\r\n        }\r\n        if (!this.mouseIsDown ||\r\n            e.gesture ||\r\n            getCurCol() === -1) return;\r\n\r\n        // mobile and same pointerid as at down but also not initiated by 'up' event\r\n        if (mobile && this.pointerId !== e.pointerId)\r\n            return;\r\n\r\n        const screenX = e.clientX, screenY = e.clientY;\r\n\r\n        const dx = Math.abs(screenX - this.screenPos[0]);\r\n        const dy = Math.abs(screenY - this.screenPos[1]);\r\n\r\n        if (dx < 5 && dy < 5 && !isUp) {\r\n            return;\r\n        }\r\n\r\n        // workaround for the bug when drawing line is torn apart\r\n        const mover = globals.toolManager.tools.mover;\r\n        let x, y;\r\n        if (mover.antijitterDownPos) {\r\n            [x, y] = mover.antijitterDownPos;\r\n        } else if (e.clientX && e.clientY) {\r\n            [x, y] = screenToBoardSpace(e.clientX, e.clientY);\r\n        } else {\r\n            [x, y] = [player.x, player.y];\r\n        }\r\n        \r\n        \r\n        let line = shapes.line(x, y, this.lastPos[0], this.lastPos[1]);\r\n        this.lastPos = [x, y];\r\n        \r\n        let circle = [[0, 0]];\r\n        if (player.brushSize !== 1) {\r\n            circle = globals.renderer.preRendered.brush.circle;\r\n        }\r\n\r\n        let c = 0;\r\n        for (let [x, y] of line) {\r\n            let pixels = [];\r\n\r\n            if (!this.checkAllowance(circle.length)) return;\r\n            circle.forEach(([cx, cy]) => {\r\n                let _x = x + cx;\r\n                let _y = y + cy;\r\n                if (this.checkPixel(_x, _y)) {\r\n                    const myColor = getColByCord(_x, _y); // duplicate\r\n                    pixels.push([_x, _y, myColor]);\r\n                }\r\n                c++;\r\n            });\r\n\r\n            this.place(pixels);\r\n        }\r\n    }\r\n\r\n    checkAllowance(count) {\r\n        return player.bucket.allowance >= count;\r\n    }\r\n\r\n    place(pixels) {\r\n        if (pixels.length === 0) return;\r\n\r\n        player.bucket.spend(pixels.length);\r\n\r\n        if (pixels.length == 1) {\r\n            placePixel(...pixels[0]);\r\n        }\r\n        else\r\n            placePixels(pixels);\r\n    }\r\n\r\n    render(ctx) {\r\n        const zoom = camera.zoom;\r\n        ctx.lineWidth = zoom / 5;\r\n        ctx.globalAlpha = .5;\r\n\r\n        for (let key of Object.keys(this._pendingPixels)) {\r\n            let [x, y] = key.split(',').map(x => parseInt(x, 10));\r\n\r\n            const color = this._pendingPixels[key][0];\r\n            ctx.strokeStyle = '#000000';\r\n            ctx.fillStyle = hexPalette[color];\r\n\r\n            const [scrX, scrY] = boardToScreenSpace(x, y);\r\n\r\n\r\n            ctx.strokeRect(scrX, scrY, zoom, zoom);\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n\r\n        return 1;\r\n    }\r\n\r\n    clearPending() {\r\n        let deletedSome = false;\r\n        Object.keys(this._pendingPixels).forEach(key => {\r\n            let timestamp = this._pendingPixels[key][1];\r\n\r\n            if (Date.now() - timestamp > 500) {\r\n                delete this._pendingPixels[key];\r\n                deletedSome = true;\r\n            }\r\n        });\r\n\r\n        return deletedSome;\r\n    }\r\n}\r\nconst clicker = new Clicker('clicker', 'Space', clickerIcon);\r\nexport default clicker;","import player from '../player';\r\nimport Tool from '../Tool';\r\n\r\nexport const colorSwap = new Tool('swap colors', 'KeyX');\r\ncolorSwap.on('up', player.swapColors.bind(player));\r\n\r\nexport default colorSwap;","import camera from '../camera';\r\nimport { boardHeight, boardWidth, allColors } from '../config';\r\nimport { ROLE } from '../constants';\r\nimport { addFX, FX, removeFX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport { paste } from \"./paste\";\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\nimport { mainCanvas } from '../ui/elements';\r\nimport { boardToScreenSpace } from '../utils/conversions';\r\nimport { testPointInPolygon } from '../utils/misc';\r\n\r\n\r\nclass Copy extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        // 0 - idle\r\n        // 1 - started selection\r\n        this.state = 0;\r\n\r\n        this.selectFX = null;\r\n\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    down(e) {\r\n        if (this.state > 0 || paste.state > 0)\r\n            return;\r\n\r\n        // since default key is ctrl+c\r\n        const isTextSelected = (window.getSelection().type === 'Range');\r\n        if (isTextSelected) return;\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        camera.disableMove();\r\n        player.suspendColors();\r\n        mainCanvas.css('cursor', 'crosshair');\r\n\r\n        this.state = 1;\r\n\r\n        let fx;\r\n        let startX, startY, endX, endY;\r\n\r\n        let altPressed = false, lassoMode = false, lassoPoints = [];\r\n        function keydown(e) {\r\n            if (e.key === 'Alt')\r\n                altPressed = true;\r\n        }\r\n        // function keyup(e) {\r\n        //     // tf is this ... ???\r\n        //     if (e.key === 'Alt')\r\n        //         altPressed = false;\r\n        // }\r\n        function mousedown() {\r\n            if (altPressed) {\r\n                lassoMode = true;\r\n                lassoPoints = [[player.x, player.y]];\r\n            } else {\r\n                startX = player.x;\r\n                startY = player.y;\r\n            }\r\n        }\r\n        function mousemove() {\r\n            if (lassoMode) {\r\n                let x = player.x, y = player.y;\r\n\r\n                lassoPoints.push([x, y]);\r\n            } else {\r\n                endX = player.x + 1;\r\n                endY = player.y + 1;\r\n            }\r\n        }\r\n        function mouseup() {\r\n            // area is selected and we can tell Paste tool to draw it\r\n            mainCanvas.css('cursor', '');\r\n\r\n            removeFX(fx);\r\n\r\n            globals.eventManager.off('keydown', keydown);\r\n            // globals.eventManager.off('keyup', keyup);\r\n            globals.eventManager.off('mousedown', mousedown);\r\n            globals.eventManager.off('mousemove', mousemove);\r\n            globals.eventManager.off('mouseup', mouseup);\r\n\r\n            this.state = 0;\r\n\r\n            camera.enableMove();\r\n            player.restoreColors();\r\n\r\n            onSelected();\r\n        }\r\n\r\n        function render(ctx) {\r\n            ctx.save();\r\n\r\n            ctx.strokeStyle = 'gray';\r\n            ctx.lineWidth = 2;\r\n            ctx.setLineDash([3, 3]);\r\n            ctx.globalAlpha = 1;\r\n\r\n            if (lassoMode) {\r\n                ctx.beginPath();\r\n                const firstCord = boardToScreenSpace(lassoPoints[0][0], lassoPoints[0][1]);\r\n                ctx.moveTo(...firstCord);\r\n                for (let i = 1; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    ctx.lineTo(...boardToScreenSpace(...point));\r\n                }\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n            } else {\r\n                const [x1, y1] = boardToScreenSpace(startX, startY);\r\n                const [x2, y2] = boardToScreenSpace(endX, endY);\r\n                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);\r\n            }\r\n\r\n            ctx.restore();\r\n            return 1;\r\n        }\r\n        fx = new FX(render);\r\n        addFX(fx);\r\n\r\n        keydown = keydown.bind(this);\r\n        // keyup = keyup.bind(this);\r\n        mousedown = mousedown.bind(this);\r\n        mousemove = mousemove.bind(this);\r\n        mouseup = mouseup.bind(this);\r\n\r\n        globals.eventManager.on('keydown', keydown);\r\n        // globals.eventManager.on('keyup', keyup);\r\n        globals.eventManager.on('mousedown', mousedown);\r\n        globals.eventManager.on('mousemove', mousemove);\r\n        globals.eventManager.on('mouseup', mouseup);\r\n\r\n\r\n        function onSelected() {\r\n            let minX, maxX, minY, maxY;\r\n            if (lassoMode) {\r\n                minX = maxX = lassoPoints[0][0];\r\n                minY = maxY = lassoPoints[0][1];\r\n                for (let i = 0; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    if (point[0] < minX)\r\n                        minX = point[0];\r\n                    if (point[0] > maxX)\r\n                        maxX = point[0];\r\n                    if (point[1] < minY)\r\n                        minY = point[1];\r\n                    if (point[1] > maxY)\r\n                        maxY = point[1];\r\n                }\r\n            } else {\r\n                if ([startX, startY, endX, endY].some(x => x === undefined))\r\n                    return;\r\n\r\n                minX = Math.min(startX, endX);\r\n                maxX = Math.max(startX, endX) + 1;\r\n                minY = Math.min(startY, endY);\r\n                maxY = Math.max(startY, endY) + 1;\r\n            }\r\n\r\n            // normalize coordinates\r\n            minX = Math.max(minX, 0);\r\n            maxX = Math.min(maxX, boardWidth);\r\n            minY = Math.max(minY, 0);\r\n            maxY = Math.min(maxY, boardHeight);\r\n\r\n            const w = maxX - minX;\r\n            const h = maxY - minY;\r\n\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = w;\r\n            canvas.height = h;\r\n\r\n            const ctx = canvas.getContext('2d');\r\n            const data = ctx.createImageData(w, h);\r\n            const protectMask = new Uint8Array(w * h);\r\n\r\n            // poly x coordinates and y coordinates arrays\r\n            let vertx, verty;\r\n            if (lassoMode) {\r\n                vertx = new Array(lassoPoints.length);\r\n                verty = new Array(lassoPoints.length);\r\n\r\n                for (let i = 0; i < lassoPoints.length; i++) {\r\n                    const point = lassoPoints[i];\r\n                    vertx[i] = point[0];\r\n                    verty[i] = point[1];\r\n                }\r\n            }\r\n\r\n            // local canvas coordinates\r\n            for (let x = 0; x < w; x++) {\r\n                for (let y = 0; y < h; y++) {\r\n                    const i = (x + y * w) * 4;\r\n\r\n                    // absolute board coordinates\r\n                    const absX = minX + x;\r\n                    const absY = minY + y;\r\n\r\n                    if (lassoMode && !testPointInPolygon(lassoPoints.length, vertx, verty, absX, absY)) {\r\n                        continue;\r\n                    }\r\n\r\n\r\n                    const isProtected = globals.chunkManager.getProtect(absX, absY);\r\n                    protectMask[i / 4] = isProtected;\r\n\r\n                    const colId = globals.chunkManager.getChunkPixel(absX, absY);\r\n                    const col = allColors[colId];\r\n\r\n                    data.data[i] = col[0];\r\n                    data.data[i + 1] = col[1];\r\n                    data.data[i + 2] = col[2];\r\n                    data.data[i + 3] = 255;\r\n                }\r\n            }\r\n\r\n            ctx.putImageData(data, 0, 0);\r\n\r\n            // let the Paste tool do other stuff\r\n            paste.startPlace(canvas, protectMask);\r\n        }\r\n    }\r\n}\r\nconst copy = new Copy('copy', 'CTRL+KeyC', null, ROLE.MOD);\r\n\r\nexport default copy;","// import pipetteIcon from '.../img/toolIcons/pipette.png'\r\nimport revertIcon from '../../img/toolIcons/revert.png';\r\nimport globals from '../globals';\r\nimport player, { placePixel } from '../player';\r\nimport Tool from '../Tool';\r\n\r\n\r\nclass CtrlZ extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n    }\r\n\r\n    handlers() {\r\n        let isDown = false;\r\n\r\n        function reset() {\r\n            isDown = false;\r\n\r\n            this.off('tick', tick);\r\n            tickTime = tickMax;\r\n            lastTick = 0;\r\n        }\r\n        reset = reset.bind(this);\r\n\r\n        const down = function (e) {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (e.gesture) {\r\n                return reset();\r\n            }\r\n\r\n            // i know about e.repeat\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            tick();\r\n            this.on('tick', tick);\r\n        }.bind(this);\r\n\r\n        const move = function (e) {\r\n            if (e.gesture) {\r\n                reset();\r\n            }\r\n        }.bind(this);\r\n\r\n        const up = function () {\r\n            reset();\r\n        }.bind(this);\r\n\r\n        const tickMax = 500;\r\n        const tickMin = 50;\r\n\r\n        const nocdMinTick = 2;\r\n        // ticknow = ticknow - (ts / nocdStepFactor)\r\n        // i.e ms passed since last tick divided by this factor\r\n        const nocdStepFactor = 100;\r\n\r\n        const step = 1.5;\r\n        let tickTime = tickMax;\r\n\r\n        let lastTick = 0;\r\n        const tick = function () {\r\n            const ts = Date.now() - lastTick;\r\n            if (ts < tickTime) return;\r\n            let multiTicks = ts / tickTime | 0;\r\n            // when lastTick is 0 (tool is just activated)\r\n            if (multiTicks < 0) multiTicks = 1;\r\n\r\n            lastTick = Date.now();\r\n\r\n            do {\r\n                // if (tickTime <= tickMin) {\r\n                //     if(player.bucket.delay < tickMin){\r\n                //         tickTime = Math.max(nocdMinTick, tickTime-(ts/nocdStepFactor))\r\n                //     }\r\n                // }else{\r\n                //     tickTime /= step;\r\n                // }\r\n                // instead of speeding up we'll do it only if alt pressed\r\n                const altFactor = globals.toolManager.altDown ? 0.2 : 1;\r\n                tickTime = Math.max(tickTime / step, tickMin * altFactor);\r\n\r\n                if (player.placed.length > player.maxPlaced) {\r\n                    player.placed = player.placed.slice(-player.maxPlaced);\r\n                }\r\n                if (!player.placed.length) return;\r\n                if (!player.bucket.spend(1)) return;\r\n\r\n                const [x, y, c] = player.placed.pop();\r\n\r\n                placePixel(x, y, c, false, true);\r\n            }\r\n            while (--multiTicks);\r\n        }.bind(this);\r\n\r\n        this.on('down', down);\r\n        globals.eventManager.on('mousemove', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst ctrlZ = new CtrlZ('ctrlZ', 'KeyZ', revertIcon);\r\nexport default ctrlZ;","import { renderFX, getColByCord, getPixel, getCurCol } from \"./toolUtils\";\r\nimport floodfillIcon from '../../img/toolIcons/floodfill.png';\r\nimport camera from '../camera';\r\nimport { hexPalette } from '../config';\r\nimport { addFX, FX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport player, { placePixel } from '../player';\r\nimport Tool from '../Tool';\r\nimport { inBounds } from '../utils/camera';\r\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\r\n\r\n\r\nclass FloodFill extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.on('up', this.up);\r\n        this.on('down', this.down);\r\n        this.on('leave', this.up);\r\n\r\n        this.on('tick', this.tick);\r\n\r\n        this.previewing = false;\r\n        this.fx = null;\r\n        this.prevStack = [];\r\n    }\r\n\r\n    up(e, isCancel) {\r\n        if (this.active) { // stop and return\r\n            this.active = false;\r\n            return;\r\n        }\r\n\r\n        if (this.previewing) {\r\n            this.fx.remove();\r\n            renderFX();\r\n            this.previewing = false;\r\n        } else return; // means that key wasn't pressed\r\n\r\n\r\n        if (isCancel)\r\n            return;\r\n\r\n        const cord = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (getColByCord(...cord) === -1 || !inBounds(...cord) || e.type === 'mouseleave') {\r\n            return;\r\n        }\r\n\r\n        this.active = true;\r\n\r\n        this.stack = [\r\n            [player.x, player.y]\r\n        ];\r\n\r\n        this.playerCol = player.color;\r\n        this.secondPlayerCol = player.secondCol;\r\n        this.fillingCol = getPixel(player.x, player.y);\r\n    }\r\n\r\n    down(e) {\r\n        // preview floodfill\r\n        if (e.repeat || this.previewing || this.active) {\r\n            return;\r\n        }\r\n\r\n        const cord = screenToBoardSpace(e.clientX, e.clientY);\r\n        if (getColByCord(...cord) === -1 || !inBounds(...cord)) {\r\n            return;\r\n        }\r\n        let _lastX, _lastY;\r\n\r\n        restart.apply(this);\r\n\r\n        this.showedPixels = [];\r\n        this.fillingCol = getPixel(player.x, player.y);\r\n\r\n        let fx = new FX(tick.bind(this));\r\n        addFX(fx, 0);\r\n\r\n        this.fx = fx;\r\n\r\n        //globals.renderer.needRender = true;\r\n        this.previewing = true;\r\n\r\n        function restart() {\r\n            this.prevStack = [\r\n                [player.x, player.y]\r\n            ];\r\n            this.showedPixels = [];\r\n\r\n            _lastX = player.x;\r\n            _lastY = player.y;\r\n\r\n            this.playerCol = player.color;\r\n            this.secondPlayerCol = player.secondCol;\r\n            this.fillingCol = getPixel(player.x, player.y);\r\n        }\r\n\r\n        function paint() {\r\n            if (!this.prevStack.length) return 1;\r\n\r\n            let [x, y] = this.prevStack.pop();\r\n\r\n            let color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n            let tileCol = getPixel(x, y);\r\n            let painted = this.showedPixels.indexOf(x + ',' + y) !== -1;\r\n\r\n            if (painted || tileCol === color || tileCol !== this.fillingCol || !inBounds(x, y)) {\r\n                return 0;\r\n            }\r\n\r\n            this.showedPixels.push(x + ',' + y);\r\n\r\n            let top = this.checkP(x, y - 1);\r\n            let bottom = this.checkP(x, y + 1);\r\n            let left = this.checkP(x - 1, y);\r\n            let right = this.checkP(x + 1, y);\r\n            if (top && left) {\r\n                this.checkP(x - 1, y - 1);\r\n            }\r\n            if (top && right) {\r\n                this.checkP(x + 1, y - 1);\r\n            }\r\n            if (bottom && left) {\r\n                this.checkP(x - 1, y + 1);\r\n            }\r\n            if (bottom && right) {\r\n                this.checkP(x + 1, y + 1);\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        function tick(ctx) {\r\n            if (globals.mobile && globals.toolManager.tool !== this) {\r\n                this.up({}, true);\r\n                return 1;\r\n            }\r\n            if (player.x != _lastX || player.y != _lastY) {\r\n                restart.call(this);\r\n            }\r\n            if (getCurCol() === -1) return 1;\r\n\r\n            let res = 0;\r\n            for (let i = 0; i < 700 && res == 0; i++)\r\n                res = paint.call(this);\r\n\r\n\r\n            ctx.strokeWidth = camera.zoom;\r\n\r\n            this.showedPixels.forEach((p, i) => {\r\n                let [x, y] = p.split(',').map(x => parseInt(x, 10));\r\n\r\n                let alpha = 1;\r\n                let len = this.showedPixels.length;\r\n                if (len >= 100 && i < len / 2) {\r\n                    alpha = 1 - (((len / 2) - i) / (len / 2));\r\n                    if (alpha <= 0) return;\r\n                }\r\n                ctx.globalAlpha = alpha;\r\n\r\n                const color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n                ctx.strokeStyle = hexPalette[color];\r\n\r\n                let [absX, absY] = boardToScreenSpace(x, y);\r\n                ctx.strokeRect(absX, absY, camera.zoom, camera.zoom);\r\n            });\r\n\r\n            return res;\r\n        }\r\n    }\r\n\r\n    checkP(x, y) {\r\n        if (getPixel(x, y) !== this.fillingCol) return false;\r\n        this.prevStack.unshift([x, y]);\r\n        return true;\r\n    }\r\n\r\n    tick() {\r\n        if (!this.active) return;\r\n\r\n        for (let i = 0; i < 15 && this.stack.length; i++) {\r\n            let nextX = this.stack[this.stack.length - 1][0];\r\n\r\n            if (!player.bucket.spend(1)) break;\r\n\r\n            let [x, y] = this.stack.pop();\r\n\r\n            let color = getColByCord(x, y, this.playerCol, this.secondPlayerCol);\r\n            let tileCol = getPixel(x, y);\r\n\r\n            if (tileCol === color || tileCol !== this.fillingCol || !inBounds(x, y)) {\r\n                continue;\r\n            }\r\n\r\n            //this.stack.push([x, y]);\r\n            let top = this.check(x, y - 1);\r\n            let bottom = this.check(x, y + 1);\r\n            let left = this.check(x - 1, y);\r\n            let right = this.check(x + 1, y);\r\n            if (top && left) {\r\n                this.check(x - 1, y - 1);\r\n            }\r\n            if (top && right) {\r\n                this.check(x + 1, y - 1);\r\n            }\r\n            if (bottom && left) {\r\n                this.check(x - 1, y + 1);\r\n            }\r\n            if (bottom && right) {\r\n                this.check(x + 1, y + 1);\r\n            }\r\n\r\n            placePixel(x, y, color);\r\n        }\r\n\r\n        if (!this.stack.length) return this.active = false;\r\n    }\r\n\r\n    check(x, y) {\r\n        if (getPixel(x, y) !== this.fillingCol) return false;\r\n        this.stack.unshift([x, y]);\r\n        return true;\r\n    }\r\n}\r\nconst floodfill = new FloodFill('floodfill', 'KeyF', floodfillIcon);\r\nexport default floodfill;","import { mobile } from \"./toolUtils\";\r\nimport wandCursor from '../../img/toolIcons/wand-cur.png';\r\nimport wandIcon from '../../img/toolIcons/wand-cur.png';\r\nimport { allColors, argbToId, hexPalette } from '../config';\r\nimport { addFX, FX, FX_STATE, removeFX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\nimport { isDarkColor, rgb2abgr } from '../utils/color';\r\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\r\nimport { isClick } from '../utils/misc';\r\nimport { generateShader } from '../utils/webGL';\r\nimport bayerMatrices from '../convert/matrices/bayer';\r\nimport camera from \"../camera\";\r\nimport MiniWindow from \"../MiniWindow\";\r\nimport { translate as t } from \"../translate\";\r\nimport { capitalize } from \"../utils/strings\";\r\nimport { getLS, setLS } from \"../utils/localStorage\";\r\n\r\n\r\nconst GRAD_STATE = {\r\n    DISABLED: 0,\r\n    ENABLED: 1,\r\n    SELECTING: 2,\r\n    PREVIEWING: 2\r\n};\r\nconst FILL_MODE = {\r\n    FLOODFILL: 0,\r\n    GLOBAL: 1,\r\n}\r\n\r\nlet gradientCanvas = null, gradientCtx = null;\r\nfunction generateGradient(w, h, x1, y1, x2, y2, color1, color2) {\r\n    if (gradientCanvas === null || gradientCanvas.width < w || gradientCanvas.height < h ||\r\n        // re-create the canvas if its too big - causes lags\r\n        gradientCanvas.width / w >= 2 || gradientCanvas.height / h >= 2\r\n    ) {\r\n        if (gradientCanvas === null) {\r\n            gradientCanvas = document.createElement('canvas');\r\n            gradientCtx = gradientCanvas.getContext('2d');\r\n        }\r\n        gradientCanvas.width = w;\r\n        gradientCanvas.height = h;\r\n    } else {\r\n        gradientCtx.clearRect(0, 0, w, h);\r\n    }\r\n\r\n    // edge case\r\n    // if (x1 === x2 && y1 === y2) {\r\n    //     gradientCtx.save();\r\n    //     gradientCtx.fillStyle = color2;\r\n    //     gradientCtx.fillRect(0, 0, w, h);\r\n    //     gradientCtx.restore();\r\n    //     return gradientCanvas;\r\n    // }\r\n\r\n    // const grad = gradientCtx.createLinearGradient(x1, y1, x2, y2);\r\n\r\n    // // we should swap colors because createLinearGradient does the same\r\n    // grad.addColorStop(0.0, color2);\r\n    // grad.addColorStop(1.0, color1);\r\n\r\n    // gradientCtx.save();\r\n    // gradientCtx.fillStyle = grad;\r\n    // gradientCtx.fillRect(0, 0, w, h);\r\n    // gradientCtx.restore();\r\n\r\n    return gradientCanvas;\r\n}\r\n\r\n\r\nfunction euclidianRGBA(c1, c2) {\r\n    const dR = c1[0] - c2[0];\r\n    const dG = c1[1] - c2[1];\r\n    const dB = c1[2] - c2[2];\r\n    const dA = c1[3] - c2[3];\r\n\r\n    return Math.sqrt(dR * dR + dG * dG + dB * dB + dA * dA);\r\n}\r\nfunction distXY(cord1, cord2) {\r\n    const dx = cord1[0] - cord2[0];\r\n    const dy = cord1[1] - cord2[1];\r\n\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\nfunction nearestColorId(rgba, palette) {\r\n    let dist = 510, colId = -1;\r\n    for (let i = 0; i < palette.length; i++) {\r\n        const col = palette[i];\r\n\r\n        const curDist = euclidianRGBA(rgba, col);\r\n        if (curDist < dist) {\r\n            dist = curDist;\r\n            colId = i;\r\n        }\r\n    }\r\n    return colId;\r\n}\r\n\r\nfunction clamp(num, min, max) {\r\n    return Math.max(min, Math.min(max, num))\r\n}\r\n// we can use these functions to draw gradients without drawing it\r\nfunction getLinearGradientPosition(x, y, x0, y0, x1, y1) {\r\n    const dx = x1 - x0;\r\n    const dy = y1 - y0;\r\n\r\n    const len2 = dx * dx + dy * dy;\r\n\r\n    if (len2 === 0)\r\n        return 0;\r\n\r\n    const t = ((x - x0) * dx + (y - y0) * dy) / len2;\r\n\r\n    return clamp(t, 0, 1);\r\n}\r\nfunction getRadialGradientPosition(x, y, x0, y0, x1, y1) {\r\n    const maxDist = Math.hypot(x1 - x0, y1 - y0);\r\n\r\n    if (maxDist === 0)\r\n        return 0;\r\n\r\n    const dist = Math.hypot(x - x0, y - y0);\r\n\r\n    const t = dist / maxDist;\r\n\r\n    return clamp(t, 0, 1);\r\n}\r\n\r\n// quantize gradient to the palette using some dithering\r\nfunction ditherGradient(ctx, color1, color2, matrixSize, gradientProps) {\r\n    const matrix = bayerMatrices[matrixSize];\r\n    const matrixLen = matrixSize ** 2;\r\n\r\n    let firstTransparent = color1 === null,\r\n        secondTransparent = color2 === null;\r\n    if (firstTransparent) {\r\n        color1 = [0, 0, 0, 0];\r\n    }\r\n    if (secondTransparent) {\r\n        color2 = [0, 0, 0, 0];\r\n    }\r\n\r\n    if (color1.length === 3) {\r\n        color1 = [...color1, 255];\r\n    }\r\n    if (color2.length === 3) {\r\n        color2 = [...color2, 255];\r\n    }\r\n\r\n    const w = ctx.canvas.width;\r\n    const h = ctx.canvas.height;\r\n\r\n    const ox = gradientProps.originX;\r\n    const oy = gradientProps.originY;\r\n\r\n    const imageData = ctx.getImageData(0, 0, w, h);\r\n    const data = imageData.data;\r\n\r\n    for (let y = 0; y < h; y++) {\r\n        for (let x = 0; x < w; x++) {\r\n            const i = (y * w + x) * 4;\r\n\r\n            const matrixVal = matrix[Math.abs(ox + x) % matrixSize][Math.abs(oy + y) % matrixSize];\r\n            const matrixValNorm = ((matrixVal + 0.5) / matrixLen);\r\n\r\n            let gradientPos;\r\n            if (gradientProps.isRadial) {\r\n                gradientPos = getRadialGradientPosition(x, y, gradientProps.p1[0], gradientProps.p1[1], gradientProps.p2[0], gradientProps.p2[1]);\r\n            } else {\r\n                gradientPos = getLinearGradientPosition(x, y, gradientProps.p1[0], gradientProps.p1[1], gradientProps.p2[0], gradientProps.p2[1]);\r\n            }\r\n\r\n            const useFirst = gradientPos < matrixValNorm;\r\n            let col = useFirst ? color1 : color2;\r\n\r\n            data[i + 0] = col[0];\r\n            data[i + 1] = col[1];\r\n            data[i + 2] = col[2];\r\n            data[i + 3] = col[3];\r\n        }\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n    return ctx.canvas;\r\n}\r\n\r\nfunction selectColor(ctx, rgb, startX, startY, floodfillMode) {\r\n    const canvas = ctx.canvas;\r\n    const w = canvas.width;\r\n    const h = canvas.height;\r\n\r\n    const imData = ctx.getImageData(0, 0, w, h);\r\n    const view = new Int32Array(imData.data.buffer);\r\n    if (!rgb) {\r\n        ctx.clearRect(0, 0, w, h);\r\n        return;\r\n    }\r\n\r\n    const targetAbgr = rgb2abgr(...rgb);\r\n\r\n    if (floodfillMode === FILL_MODE.GLOBAL) {\r\n        for (let i = 0; i < view.length; i++) {\r\n            const color = view[i];\r\n\r\n            if (color !== targetAbgr) {\r\n                view[i] = 0;\r\n            }\r\n        }\r\n    } else if (floodfillMode === FILL_MODE.FLOODFILL) {\r\n        floodFillScanline(view, w, h, startX, startY);\r\n    }\r\n\r\n    ctx.putImageData(imData, 0, 0);\r\n}\r\nfunction floodFillScanline(view, w, h, startX, startY) {\r\n    const startIndex = startY * w + startX;\r\n    const targetColor = view[startIndex];\r\n    if (targetColor === undefined) return;\r\n\r\n    const fillColor = targetColor - 0x01000000;\r\n    if (targetColor === fillColor) return;\r\n\r\n    const stack = [startIndex];\r\n\r\n    while (stack.length) {\r\n        let idx = stack.pop();\r\n\r\n        let left = idx;\r\n        while (left % w > 0 && view[left - 1] === targetColor) left--;\r\n\r\n        let right = idx;\r\n        while (right % w < w - 1 && view[right + 1] === targetColor) right++;\r\n\r\n        for (let x = left; x <= right; x++) {\r\n            view[x] = fillColor;\r\n\r\n            const up = x - w;\r\n            const down = x + w;\r\n\r\n            if (up >= 0 && view[up] === targetColor) stack.push(up);\r\n            if (down < w * h && view[down] === targetColor) stack.push(down);\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < view.length; i++) {\r\n        if (view[i] !== fillColor) view[i] = 0;\r\n    }\r\n}\r\n\r\nfunction doISOSetup(start_x, start_y, x1, y1) {\r\n    const dx = x1 - start_x;\r\n    const dy = y1 - start_y;\r\n\r\n    let angle = Math.atan2(dy, dx) * 180 / Math.PI;\r\n    if (angle < 0) angle += 360;\r\n\r\n    const snapAngles = [0, 45, 90, 135, 180, 225, 270, 315];\r\n\r\n    let closest = snapAngles.reduce((prev, curr) => {\r\n        const diffPrev = Math.min(Math.abs(prev - angle), 360 - Math.abs(prev - angle));\r\n        const diffCurr = Math.min(Math.abs(curr - angle), 360 - Math.abs(curr - angle));\r\n        return diffCurr < diffPrev ? curr : prev;\r\n    });\r\n\r\n    const rad = closest * Math.PI / 180;\r\n    const len = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    x1 = start_x + Math.cos(rad) * len;\r\n    y1 = start_y + Math.sin(rad) * len;\r\n\r\n    return [x1 | 0, y1 | 0];\r\n}\r\n\r\n\r\n\r\n\r\n\r\nclass Gradient extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.state = GRAD_STATE.DISABLED;\r\n\r\n        this.mouseListeners = {\r\n            down: this.mousedown.bind(this),\r\n            move: this.mousemove.bind(this),\r\n            up: this.mouseup.bind(this)\r\n        };\r\n\r\n        // color on which to render/draw the gradient\r\n        this.selectedColor = null;\r\n\r\n        this.firstPointPos = null;\r\n        this.secondPointPos = null;\r\n\r\n        this.movingFirstPoint = false;\r\n        this.movingSecondPoint = false;\r\n        this.movingDone = false;\r\n\r\n        this.previewCanvas = null;\r\n        this.previewProps = {\r\n            // canvas x/y to know where to draw the preview\r\n            x: null,\r\n            y: null,\r\n            // w/h of the current gradient, since old(larger) canvas could be reused\r\n            w: null,\r\n            h: null,\r\n        }\r\n        this.fx = null;\r\n\r\n        this.options = {\r\n            globalMaxRadius: 10,\r\n            fillMode: parseInt(getLS('grad:fill_mode') || FILL_MODE.FLOODFILL),\r\n            isRadial: getLS('grad:radial') === 'true',\r\n            magnetMode: getLS('grad:magnet_mode') === 'true',\r\n            matrixSize: parseInt(getLS('grad:matrix_size') || 2)\r\n        }\r\n\r\n        this.menuWindow = null;\r\n        this.lastMenuPos = null;\r\n\r\n        this.on('up', this.up.bind(this));\r\n        this.on('selected', this.selected.bind(this));\r\n        this.on('deselected', this.deselected.bind(this));\r\n    }\r\n\r\n    // mobile events\r\n    selected() {\r\n        if (this.state !== GRAD_STATE.DISABLED) return;\r\n\r\n\r\n        this.state = GRAD_STATE.ENABLED;\r\n        this.showSubmenu();\r\n        this.addMouseListeners();\r\n        this.addFx();\r\n    }\r\n    deselected() {\r\n        this.firstPointPos = this.secondPointPos = null;\r\n        this.movingFirstPoint = this.movingSecondPoint = false;\r\n        this.movingDone = false;\r\n        this.previewCanvas = null;\r\n        \r\n        \r\n        this.removeMouseListeners();\r\n        this.hideSubmenu();\r\n        this.removeFx();\r\n        \r\n        this.state = GRAD_STATE.DISABLED;\r\n    }\r\n\r\n    showSubmenu() {\r\n        const menuWin = new MiniWindow(t('gradient'), 2, true);\r\n        const body = $(\r\n            `<div>\r\n            <select id=\"gradientFillMode\">\r\n                <option value=\"${FILL_MODE.GLOBAL}\">\r\n                    ${t('fill_mode.global')}\r\n                </option>\r\n                <option value=\"${FILL_MODE.FLOODFILL}\">\r\n                    ${t('fill_mode.floodfill')}\r\n                </option>\r\n            </select><br>\r\n            ${capitalize(t('bayer'))}: <select id=\"gradientMatrixSize\">\r\n                <option value=\"2\">\r\n                    2\r\n                </option>\r\n                <option value=\"4\">\r\n                    4\r\n                </option>\r\n                <option value=\"8\">\r\n                    8\r\n                </option>\r\n            </select><br>\r\n            <label for=\"gradientIsRadial\">${capitalize(t('radial'))}:</label><input type=\"checkbox\" id=\"gradientIsRadial\">\r\n            <label for=\"gradientMagnetMode\">${capitalize(t('magnet_mode'))}:</label><input type=\"checkbox\" id=\"gradientMagnetMode\">\r\n            </div>`\r\n        );\r\n        menuWin.bodyElement.append(body);\r\n        document.body.appendChild(menuWin.element[0]);\r\n\r\n        const fillModeSel = body.find('#gradientFillMode');\r\n        fillModeSel.val(this.options.fillMode.toString());\r\n        fillModeSel.on('change', e => {\r\n            this.options.fillMode = parseInt(fillModeSel.val());\r\n            setLS('grad:fill_mode', fillModeSel.val());\r\n            this.updatePreview();\r\n        });\r\n\r\n        const bayerSizeSel = body.find('#gradientMatrixSize');\r\n        bayerSizeSel.val(this.options.matrixSize.toString());\r\n        bayerSizeSel.on('change', e => {\r\n            this.options.matrixSize = parseInt(bayerSizeSel.val());\r\n            setLS('grad:matrix_size', bayerSizeSel.val());\r\n            this.updatePreview();\r\n        });\r\n\r\n        const isRadialCb = body.find('#gradientIsRadial');\r\n        isRadialCb.prop('checked', this.options.isRadial);\r\n        isRadialCb.on('change', e => {\r\n            this.options.isRadial = isRadialCb.is(':checked');\r\n            setLS('grad:radial', isRadialCb.is(':checked'));\r\n            this.updatePreview();\r\n        });\r\n\r\n        const magnetModeCb = body.find('#gradientMagnetMode');\r\n        magnetModeCb.prop('checked', this.options.magnetMode);\r\n        magnetModeCb.on('change', e => {\r\n            this.options.magnetMode = magnetModeCb.is(':checked');\r\n            setLS('grad:magnet_mode', magnetModeCb.is(':checked'));\r\n            this.updatePreview();\r\n        });\r\n\r\n        this.menuWindow = menuWin;\r\n        if (this.lastMenuPos) {\r\n            menuWin.x = this.lastMenuPos[0];\r\n            menuWin.y = this.lastMenuPos[1];\r\n        } else {\r\n            menuWin.x = window.innerWidth - menuWin.w;\r\n            menuWin.y = window.innerHeight / 2;\r\n        }\r\n\r\n        const originalMoveTo = this.menuWindow.moveTo.bind(this.menuWindow);\r\n        this.menuWindow.moveTo = (x, y) => {\r\n            this.lastMenuPos = [x, y];\r\n            originalMoveTo(x, y);\r\n        }\r\n\r\n        this.menuWindow.on('okClicked', this.menuOkClicked.bind(this));\r\n        this.menuWindow.on('cancelClicked', this.menuCancelClicked.bind(this));\r\n\r\n    }\r\n    hideSubmenu() {\r\n        if(!this.menuWindow) return;\r\n        this.menuWindow.close();\r\n        this.menuWindow = null;\r\n    }\r\n\r\n    menuOkClicked(){\r\n        this.drawRendered();\r\n        this.deselected();\r\n    }\r\n    menuCancelClicked(){\r\n        this.deselected();\r\n    }\r\n\r\n    up() {\r\n        if (mobile) return;\r\n\r\n        switch (this.state) {\r\n            case GRAD_STATE.DISABLED: {\r\n                this.selected();\r\n                break;\r\n            }\r\n            default: {\r\n                this.deselected();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    mousedown(e) {\r\n        camera.disableMove();\r\n        if (this.firstPointPos) {\r\n            const distToFirstPoint = distXY(boardToScreenSpace(this.firstPointPos[0] + 0.5, this.firstPointPos[1] + 0.5), [e.clientX, e.clientY]);\r\n            if (distToFirstPoint < 10) {\r\n                this.movingFirstPoint = true;\r\n                return;\r\n            }\r\n\r\n            const distToSecondPoint = distXY(boardToScreenSpace(this.secondPointPos[0] + 0.5, this.secondPointPos[1] + 0.5), [e.clientX, e.clientY]);\r\n            if (distToSecondPoint < 10) {\r\n                this.movingSecondPoint = true;\r\n                return;\r\n            }\r\n        } else {\r\n            this.firstPointPos = [player.x, player.y];\r\n            this.selectedColor = globals.chunkManager.getChunkPixel(player.x, player.y);\r\n        }\r\n    }\r\n\r\n    mousemove(e) {\r\n        if (e.buttons !== 1 || !this.firstPointPos) return;\r\n        if (this.movingFirstPoint) {\r\n            // avoiding updates on the same pixel\r\n            if (this.firstPointPos?.at(0) === player.x && this.firstPointPos?.at(1) === player.y) return;\r\n\r\n            this.firstPointPos = [player.x, player.y];\r\n            if(this.secondPointPos && this.options.magnetMode){\r\n                this.firstPointPos = doISOSetup(...this.secondPointPos, ...this.firstPointPos)\r\n            }\r\n\r\n            this.selectedColor = globals.chunkManager.getChunkPixel(player.x, player.y);\r\n            this.updatePreview();\r\n        } else if (this.movingSecondPoint || !this.movingDone) {\r\n            if (this.secondPointPos?.at(0) === player.x && this.secondPointPos?.at(1) === player.y) return;\r\n\r\n            let secondPoint = [player.x, player.y];\r\n            if(this.options.magnetMode){\r\n                secondPoint = doISOSetup(...this.firstPointPos, ...secondPoint)\r\n            }\r\n            this.secondPointPos = secondPoint;\r\n            this.updatePreview();\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    mouseup(e) {\r\n        camera.enableMove();\r\n\r\n        if (this.movingFirstPoint || this.movingSecondPoint) {\r\n            this.movingFirstPoint = false;\r\n            this.movingSecondPoint = false;\r\n        }\r\n\r\n        this.movingDone = true;\r\n    }\r\n\r\n    addMouseListeners() {\r\n        globals.eventManager.on('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.on('mousemove', this.mouseListeners.move);\r\n        globals.eventManager.on('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n    removeMouseListeners() {\r\n        globals.eventManager.off('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.off('mousemove', this.mouseListeners.move);\r\n        globals.eventManager.off('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n    addFx() {\r\n        if (this.fx) {\r\n            console.warn('adding fx while it\\'s ON');\r\n            return;\r\n        }\r\n\r\n        const strokeCol = '#a65d49ff';\r\n        const fillCol = 'white';\r\n\r\n\r\n        this.fx = new FX(ctx => {\r\n            if (!this.firstPointPos || !this.secondPointPos) {\r\n                return FX_STATE.FINISHED;\r\n            }\r\n\r\n            //actual gradient drawing\r\n            if (this.previewCanvas) {\r\n                ctx.globalAlpha = 1;\r\n                const screenPos = boardToScreenSpace(this.previewProps.x, this.previewProps.y);\r\n                ctx.drawImage(\r\n                    this.previewCanvas,\r\n                    0, 0, this.previewProps.w, this.previewProps.h,\r\n                    screenPos[0], screenPos[1], this.previewProps.w * camera.zoom, this.previewProps.h * camera.zoom\r\n                );\r\n                ctx.globalAlpha = 1;\r\n            }\r\n\r\n            // everything below are just some visuals\r\n            // for the gradient's dot-to-dot position\r\n\r\n            // white-ish glow\r\n            ctx.shadowBlur = 20;\r\n            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';\r\n            ctx.shadowOffsetX = 0;\r\n            ctx.shadowOffsetY = 0;\r\n\r\n            const firstPos = boardToScreenSpace(this.firstPointPos[0] + 0.5, this.firstPointPos[1] + 0.5);\r\n            const secondPos = boardToScreenSpace(this.secondPointPos[0] + 0.5, this.secondPointPos[1] + 0.5);\r\n\r\n            ctx.strokeStyle = strokeCol;\r\n            ctx.fillStyle = fillCol;\r\n\r\n            ctx.beginPath();\r\n            // dotted line between the points\r\n            ctx.setLineDash([10, 10]);\r\n            ctx.lineWidth = 5;\r\n\r\n            ctx.moveTo(...firstPos);\r\n            ctx.lineTo(...secondPos);\r\n\r\n            ctx.stroke();\r\n            // removing dots to draw solid cirles\r\n            ctx.beginPath();\r\n            ctx.setLineDash([]);\r\n            ctx.moveTo(firstPos[0] + 10, firstPos[1]);\r\n            ctx.arc(...firstPos, 10, 0, Math.PI * 2);\r\n            ctx.moveTo(secondPos[0] + 10, secondPos[1]);\r\n            ctx.arc(...secondPos, 10, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.stroke();\r\n\r\n            ctx.fillStyle = 'black';\r\n            ctx.textAlign = 'center';\r\n            ctx.textBaseline = 'middle';\r\n            ctx.fillText('1', firstPos[0], firstPos[1]);\r\n            ctx.fillText('2', secondPos[0], secondPos[1]);\r\n\r\n            // ctx.restore();\r\n            ctx.shadowBlur = 0;\r\n            ctx.shadowColor = 'transparent';\r\n\r\n\r\n            return FX_STATE.FINISHED;\r\n        });\r\n        addFX(this.fx);\r\n    }\r\n    removeFx() {\r\n        removeFX(this.fx);\r\n        this.fx = null;\r\n    }\r\n\r\n    updatePreview() {\r\n        if(!this.firstPointPos || !this.secondPointPos) return;\r\n\r\n        const deltaX = -(this.firstPointPos[0] - this.secondPointPos[0]);\r\n        const deltaY = -(this.firstPointPos[1] - this.secondPointPos[1]);\r\n\r\n        let maxW, maxH, firstOffX, firstOffY, secondOffX, secondOffY;\r\n        // centering the points to spread the gradient in all directions\r\n        if (this.options.isRadial) {\r\n            maxH = maxW = Math.hypot(deltaX, deltaY) * 2;\r\n            firstOffX = Math.floor(maxW / 2);\r\n            firstOffY = Math.floor(maxH / 2);\r\n        } else {\r\n            maxW = maxH = Math.max(Math.abs(deltaX) * 2, Math.abs(deltaY) * 2, this.options.globalMaxRadius * 2);\r\n            firstOffX = Math.floor((maxW - deltaX) / 2);\r\n            firstOffY = Math.floor((maxH - deltaY) / 2);\r\n        }\r\n        secondOffX = firstOffX + deltaX;\r\n        secondOffY = firstOffY + deltaY;\r\n\r\n        this.previewProps.x = this.firstPointPos[0] - firstOffX;\r\n        this.previewProps.y = this.firstPointPos[1] - firstOffY;\r\n        this.previewProps.w = maxW;\r\n        this.previewProps.h = maxH;\r\n\r\n        const firstColHex = hexPalette[player.color] ?? '#00000000';\r\n        const secondColHex = hexPalette[player.secondCol] ?? '#00000000';\r\n\r\n        const generatedGrad = generateGradient(\r\n            maxW, maxH,\r\n            firstOffX, firstOffY,\r\n            secondOffX, secondOffY,\r\n            firstColHex, secondColHex\r\n        );\r\n\r\n        const firstColRgb = allColors[player.color] ?? null;\r\n        const secondColRgb = allColors[player.secondCol] ?? null;\r\n\r\n        const ditheredGrad = ditherGradient(\r\n            generatedGrad.getContext('2d'),\r\n            firstColRgb,\r\n            secondColRgb,\r\n            this.options.matrixSize,\r\n            {\r\n                ...this.options,\r\n                p1: [firstOffX, firstOffY],\r\n                p2: [secondOffX, secondOffY],\r\n                originX: this.previewProps.x,\r\n                originY: this.previewProps.y\r\n            }\r\n        );\r\n\r\n        // finally, we need to mask this canvas to draw only on the same color\r\n        const boardDump = globals.chunkManager.dumpZone(\r\n            this.previewProps.x,\r\n            this.previewProps.y,\r\n            this.previewProps.w,\r\n            this.previewProps.h\r\n        );\r\n\r\n        const dumpCtx = boardDump.getContext('2d');\r\n        selectColor(dumpCtx,\r\n            allColors[this.selectedColor],\r\n            firstOffX, firstOffY,\r\n            this.options.fillMode);\r\n\r\n        dumpCtx.globalCompositeOperation = 'source-in';\r\n        dumpCtx.drawImage(ditheredGrad, 0, 0);\r\n\r\n        this.previewCanvas = boardDump;\r\n    }\r\n\r\n    drawRendered(){\r\n        globals.toolManager.tools.paste.startDraw(this.previewCanvas, this.previewProps.x, this.previewProps.y);\r\n    }\r\n}\r\nconst gradient = new Gradient('gradient', 'KeyB', wandIcon);\r\nexport default gradient;\r\n","import camera from '../camera';\r\nimport { chunkSize } from '../config';\r\nimport { addFX, FX, removeFX } from '../fxcanvas';\r\nimport Tool from '../Tool';\r\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\r\nimport { getOrDefault, setLS } from '../utils/localStorage';\r\nimport { mapRange } from '../utils/math';\r\n\r\n\r\nclass Grid extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.state = 0;\r\n        this.fx = null;\r\n\r\n        this.pattern = null;\r\n\r\n        camera.on('zoom', () => {\r\n            if (this.state == 1) {\r\n                this.tryRender();\r\n            }\r\n        });\r\n\r\n        this.on('down', this.pressed.bind(this));\r\n        if (JSON.parse(getOrDefault('enableGrid', false))) {\r\n            this.show();\r\n        }\r\n    }\r\n\r\n    pressed(e) {\r\n        if (e.repeat) return;\r\n        this.toggle();\r\n    }\r\n\r\n    /**@param {CanvasRenderingContext2D} ctx*/\r\n    drawGrid(ctx) {\r\n        let [x, y] = screenToBoardSpace(0, 0), [clientX, clientY] = boardToScreenSpace(x, y);\r\n\r\n        let { width, height } = ctx.canvas;\r\n        const zoom = camera.zoom;\r\n\r\n\r\n        ctx.fillStyle = 'rgb(127,127,127)';\r\n\r\n        // make grid fade out from zoom 16 to 5 (lower than 5 is invisible)\r\n        const calculatedAlpha = zoom > 16 ? 0.5 : mapRange(zoom, 24, 5, 0.5, 0);\r\n        ctx.globalAlpha = calculatedAlpha;\r\n\r\n        let thickInterval;\r\n        if (chunkSize % 16 == 0) thickInterval = 16;\r\n        else if (chunkSize % 10 == 0) thickInterval = 10;\r\n        else thickInterval = null;\r\n\r\n        // finally, i decided to disable this feature\r\n        thickInterval = null;\r\n\r\n        let wid = 1;\r\n\r\n        // kostyl\r\n        x--; y--;\r\n\r\n        // pixels lines\r\n        for (; clientX < width; clientX += zoom) {\r\n            x++;\r\n            if (x % thickInterval == 0) wid = 1;\r\n            else wid = 1;\r\n\r\n            if (x % chunkSize == 0) wid = 1;\r\n\r\n            ctx.fillRect(clientX | 0, 0, wid, height);\r\n        }\r\n\r\n        for (; clientY < height; clientY += zoom) {\r\n            y++;\r\n            if (y % thickInterval == 0) wid = 1;\r\n            else wid = 1;\r\n\r\n            if (y % chunkSize == 0) wid = 1;\r\n\r\n            ctx.fillRect(0, clientY | 0, width, wid);\r\n        }\r\n\r\n        ctx.globalAlpha = 1;\r\n    }\r\n\r\n    tryRender() {\r\n        if (!this.fx || this.fx.removed) {\r\n            this.fx = new FX(this.render.bind(this));\r\n            addFX(this.fx, 2);\r\n        }\r\n    }\r\n\r\n    toggle() {\r\n        if (this.state == 0) this.show();\r\n        else this.hide();\r\n        setLS('enableGrid', (!!this.state).toString());\r\n    }\r\n\r\n    show() {\r\n        this.state = 1;\r\n        this.tryRender();\r\n    }\r\n\r\n    hide() {\r\n        this.state = 0;\r\n        this.fx && removeFX(this.fx);\r\n    }\r\n\r\n    render(ctx) {\r\n        if (camera.zoom <= 5) return 1;\r\n\r\n        this.drawGrid(ctx);\r\n    }\r\n}\r\nconst grid = new Grid('grid', 'KeyG');\r\nexport default grid;","\r\nimport clicker from './clicker';\r\nimport mover from './mover';\r\nimport floodfill from './floodfill';\r\nimport { altPipette, pipette } from './pipettes';\r\nimport line from './line';\r\nimport { colorDec, colorInc } from './nextColor';\r\nimport colorSwap from './colorSwap';\r\nimport { allOpac, chatOpac, menuOpac } from './uiToggles';\r\nimport ctrlZ from './ctrlZ';\r\nimport { altProtector, protector } from './protectors';\r\nimport grid from './grid';\r\nimport copy from './copy';\r\nimport paste from './paste';\r\nimport cordAdd from './sendCoords';\r\nimport { templateOp1, templateOp2 } from './templateToggles';\r\nimport square from './square';\r\nimport { decBrush, incBrush } from './brushSize';\r\nimport pixelInfo from './pixelInfo';\r\nimport text from './text';\r\nimport resetColors from './resetColors';\r\nimport wand from './wand';\r\nimport colorador from './mnkbm';\r\nimport paletteSwapper from './paletteSwapper';\r\nimport gradient from './gradient';\r\n\r\n\r\n\r\n\r\nexport default {\r\n    clicker,\r\n    mover,\r\n    floodfill,\r\n    pipette, altPipette,\r\n    line,\r\n    colorInc, colorDec,\r\n    colorSwap,\r\n    chatOpac, menuOpac, allOpac,\r\n    ctrlZ,\r\n    protector, altProtector,\r\n    grid,\r\n    copy,\r\n    paste,\r\n    cordAdd,\r\n    templateOp1, templateOp2,\r\n    square,\r\n    incBrush, decBrush,\r\n    pixelInfo,\r\n    text,\r\n    resetColors,\r\n    wand,\r\n    colorador,\r\n    paletteSwapper,\r\n    gradient\r\n}\r\n","import { onToolManager, getColByCord, renderFX, checkBounds, getPixel } from \"./toolUtils\";\r\nimport lineIcon from '../../img/toolIcons/line.png';\r\nimport camera from '../camera';\r\nimport { boardWidth, hexPalette } from '../config';\r\nimport { ROLE } from '../constants';\r\nimport { addFX, FX, removeFX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport me from '../me';\r\nimport player, { placePixel } from '../player';\r\nimport Tool from '../Tool';\r\nimport { boardToScreenSpace } from '../utils/conversions';\r\nimport { getOrDefault } from '../utils/localStorage';\r\nimport shapes from '../utils/shapes';\r\n\r\n\r\nclass Line extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.drawLength = JSON.parse(getOrDefault('drawLineLen', false));;\r\n\r\n        onToolManager(() => {\r\n            this.handlers();\r\n        });\r\n    }\r\n\r\n    handlers() {\r\n        let startCoords, endCoords, lastCoords = [], fx, isDown = false, line, startColor1, startColor2, startCircleSize;\r\n\r\n        function down(e) {\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            startCoords = [player.x, player.y];\r\n\r\n            [startColor1, startColor2] = [player.color, player.secondCol];\r\n\r\n            startCircleSize = 1;\r\n            if (player.brushSize !== 1) {\r\n                startCircleSize = globals.renderer.preRendered.brush.circle.length;\r\n            }\r\n\r\n            move(e);\r\n        }\r\n\r\n        function move(e) {\r\n            if (!isDown || !startCoords) return;\r\n            if (e.gesture) {\r\n                isDown = false;\r\n                return startCoords = null;\r\n            };\r\n\r\n            endCoords = [player.x, player.y];\r\n\r\n            if (player.color === -1 && player.secondCol === -1) {\r\n                fx && removeFX(fx);\r\n                return;\r\n            }\r\n            if (endCoords[0] != lastCoords[0] || endCoords[1] != lastCoords[1]) {\r\n                lastCoords = endCoords;\r\n\r\n                const line = buildLine(...startCoords, ...endCoords);\r\n\r\n                fx && removeFX(fx);\r\n                fx = new FX((ctx) => {\r\n                    ctx.globalAlpha = .5;\r\n\r\n                    // draw line pixel by pixel\r\n                    line.forEach(([x, y]) => {\r\n                        const color = getColByCord(x, y);\r\n                        ctx.fillStyle = hexPalette[color];\r\n\r\n                        let [screenX, screenY] = boardToScreenSpace(x, y);\r\n                        ctx.fillRect(screenX, screenY, camera.zoom, camera.zoom);\r\n                    });\r\n\r\n                    // draw (non pixelated) black line over the line\r\n                    ctx.strokeStyle = '#000000';\r\n                    ctx.lineWidth = camera.zoom / 5;\r\n\r\n                    const startScreen = boardToScreenSpace(...line[0]);\r\n                    const endScreen = boardToScreenSpace(...line[line.length - 1]);\r\n\r\n                    ctx.beginPath();\r\n                    ctx.lineCap = 'round';\r\n                    ctx.moveTo(...startScreen.map(z => z += camera.zoom / 2));\r\n                    ctx.lineTo(...endScreen.map(z => z += camera.zoom / 2));\r\n\r\n                    // draw line length text\r\n                    function angle(cx, cy, ex, ey) {\r\n                        var dy = ey - cy;\r\n                        var dx = ex - cx;\r\n                        var theta = Math.atan2(dy, dx); // range (-PI, PI]\r\n                        theta *= 180 / Math.PI; // rads to degs, range (-180, 180]\r\n\r\n                        //if (theta < 0) theta = 360 + theta; // range [0, 360)\r\n                        return theta;\r\n                    }\r\n\r\n                    function toRadians(angle) {\r\n                        return angle * (Math.PI / 180);\r\n                    }\r\n\r\n                    if (this.drawLength && line.length > 1) {\r\n                        let [startPosX, startPosY] = startScreen;\r\n                        let [endPosX, endPosY] = endScreen;\r\n\r\n                        let minX = Math.min(startPosX, endPosX);\r\n                        let minY = Math.min(startPosY, endPosY);\r\n                        let maxX = Math.max(startPosX, endPosX);\r\n                        let maxY = Math.max(startPosY, endPosY);\r\n\r\n                        let [midPosX, midPosY] = [maxX - Math.abs(maxX - minX) / 2, maxY - Math.abs(maxY - minY) / 2];\r\n\r\n                        // append half-pixel offset to center text in the middle\r\n                        midPosX += camera.zoom * 0.5;\r\n                        midPosY += camera.zoom * 0.5;\r\n\r\n                        let lineAngle = angle(startPosX, startPosY, endPosX, endPosY);\r\n                        if (lineAngle > 90) {\r\n                            lineAngle -= 180;\r\n                        } else if (lineAngle < -90) {\r\n                            lineAngle += 180;\r\n                        }\r\n\r\n                        let lineRads = toRadians(lineAngle);\r\n                        let offsetX = 40 * Math.sin(lineRads);\r\n                        let offsetY = 40 * Math.cos(lineRads);\r\n\r\n                        midPosX += offsetX;\r\n                        midPosY -= offsetY;\r\n\r\n\r\n\r\n                        ctx.save();\r\n                        ctx.globalAlpha = .7;\r\n\r\n                        const fontHei = 20; //camera.zoom / 1.5;\r\n                        ctx.font = fontHei + 'px sans-serif';\r\n                        ctx.fillStyle = 'black';\r\n                        ctx.strokeStyle = 'white';\r\n\r\n                        ctx.textAlign = 'center';\r\n                        ctx.textBaseline = 'middle';\r\n                        ctx.lineWidth = fontHei / 6;\r\n\r\n                        const text = line.length;\r\n                        const [x, y] = [midPosX, midPosY];\r\n\r\n                        ctx.strokeText(text, x, y);\r\n                        ctx.fillText(text, x, y);\r\n\r\n                        ctx.restore();\r\n                    }\r\n\r\n                    ctx.stroke();\r\n\r\n                    ctx.globalAlpha = 1;\r\n\r\n                    return 1;\r\n                });\r\n                addFX(fx);\r\n            }\r\n        }\r\n\r\n        function buildLine(x1, y1, x2, y2) {\r\n            let circle = [[0, 0]];\r\n            if (player.brushSize !== 1) {\r\n                circle = globals.renderer.preRendered.brush.circle;\r\n            }\r\n\r\n            const w = boardWidth;\r\n\r\n            // to not repeat already added pixels\r\n            const placed = new Set();\r\n\r\n            const bruhLinePixels = [];\r\n            const linePixels = shapes.line(x1, y1, x2, y2);\r\n\r\n            // starting from the end and then\r\n            // reversing brushed array will\r\n            // make pixels rendering looking more brush-like\r\n            for (let i = linePixels.length - 1; i >= 0; i--) {\r\n                const [x, y] = linePixels[i];\r\n                circle.forEach(([offX, offY]) => {\r\n                    const absX = x + offX;\r\n                    const absY = y + offY;\r\n\r\n                    const encoded = absX + absY * w;\r\n\r\n                    if (placed.has(encoded)) return;\r\n                    placed.add((encoded));\r\n\r\n                    bruhLinePixels.push([absX, absY]);\r\n                });\r\n            }\r\n\r\n            return bruhLinePixels.reverse();\r\n        }\r\n\r\n        function up() {\r\n            this.off('tick', tick);\r\n\r\n            if (!isDown || !startCoords) return;\r\n            isDown = false;\r\n\r\n            fx && fx.remove();\r\n\r\n            if (!endCoords) endCoords = [player.x, player.y];\r\n\r\n            line = buildLine(...startCoords, ...endCoords);\r\n\r\n            if (line.length > 150 && me.role < ROLE.TRUSTED) {\r\n                return;\r\n            }\r\n\r\n            startCoords = null;\r\n            endCoords = null;\r\n\r\n            renderFX();\r\n            this.on('tick', tick);\r\n        }\r\n\r\n        function tick() {\r\n            if (player.color === -1 && player.secondCol === -1) {\r\n                // assume player cancelled line\r\n                line = null;\r\n            }\r\n\r\n            let placed = 0;\r\n            while (true) {\r\n                if (!line || !line.length) {\r\n                    this.off('tick', tick);\r\n                    return;\r\n                }\r\n\r\n                const [x, y] = line.pop();\r\n                const col = getColByCord(x, y, startColor1, startColor2);\r\n\r\n                if (col === undefined || col === -1) return this.off('tick', tick);\r\n                if (!checkBounds(x, y) || getPixel(x, y) === col) continue;\r\n\r\n                if (!player.bucket.spend(1)) return line.push([x, y]);\r\n\r\n                placePixel(x, y, col);\r\n                placed++;\r\n                if (placed >= startCircleSize / 2) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        down = down.bind(this);\r\n        move = move.bind(this);\r\n        up = up.bind(this);\r\n\r\n        tick = tick.bind(this);\r\n\r\n        this.on('down', down);\r\n        // TODO maybe it's too many listeners\r\n        // so it'd be good to make some sort of local signal\r\n        // that there was gesture (this listener is only for e.gesture to reset start coords)\r\n        globals.toolManager.on('move', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst line = new Line('line', 'ShiftLeft', lineIcon);\r\nexport default line;","import { mobile } from \"./toolUtils\";\r\nimport disabledColorSvg from '../../img/disabled-color.svg';\r\nimport disableCur from '../../img/toolIcons/disable-cur.png';\r\nimport disableIcon from '../../img/toolIcons/disable.png';\r\nimport { allColors, resolveWhenConfigDownloaded } from '../config';\r\nimport { addFX, FX, FX_STATE } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport player from '../player';\r\nimport template from '../template';\r\nimport Tool from '../Tool';\r\nimport { translate as t } from '../translate';\r\nimport { mainCanvas } from '../ui/elements';\r\nimport { getPaletteColorId } from '../utils/color';\r\nimport { screenToBoardSpace } from '../utils/conversions';\r\nimport { getOrDefault, setLS } from '../utils/localStorage';\r\nimport { isClick } from '../utils/misc';\r\nimport { generateShader, MAX_TEX_SIZE } from '../utils/webGL';\r\n\r\n\r\nexport const COLORADOR_STATE = {\r\n    DISABLED: 0,\r\n    SELECTING: 1\r\n};\r\nclass TemplateColorador extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.colorsWhitelist = [];\r\n        resolveWhenConfigDownloaded().then(() => {\r\n            this.colorsWhitelist = JSON.parse(getOrDefault('coloradorColors', '[]', true));\r\n            if (this.colorsWhitelist.length) {\r\n                addFX(new FX(() => {\r\n                    if (!template.templateImg?.width) return FX_STATE.IN_PROCESS;\r\n\r\n                    try {\r\n                        this.update();\r\n                    } catch (error) { }\r\n\r\n                    return FX_STATE.REMOVED;\r\n                }));\r\n            }\r\n        });\r\n\r\n        this.state = COLORADOR_STATE.DISABLED;\r\n\r\n        this.on('up', this.up.bind(this));\r\n        this.on('selected', this.selected.bind(this));\r\n        this.on('deselected', this.deselected.bind(this));\r\n\r\n        this.mouseListeners = {\r\n            down: this.mousedown.bind(this),\r\n            up: this.mouseup.bind(this)\r\n        };\r\n\r\n        // needed for the reference\r\n        this.origTemplateCanvas = null;\r\n        this.origTemplateCtx = null;\r\n        // the one that is monkeypatched into the Template\r\n        this.templateCanvas = null;\r\n        this.templateUpdated = false;\r\n\r\n        this.glData = {\r\n            gl: null,\r\n            imageLoc: null,\r\n            colorsWhitelistLoc: null,\r\n            screenSizeLoc: null,\r\n            disabledOpacityLoc: null,\r\n            texture: null,\r\n        };\r\n    }\r\n\r\n    selected() {\r\n        this.startSelecting();\r\n    }\r\n    deselected() {\r\n        this.stopSelecting();\r\n    }\r\n\r\n    up() {\r\n        switch (this.state) {\r\n            case COLORADOR_STATE.DISABLED: {\r\n                this.startSelecting();\r\n                break;\r\n            }\r\n            case COLORADOR_STATE.SELECTING: {\r\n                this.stopSelecting();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    mmb(colorId) {\r\n        this.toggleWhitelistColor(allColors[colorId]);\r\n    }\r\n\r\n    mousedown(e) {\r\n        this.downPos = [e.clientX, e.clientY];\r\n    }\r\n\r\n    mouseup(e) {\r\n        try {\r\n            if (!this.downPos) return;\r\n\r\n            const upPos = [e.clientX, e.clientY];\r\n            if (!isClick(this.downPos, upPos)) {\r\n                return;\r\n            }\r\n\r\n            this.regenerateTemplateIfNeeded();\r\n\r\n            const boardPos = screenToBoardSpace(...upPos);\r\n\r\n            if (this.isOutsideTemplate(...boardPos)) {\r\n                this.colorsWhitelist.length = 0;\r\n                this.update();\r\n                return;\r\n            }\r\n\r\n            const templateCol = this.getTemplateColor(...boardPos);\r\n            if (!templateCol) return;\r\n\r\n            const templateColId = getPaletteColorId(templateCol);\r\n            if (templateColId === -1) {\r\n                toastr.warning(t('color_not_in_palette'));\r\n                return;\r\n            }\r\n\r\n            this.toggleWhitelistColor(templateCol);\r\n        } finally {\r\n            if (mobile) {\r\n                this.startSelecting();\r\n            }\r\n        }\r\n    }\r\n    isOutsideTemplate(boardX, boardY) {\r\n        const div = template.isPatterns ? 7 : 1;\r\n        const templateW = template.templateImg.width / div;\r\n        const templateH = template.templateImg.height / div;\r\n\r\n        return boardX < template.x || boardY < template.y ||\r\n            boardX >= template.x + templateW ||\r\n            boardY >= template.y + templateH;\r\n    }\r\n\r\n\r\n    getTemplateColor(boardX, boardY) {\r\n        const temCtx = this.origTemplateCtx;\r\n\r\n        const temX = boardX - template.x;\r\n        const temY = boardY - template.y;\r\n\r\n        let color = null;\r\n        if (!template.isPatterns) {\r\n            const temColor = temCtx.getImageData(temX, temY, 1, 1).data;\r\n            // no color if it is opaque\r\n            if (temColor[3] === 0) {\r\n                return null;\r\n            }\r\n            color = temColor.slice(0, 3);\r\n        } else {\r\n            const multedTemX = temX * 7;\r\n            const multedTemY = temY * 7;\r\n\r\n            // finding the color in the 7x7 pattern cell\r\n            toBreak: for (let x = 0; x < 7; x++) {\r\n                for (let y = 0; y < 7; y++) {\r\n                    const curX = multedTemX + x;\r\n                    const curY = multedTemY + y;\r\n\r\n                    const curColor = temCtx.getImageData(curX, curY, 1, 1).data;\r\n                    // alpha\r\n                    if (curColor[3] !== 0) {\r\n                        color = curColor.slice(0, 3);\r\n                        break toBreak;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return color;\r\n\r\n    }\r\n\r\n    toggleWhitelistColor(targetCol) {\r\n        const whitelistColId = this.colorsWhitelist.findIndex(rgb => rgb[0] === targetCol[0] && rgb[1] === targetCol[1] && rgb[2] === targetCol[2]);\r\n        if (whitelistColId !== -1) {\r\n            this.removeWhitelistColor(whitelistColId);\r\n        } else {\r\n            this.addWhitelistColor(targetCol);\r\n        }\r\n    }\r\n    addWhitelistColor(rgb) {\r\n        this.colorsWhitelist.push([...rgb]);\r\n        this.update();\r\n    }\r\n    removeWhitelistColor(idx) {\r\n        this.colorsWhitelist.splice(idx, 1);\r\n        this.update();\r\n    }\r\n\r\n    updateUIPalette() {\r\n        $('.paletteColor>img.disabledClr').remove();\r\n\r\n        if (!this.colorsWhitelist.length) return;\r\n\r\n        $(`.paletteColor`).append(`<img src=\"${disabledColorSvg}\" class=\"disabledClr\">`);\r\n\r\n        for (const rgb of this.colorsWhitelist) {\r\n            const id = getPaletteColorId(rgb);\r\n            if (id === -1) {\r\n                console.warn('color', rgb, 'not found in the palette');\r\n                continue;\r\n            }\r\n\r\n            $(`#col${id}>img.disabledClr`).remove();\r\n        }\r\n    }\r\n\r\n    update() {\r\n        setLS('coloradorColors', JSON.stringify(this.colorsWhitelist), true);\r\n\r\n        this.regenerateTemplateIfNeeded();\r\n\r\n        if (this.colorsWhitelist.length > 0) {\r\n            this.render(this.state === COLORADOR_STATE.SELECTING);\r\n\r\n            this.patchTemplate();\r\n        } else {\r\n            this.unpatchTemplate();\r\n        }\r\n\r\n        this.updateUIPalette();\r\n    }\r\n\r\n    regenerateTemplateIfNeeded() {\r\n        if (!this.origTemplateCanvas || !this.templateCanvas || this.templateCanvas !== template.templateImg) {\r\n            this.templateUpdated = true;\r\n            this.glData.gl = null;\r\n\r\n            const templateImg = template.templateImg;\r\n\r\n            const origCanv = this.origTemplateCanvas = document.createElement('canvas');\r\n            const templCanv = this.templateCanvas = document.createElement('canvas');\r\n\r\n            origCanv.width = templCanv.width = templateImg.width;\r\n            origCanv.height = templCanv.height = templateImg.height;\r\n\r\n            this.origTemplateCtx = origCanv.getContext('2d');\r\n            this.origTemplateCtx.drawImage(templateImg, 0, 0);\r\n        }\r\n    }\r\n\r\n    startSelecting() {\r\n        this.state = COLORADOR_STATE.SELECTING;\r\n\r\n        this.changeCursor(1);\r\n        player.suspendColors();\r\n\r\n        this.clearListeners();\r\n\r\n        globals.eventManager.on('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.on('mouseup', this.mouseListeners.up);\r\n\r\n        this.render(true);\r\n    }\r\n\r\n    stopSelecting() {\r\n        this.state = COLORADOR_STATE.DISABLED;\r\n\r\n        this.changeCursor(0);\r\n        player.restoreColors();\r\n\r\n        this.clearListeners();\r\n\r\n        this.render(false);\r\n    }\r\n\r\n    clearListeners() {\r\n        globals.eventManager.off('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.off('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n\r\n\r\n    render(drawDisabled) {\r\n        if (!this.origTemplateCanvas) {\r\n            this.regenerateTemplateIfNeeded();\r\n        }\r\n\r\n        const w = this.origTemplateCanvas.width;\r\n        const h = this.origTemplateCanvas.height;\r\n\r\n        let cpuFallback = (w > MAX_TEX_SIZE || h > MAX_TEX_SIZE);\r\n\r\n        if (!cpuFallback) {\r\n            this.generateShader();\r\n            this.renderShader(drawDisabled);\r\n        } else {\r\n            this.glData.gl = null;\r\n            this.glData.texture = null;\r\n\r\n            console.log('colorador cpu fallback');\r\n            this.renderCpu(drawDisabled);\r\n        }\r\n    }\r\n\r\n    createWhitelistTexture(gl, colors) {\r\n        const data = new Uint8Array(colors.flat());\r\n        const tex = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, colors.length, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, data);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        return tex;\r\n    }\r\n\r\n    renderShader(drawDisabled) {\r\n        if (!this.glData.gl) {\r\n            this.regenerateTemplateIfNeeded();\r\n            this.generateShader();\r\n        }\r\n\r\n        if (!this.colorsWhitelist.length) return;\r\n\r\n        const gl = this.glData.gl;\r\n\r\n        gl.viewport(0, 0, this.templateCanvas.width, this.templateCanvas.height);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.glData.texture);\r\n        if (this.templateUpdated) {\r\n            this.templateUpdated = false;\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,\r\n                gl.UNSIGNED_BYTE, this.origTemplateCanvas);\r\n        }\r\n        gl.uniform1i(this.glData.imageLoc, 0);\r\n\r\n        gl.activeTexture(gl.TEXTURE1);\r\n        const whitelistTexture = this.createWhitelistTexture(gl, this.colorsWhitelist);\r\n        gl.bindTexture(gl.TEXTURE_2D, whitelistTexture);\r\n        gl.uniform1i(this.glData.colorsWhitelistLoc, 1);\r\n\r\n        gl.uniform2f(this.glData.screenSizeLoc, mainCanvas.width, mainCanvas.height);\r\n\r\n        const disabledOpacity = drawDisabled ? 0.1 : 0;\r\n        gl.uniform1f(this.glData.disabledOpacityLoc, disabledOpacity);\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    }\r\n    generateShader() {\r\n        if (!this.colorsWhitelist.length) return;\r\n\r\n        const fragmentShader = `\r\n        #define COLORS_SIZE ${this.colorsWhitelist.length}\r\n        precision mediump float;\r\n        uniform sampler2D u_image;\r\n        uniform sampler2D u_colorsWhitelist;\r\n        uniform vec2 u_screenSize;\r\n        uniform float u_disabledOpacity;\r\n        varying vec2 v_texCoord;\r\n\r\n        bool colorMatch(vec3 a, vec3 b) {\r\n            return distance(a, b) < 0.01;\r\n        }\r\n\r\n        void main() {\r\n            vec4 color = texture2D(u_image, v_texCoord);\r\n            \r\n            if(color.a < 0.001){\r\n                gl_FragColor = color;\r\n                return;\r\n            }\r\n\r\n            for(int i = 0; i < COLORS_SIZE; i++){\r\n                vec3 wl = texture2D(u_colorsWhitelist, vec2((float(i) + 0.5) / float(COLORS_SIZE), 0.5)).rgb;\r\n                if(colorMatch(wl, color.rgb)){\r\n                    gl_FragColor = color;\r\n                    return;\r\n                }\r\n            }\r\n\r\n            \r\n            gl_FragColor = vec4(0.0, 0.0, 0.0, u_disabledOpacity);\r\n        }\r\n        `;\r\n\r\n        let existingGl = this.glData.gl;\r\n        const { gl, program, texture } = generateShader(existingGl ?? this.templateCanvas, fragmentShader, existingGl ? false : true);\r\n\r\n        this.glData.imageLoc = gl.getUniformLocation(program, \"u_image\");\r\n        this.glData.colorsWhitelistLoc = gl.getUniformLocation(program, \"u_colorsWhitelist\");\r\n        this.glData.screenSizeLoc = gl.getUniformLocation(program, \"u_screenSize\");\r\n        this.glData.disabledOpacityLoc = gl.getUniformLocation(program, \"u_disabledOpacity\");\r\n\r\n        this.glData.gl = gl;\r\n        if (texture) {\r\n            this.glData.texture = texture;\r\n        }\r\n    }\r\n\r\n    renderCpu(drawDisabled) {\r\n        const REPLACE_ALPHA = drawDisabled ? 15 : 0;\r\n\r\n        const ctx = this.origTemplateCtx;\r\n        const imgData = ctx.getImageData(0, 0, this.origTemplateCanvas.width, this.origTemplateCanvas.height);\r\n        const data = imgData.data;\r\n\r\n        const key = rgb => (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\r\n        const whitelistSet = new Set(this.colorsWhitelist.map(key));\r\n\r\n        const n = data.length;\r\n        for (let i = 0; i < n; i += 4) {\r\n            if (data[i + 3] === 0) continue;\r\n            const k = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];\r\n            if (!whitelistSet.has(k)) {\r\n                data[i] = data[i + 1] = data[i + 2] = 0;\r\n                data[i + 3] = REPLACE_ALPHA;\r\n            }\r\n        }\r\n\r\n        this.templateCanvas.getContext('2d').putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    patchTemplate() {\r\n        template.templateImg = this.templateCanvas;\r\n        globals.fxRenderer.needRender = true;\r\n    }\r\n    unpatchTemplate() {\r\n        template.templateImg = this.origTemplateCanvas;\r\n        globals.fxRenderer.needRender = true;\r\n    }\r\n\r\n    changeCursor(cursorState) {\r\n        if (cursorState === 1) {\r\n            document.body.style.cursor = `url('${disableCur}') 0 0, auto`;\r\n        } else {\r\n            document.body.style.cursor = '';\r\n        }\r\n    }\r\n\r\n}\r\nconst colorador = new TemplateColorador('colorador', 'KeyD', disableIcon);\r\nexport default colorador;","import { mobile, onToolManager, getCurCol, renderFX } from \"./toolUtils\";\r\nimport pixelInfo from './pixelInfo';\r\nimport moveIcon from '../../img/toolIcons/move.png';\r\nimport camera from '../camera';\r\nimport { hexPalette } from '../config';\r\nimport { addFX, FX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\nimport { changeSelector } from '../ui/elements';\r\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\r\n\r\n\r\nclass Mover extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n\r\n        this.downPos = [0, 0];\r\n\r\n        // time when \"down\" was called\r\n        this.downTime = 0;\r\n\r\n        this.lastPos = [0, 0];\r\n        this.lastPlayerPos = [0, 0];\r\n        this.antijitterDownPos = [0, 0];\r\n\r\n        if (!mobile) {\r\n            this.fx = new FX(this.renderCursor);\r\n\r\n            addFX(this.fx, 2);\r\n        }\r\n    }\r\n\r\n    handlers() {\r\n        // \r\n        onToolManager(() => {\r\n            this.on('down', this.down);\r\n            this.on('up', this.up);\r\n            // bind to toolManager for handling not only on canvas\r\n            globals.toolManager.on('move', this.move.bind(this));\r\n            this.on('leave', this.up);\r\n        });\r\n    }\r\n\r\n    renderCursor(ctx) {\r\n        const zoom = camera.zoom;\r\n\r\n        const color = getCurCol();\r\n\r\n        if (~color && zoom > 1) {\r\n            if (player.brushSize == 1) {\r\n                let [x, y] = boardToScreenSpace(player.x, player.y);\r\n                ctx.strokeStyle = hexPalette[color];\r\n                //ctx.fillStyle = hexPalette[player.color];\r\n                ctx.lineWidth = zoom / 5;\r\n\r\n                let w, h;\r\n                let halfLineWid = ctx.lineWidth / 2;\r\n\r\n                x += halfLineWid;\r\n                y += halfLineWid;\r\n\r\n                w = zoom - ctx.lineWidth;\r\n                h = w;\r\n\r\n                //ctx.fillRect(x, y, zoom, zoom);\r\n                ctx.strokeRect(x, y, w + 1, h + 1);\r\n\r\n                //renderFX();\r\n            } else {\r\n                let offX = 0.5, offY = 0.5;\r\n                if (player.brushSize % 2 === 0) {\r\n                    offX = 1;\r\n                    offY = 1;\r\n                }\r\n                const center = player.brushSize / 2;\r\n                const [x, y] = boardToScreenSpace(player.x - center + offX, player.y - center + offY);\r\n                ctx.drawImage(globals.renderer.preRendered.brush.canvas, x, y);\r\n            }\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    down(e) {\r\n        if (e.ctrlKey) return;\r\n\r\n        this.mousedown = true;\r\n\r\n        // little workaround to keep any ui text\r\n        // unselected while canvas moves\r\n        // guess it's inefficient\r\n        changeSelector('#ui>div>*', { 'pointer-events': 'none' });\r\n\r\n        this.downPos = this.lastPos = [e.clientX, e.clientY];\r\n        this.antijitterDownPos = screenToBoardSpace(e.clientX, e.clientY);\r\n\r\n        this.downTime = Date.now();\r\n    }\r\n    up(e) {\r\n        if (e.ctrlKey) return;\r\n\r\n        this.mousedown = false;\r\n        changeSelector('#ui>div>*', { 'pointer-events': 'all' });\r\n        this.antijitterDownPos = null;\r\n\r\n        // long tap to get pixel info\r\n        if (mobile && this.moveThreshold() && !e.gesture) {\r\n            const ela = Date.now() - this.downTime;\r\n            if (ela < 1000) return;\r\n\r\n            pixelInfo.emit('up');\r\n        }\r\n    }\r\n\r\n    move(e) {\r\n        // for template mover\r\n        if (e.ctrlKey) return;\r\n\r\n        if (this.lastPlayerPos[0] != player.x ||\r\n            this.lastPlayerPos[1] != player.y ||\r\n            this.mousedown) {\r\n            renderFX();\r\n        }\r\n\r\n        \r\n        this.lastPlayerPos = [player.x, player.y];\r\n        \r\n        if (!this.mousedown) return;\r\n\r\n        this.lastPos = [e.clientX, e.clientY];\r\n        if (!mobile) {\r\n\r\n            if (this.moveThreshold())\r\n                return;\r\n        }\r\n\r\n        // now works without pixel ratio, i'll keep it here if not\r\n        camera.moveBy(-e.movementX / camera.zoom /* / devicePixelRatio */, -e.movementY / camera.zoom /* / devicePixelRatio */);\r\n    }\r\n\r\n    moveThreshold() {\r\n        return (Math.abs(this.downPos[0] - this.lastPos[0]) < 5 &&\r\n            Math.abs(this.downPos[1] - this.lastPos[1]) < 5);\r\n    }\r\n}\r\nconst mover = new Mover('mover', 'LMB', moveIcon);\r\nexport default mover;","import { allColors, currentPalette } from '../config';\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\n\r\n\r\nexport const colorDec = new Tool('left color', 'KeyA');\r\ncolorDec.on('down', function () {\r\n    const minIndex = currentPalette?.slice[0] ?? 0;\r\n    const maxIndex = currentPalette?.slice[1] ?? allColors.length;\r\n\r\n    let color = player.color - 1;\r\n    if (color < minIndex) color = maxIndex - 1;\r\n\r\n    // palette overflow fix\r\n    color = Math.min(maxIndex - 1, Math.max(minIndex, color));\r\n\r\n    player.switchColor(color);\r\n});\r\nexport const colorInc = new Tool('right color', 'KeyS');\r\ncolorInc.on('down', function () {\r\n    // allColors and currentpalette can be different\r\n    // we must overflow the color if its id exceeds \r\n    // not all palette length, but the current used one\r\n    const minIndex = currentPalette?.slice[0] ?? 0;\r\n    const maxIndex = currentPalette?.slice[1] ?? allColors.length;\r\n\r\n    let color = player.color + 1;\r\n    if (color >= maxIndex) color = minIndex;\r\n\r\n    // palette overflow fix\r\n    color = Math.min(maxIndex - 1, Math.max(minIndex, color));\r\n\r\n    player.switchColor(color);\r\n});\r\n","import { currentPalette, palettes } from '../config';\r\nimport Tool from '../Tool';\r\nimport { paletteChosen } from '../ui/palette';\r\n\r\n\r\nconst paletteSwapper = new Tool('palette_swap', 'KeyH');\r\npaletteSwapper.on('down', function () {\r\n    const allPalettes = palettes;\r\n    if (!allPalettes) return;\r\n\r\n    let paletteIdx = palettes.findIndex(p => p.name === currentPalette.name);\r\n    paletteIdx = ++paletteIdx % palettes.length;\r\n\r\n    const newPalette = allPalettes[paletteIdx];\r\n    paletteChosen(newPalette.name);\r\n});\r\nexport default paletteSwapper;","import camera from '../camera';\r\nimport { boardHeight, boardWidth, allColors } from '../config';\r\nimport { ROLE } from '../constants';\r\nimport { addFX, FX, removeFX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport me from '../me';\r\nimport { SelectMiniWindow } from '../MiniWindow';\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\nimport { translate as t } from '../translate';\r\nimport { closestColor } from '../utils/color';\r\nimport { boardToScreenSpace } from '../utils/conversions';\r\nimport { getLS } from '../utils/localStorage';\r\nimport { mapRange } from '../utils/math';\r\nimport { sleep } from '../utils/misc';\r\n\r\n\r\n// WARNING: it's not supposed to be a bot\r\n// so it won't check for connection or re-check image\r\n// write your own bots please \r\nclass Paste extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        // 0 - idle\r\n        // 1 - choosing\r\n        // 2 - placing\r\n        // 3 - drawing\r\n        this.state = 0;\r\n\r\n        this.moveFX = null;\r\n        this.drawInterval = null;\r\n\r\n        this.lastClipboardEvent = {\r\n            ev: null,\r\n            date: null\r\n        };\r\n\r\n        this.initListeners();\r\n    }\r\n\r\n    initListeners() {\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    async down() {\r\n        if (this.state === 0 || this.state === 1) {\r\n            this.state = 1;\r\n\r\n            // in case 'Paste' event launched later\r\n            await sleep(100);\r\n\r\n            try {\r\n                let whichOne = 'file';\r\n                if (this.isImagePasted()) {\r\n                    whichOne = await this.promptClipboardOrFile();\r\n                }\r\n\r\n                let canvas;\r\n                if (whichOne === 'clip') {\r\n                    canvas = await this.getClipboardImage(this.lastClipboardEvent.ev);\r\n                } else if (whichOne === 'file') {\r\n                    canvas = await this.askFileImage();\r\n                }\r\n                if (canvas)\r\n                    this.startPlace(canvas);\r\n\r\n                this.lastClipboardEvent.ev = null;\r\n                this.lastClipboardEvent.date = null;\r\n            } finally {\r\n                this.state = 0;\r\n            }\r\n        } else if (this.state == 2) {\r\n            // this.state = 0\r\n            // this.stopPlace();\r\n        } else if (this.state == 3) {\r\n            this.state = 0;\r\n            this.stopDraw();\r\n        }\r\n    }\r\n\r\n    async promptClipboardOrFile() {\r\n        return new Promise((res, rej) => {\r\n            try {\r\n                const btns = [{\r\n                    text: t('from_clipboard'),\r\n                    id: 'clip'\r\n                },\r\n                {\r\n                    text: t('from_file'),\r\n                    id: 'file'\r\n                }];\r\n\r\n                const win = new SelectMiniWindow(btns, res, t('paste.choose_from'));\r\n                document.body.appendChild(win.element[0]);\r\n\r\n                win.center();\r\n            } catch (error) {\r\n                rej(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    isImagePasted() {\r\n        const lastEv = this.lastClipboardEvent;\r\n        if (!lastEv.images || Date.now() - lastEv.date > 1000) return false;\r\n        return true;\r\n    }\r\n\r\n    async getClipboardImage() {\r\n        const { images } = this.lastClipboardEvent;\r\n        if (!images?.length) return null;\r\n        return await this.readCanvasFromFile(images[0]);\r\n    }\r\n\r\n    async askFileImage() {\r\n        // get file from system\r\n        const input = document.createElement('input');\r\n        input.type = 'file';\r\n        input.accept = 'image/png';\r\n\r\n        input.click();\r\n\r\n        return new Promise((res, rej) => {\r\n            input.onchange = () => {\r\n                input.onchange = null;\r\n\r\n                if (!input.files.length || input.files[0] == \"\") {\r\n                    return rej();\r\n                }\r\n\r\n                // read first file with filereader\r\n                this.readCanvasFromFile(input.files[0])\r\n                    .then(res)\r\n                    .catch(rej);\r\n            };\r\n        });\r\n    }\r\n\r\n    readCanvasFromFile(file) {\r\n        return new Promise((res, rej) => {\r\n            const reader = new FileReader();\r\n            reader.readAsDataURL(file);\r\n\r\n            reader.onload = () => {\r\n                const img = new Image();\r\n                img.src = reader.result;\r\n                img.onload = () => {\r\n                    // draw image on canvas to get its data\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = img.width;\r\n                    canvas.height = img.height;\r\n\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(img, 0, 0);\r\n\r\n                    res(canvas);\r\n                };\r\n                img.onerror = rej;\r\n            };\r\n            reader.onerror = rej;\r\n        });\r\n    }\r\n\r\n    startPlace(canvas, protectMask = null) {\r\n        if (protectMask && protectMask.length !== canvas.width * canvas.height) {\r\n            throw new Error('protect mask length mismatch');\r\n        }\r\n\r\n        player.suspendColors();\r\n        this.state = 2;\r\n\r\n        let xPos = player.x, yPos = player.y;\r\n\r\n        function render(ctx) {\r\n            const [x, y] = boardToScreenSpace(xPos, yPos);\r\n            const z = camera.zoom;\r\n\r\n            const opacity = mapRange(Math.sin(Date.now() / 400), -1, 1, 0.5, 1);\r\n            ctx.globalAlpha = opacity;\r\n\r\n            ctx.save();\r\n            ctx.scale(z, z);\r\n            ctx.drawImage(canvas, x / z, y / z);\r\n            ctx.restore();\r\n\r\n            ctx.globalAlpha = 1;\r\n            return 0;\r\n        }\r\n\r\n        const fx = this.moveFX = new FX(render);\r\n        addFX(fx);\r\n\r\n        function move() {\r\n            let newX = player.x, newY = player.y;\r\n            if (newX == xPos && newY == yPos)\r\n                return;\r\n\r\n            xPos = newX;\r\n            yPos = newY;\r\n        }\r\n\r\n        let lastX, lastY;\r\n        let down = function (e) {\r\n            lastX = e.clientX;\r\n            lastY = e.clientY;\r\n        };\r\n\r\n        let up = function (e) {\r\n            if (e.button == 2) {\r\n                this.state = 0;\r\n                this.stopPlace(); off();\r\n                return;\r\n            };\r\n\r\n            let [x, y] = [e.clientX, e.clientY];\r\n            if (Math.abs(x - lastX) > 5 || Math.abs(y - lastY) > 5) return;\r\n\r\n            off();\r\n            player.restoreColors();\r\n\r\n            this.stopPlace();\r\n            this.startDraw(canvas, xPos, yPos, protectMask);\r\n        };\r\n        up = up.bind(this);\r\n\r\n        function off() {\r\n            globals.eventManager.off('mousedown', down);\r\n            globals.eventManager.off('mouseup', up);\r\n            globals.toolManager.off('move', move);\r\n        }\r\n\r\n        globals.eventManager.on('mousedown', down);\r\n        globals.eventManager.on('mouseup', up);\r\n        globals.toolManager.on('move', move);\r\n    }\r\n\r\n    stopPlace() {\r\n        removeFX(this.moveFX);\r\n        this.removeAllListeners('move');\r\n    }\r\n\r\n    startDraw(canvas, startX, startY, protectMask = null) {\r\n        if(me.role < ROLE.TRUSTED && (canvas.width > 150 || canvas.height > 150)){\r\n            toastr.warning('no, comrade');\r\n            return;\r\n        }\r\n\r\n        this.state = 3;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        const { width: w } = canvas;\r\n\r\n        let imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\r\n        let offset = -4;\r\n\r\n        const isMod = me.role >= ROLE.MOD;\r\n\r\n        function draw() {\r\n            let allowance = Math.floor(player.bucket.allowance);\r\n            if (allowance == 0) return;\r\n\r\n            let pixels = [], protectPixels = [];\r\n\r\n            let max = 13106;\r\n            if (getLS('ya', false) === 'polkovnik') {\r\n                max = 52441;\r\n            }\r\n            while (allowance > 0 && offset < imgdata.length - 4 && pixels.length < max && protectPixels.length < max) {\r\n                offset += 4;\r\n\r\n                let rgba = [\r\n                    imgdata[offset],\r\n                    imgdata[offset + 1],\r\n                    imgdata[offset + 2],\r\n                    imgdata[offset + 3],\r\n                ];\r\n\r\n                if (rgba[3] < 127) continue;\r\n\r\n                let off = offset / 4;\r\n                const offX = off % w, offY = off / w | 0;\r\n\r\n                const boardX = startX + offX, boardY = startY + offY;\r\n                if (boardX < 0 || boardX >= boardWidth ||\r\n                    boardY < 0 || boardY >= boardHeight)\r\n                    continue;\r\n\r\n                if (isMod && protectMask) {\r\n                    const protectedState = protectMask[offX + offY * w];\r\n                    protectPixels.push([boardX, boardY, protectedState]);\r\n                }\r\n\r\n\r\n                const color = closestColor(rgba, allColors);\r\n                const oldCol = globals.chunkManager.getChunkPixel(boardX, boardY);\r\n                if (oldCol == color) continue;\r\n\r\n                allowance--;\r\n\r\n                pixels.push([boardX, boardY, color]);\r\n            }\r\n\r\n            if (pixels.length) {\r\n                player.bucket.spend(pixels.length);\r\n                globals.socket.sendPixels(pixels);\r\n                if (protectPixels.length) {\r\n                    globals.socket.sendPixels(protectPixels, true);\r\n                }\r\n            }\r\n\r\n            if (offset >= imgdata.length - 4) {\r\n                this.state = 0;\r\n                this.stopDraw();\r\n            }\r\n        }\r\n\r\n        this.drawInterval = setInterval(draw.bind(this), 50);\r\n    }\r\n\r\n    stopDraw() {\r\n        clearInterval(this.drawInterval);\r\n    }\r\n}\r\nexport const paste = new Paste('paste', 'CTRL+KeyV', null, ROLE.MOD);\r\ndocument.addEventListener('paste', (ev) => {\r\n    // paste event does not work for other than ctrl+v\r\n    // so skip in case some another tool assigned for this key\r\n    // (check your sanity if you do :D)\r\n    if (paste.key !== 'CTRL+KeyV') return;\r\n\r\n    const images = [];\r\n    for (const item of ev.clipboardData.items) {\r\n        if (item.type.startsWith('image/')) {\r\n            images.push(item.getAsFile());\r\n        }\r\n    }\r\n\r\n    if (images.length) {\r\n        paste.lastClipboardEvent = {\r\n            images,\r\n            date: Date.now()\r\n        };\r\n    }\r\n});\r\n\r\nexport default paste;","import { mobile, getPixel, renderFX } from \"./toolUtils\";\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\n\r\n\r\nexport class Pipette extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        if (mobile) {\r\n            return;\r\n            this.on('down', this.mobileDown.bind(this));\r\n            this.on('up', this.mobileUp.bind(this));\r\n        }\r\n        else\r\n            this.on('down', this.down);\r\n    }\r\n\r\n    down(e) {\r\n        const color = getPixel(player.x, player.y);\r\n\r\n        if (color === -1) return;\r\n\r\n        if (e.__alt)\r\n            player.switchSecondColor(color);\r\n\r\n        else\r\n            player.switchColor(color);\r\n\r\n        renderFX();\r\n    }\r\n\r\n    // separate handlers for handling both\r\n    // primary and seconary colors on mobiles\r\n    // DISABLED FOR THE MOMENT\r\n    // is pipette really need in game\r\n    // with restricted palette .. ?\r\n    mobileDown() {\r\n        this.downCord = [player.x, player.y];\r\n        this.downTime = Date.now();\r\n    }\r\n\r\n    mobileUp() {\r\n        let lastCord = [player.x, player.y];\r\n        let lastTime = Date.now();\r\n\r\n        this.downCord = null;\r\n        this.downTime = null;\r\n    }\r\n}\r\nexport const pipette = new Pipette('pipette', 'KeyC');\r\nexport const altPipette = new Pipette('alt pipette', 'ALT+KeyC');\r\naltPipette.off('down', altPipette.down);\r\naltPipette.on('down', (e) => {\r\n    e.__alt = true;\r\n    altPipette.down.call(altPipette, e);\r\n});\r\n\r\n","import camera from '../camera';\r\nimport { canvasId } from '../config';\r\nimport { addFX, FX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\nimport { apiRequest } from '../utils/api';\r\nimport { boardToScreenSpace } from '../utils/conversions';\r\nimport { htmlspecialchars } from '../utils/misc';\r\n\r\n\r\nconst pixelInfo = new Tool('pixel info', 'KeyI');\r\nlet last = null, pinfoFx = null;\r\nfunction removeLast() {\r\n    if (last) {\r\n        last.remove();\r\n        last = null;\r\n    }\r\n    if (pinfoFx) {\r\n        pinfoFx.remove();\r\n        pinfoFx = null;\r\n    }\r\n}\r\nglobals.eventManager.on('mouseup', removeLast);\r\npixelInfo.on('up', async () => {\r\n    removeLast();\r\n\r\n    const [x, y] = [player.x, player.y];\r\n\r\n    const resp = await apiRequest(`/pixelInfo?canvas=${canvasId}&x=${x}&y=${y}`);\r\n    const data = await resp.json();\r\n    if (!data || !data.type) return;\r\n\r\n    const el = $('<div class=\"infoBubble\"><span style=\"user-select:text\"></span></div>');\r\n    last = el;\r\n\r\n    const coordsLegend = $('<div>');\r\n    coordsLegend[0].style.cssText =\r\n        `position: absolute;\r\n    top: -7px;\r\n    left: 0;\r\n    width: 100%;\r\n    font-size: 14px;\r\n    font-weight: bold;\r\n    text-shadow: rgb(255 255 255) -1px 1px 0px, rgb(255 255 255) 1px 1px 0px, rgb(255 255 255) 1px -1px 0px, rgb(255 255 255) -1px -1px 0px;\r\n    text-align: center;`;\r\n    coordsLegend.text(`(${x}, ${y})`);\r\n\r\n    el.append(coordsLegend);\r\n\r\n    let text = '';\r\n\r\n    if (data.type === 'UID') {\r\n        const sanitizedName = htmlspecialchars(data.placer.nick);\r\n\r\n        text += '<b>UID</b>&nbsp;' + data.placer.id + '<br>',\r\n            text += '<b>name</b>&nbsp;' + sanitizedName;\r\n    } else {\r\n        text += `<b>${data.type}</b>`;\r\n        if (data.placer) {\r\n            text += '&nbsp;' + data.placer;\r\n        }\r\n    }\r\n\r\n    $('span', el).html(text);\r\n\r\n    $('body').append(el);\r\n\r\n    const w = el[0].clientWidth;\r\n    const h = el[0].clientHeight;\r\n\r\n    function fixPos() {\r\n        const [clientX, clientY] = boardToScreenSpace(x, y);\r\n        const posX = clientX + (camera.zoom / 2) - (w / 2);\r\n        const posY = clientY - h - 11;\r\n\r\n        el.css('top', posY).css('left', posX);\r\n\r\n        return 1;\r\n    }\r\n    fixPos();\r\n\r\n\r\n    pinfoFx = new FX(() => {\r\n        fixPos();\r\n    });\r\n    addFX(pinfoFx, 2);\r\n});\r\n\r\nexport default pixelInfo;","import { mobile, getProtect } from \"./toolUtils\";\r\nimport protectIcon from '../../img/toolIcons/protect.png';\r\nimport { Clicker } from \"./clicker\";\r\nimport { showProtected } from '../config';\r\nimport { ROLE } from '../constants';\r\nimport globals from '../globals';\r\n\r\n\r\nexport class Protector extends Clicker {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.minZoom = 1;\r\n\r\n        // is this unprotector\r\n        this._alt = false;\r\n        // first touch determines whether protect or not (for full down-move-up):\r\n        // protected => unprotect; unprotected => protect,\r\n        // i.e. inverts pixel state\r\n        this._mobileIsProtect = null;\r\n    }\r\n\r\n    getProtectState() {\r\n        if (mobile)\r\n            return this._mobileIsProtect;\r\n\r\n        else\r\n            return this._alt ? false : true;\r\n\r\n    }\r\n\r\n    // override Clicker's mouse events\r\n    mousedown() { }\r\n    mouseup() { }\r\n\r\n    down(e) {\r\n        if (this.mouseIsDown) return;\r\n\r\n        super.down(e);\r\n\r\n        showProtected(); // force protect visibility\r\n        this._mobileIsProtect = !getProtect(...this.lastPos);\r\n    }\r\n\r\n    checkPixel(x, y) {\r\n        const key = `${x},${y}`;\r\n        const state = this.getProtectState();\r\n\r\n        const curState = getProtect(x, y);\r\n        if (curState === state) return;\r\n\r\n        if (this._pendingPixels[key] && this._pendingPixels[key][0] === state) return;\r\n        this._pendingPixels[key] = [state, Date.now()];\r\n\r\n        return true;\r\n    }\r\n\r\n    checkAllowance() { return true; }\r\n\r\n    place(pixels) {\r\n        // now we should replace colors from\r\n        // clicker's move func with protect state\r\n        const state = this.getProtectState();\r\n        pixels.forEach(p => p[2] = state);\r\n        if (!pixels.length) return;\r\n\r\n        globals.socket.sendPixels(pixels, true);\r\n    }\r\n\r\n    render() { }\r\n}\r\n\r\nexport const protector = new Protector('protector', 'KeyV', protectIcon, ROLE.MOD);\r\nexport const altProtector = new Protector('alt protector', 'ALT+KeyV', null, ROLE.MOD);\r\naltProtector._alt = true;\r\n\r\n","import player from '../player';\r\nimport Tool from '../Tool';\r\n\r\n\r\nconst resetColors = new Tool('reset colors', 'RMB');\r\nresetColors.on('up', () => {\r\n    player.resetColors();\r\n});\r\nexport default resetColors;","import { mobile } from \"./toolUtils\";\r\nimport chat from '../Chat';\r\nimport Tool from '../Tool';\r\nimport { chatInput } from '../ui/elements';\r\n\r\n\r\nconst cordAdd = new Tool('coords to chat', 'KeyU');\r\ncordAdd.on('up', function () {\r\n    const cords = $('#coords').text();\r\n    if (!cords.length) return;\r\n    chatInput[0].value += cords + ' ';\r\n    if (mobile) {\r\n        chat.mobileShow();\r\n    }\r\n    chatInput.trigger('focus');\r\n});\r\nexport default cordAdd;","import { getColByCord, renderFX, checkBounds, getPixel } from \"./toolUtils\";\r\nimport camera from '../camera';\r\nimport { hexPalette } from '../config';\r\nimport { addFX, FX, removeFX } from '../fxcanvas';\r\nimport player, { placePixel, placePixels } from '../player';\r\nimport Tool from '../Tool';\r\nimport { boardToScreenSpace } from '../utils/conversions';\r\nimport shapes from '../utils/shapes';\r\n\r\n\r\nclass Square extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.handlers();\r\n    }\r\n\r\n    handlers() {\r\n        let startCoords, endCoords, lastCoords = [], fx, isDown = false, square, color, color2;\r\n\r\n        function down() {\r\n            if (isDown) return;\r\n            isDown = true;\r\n\r\n            startCoords = [player.x, player.y];\r\n\r\n            [color, color2] = [player.color, player.secondCol];\r\n\r\n            this.emit('move');\r\n        }\r\n\r\n        function move() {\r\n            if (!isDown || !startCoords) return;\r\n\r\n            endCoords = [player.x, player.y];\r\n\r\n            if (endCoords[0] != lastCoords[0] || endCoords[1] != lastCoords[1]) {\r\n                lastCoords = endCoords;\r\n\r\n                let minX = Math.min(startCoords[0], lastCoords[0]);\r\n                let minY = Math.min(startCoords[1], lastCoords[1]);\r\n                let maxX = Math.max(startCoords[0], lastCoords[0]);\r\n                let maxY = Math.max(startCoords[1], lastCoords[1]);\r\n\r\n                \r\n                fx && removeFX(fx);\r\n                fx = new FX((ctx) => {\r\n                    ctx.globalAlpha = .5;\r\n                    \r\n                    if (player.color !== -1 && player.secondCol !== -1) {\r\n                        const pixels = shapes.square(minX, minY, maxX, maxY);\r\n                        // slow render for duo colors\r\n                        for (let [x, y] of pixels) {\r\n                            const [sx, sy] = boardToScreenSpace(x, y);\r\n                            const color = getColByCord(x, y);\r\n                            ctx.fillStyle = hexPalette[color];\r\n                            ctx.fillRect(sx, sy, camera.zoom, camera.zoom);\r\n                        }\r\n                    }else{\r\n                        // simplest way to get one of the colors lol\r\n                        const color = getColByCord(0, 0);\r\n                        ctx.fillStyle = hexPalette[color];\r\n\r\n                        let [startX, startY] = boardToScreenSpace(minX, minY);\r\n                        let [endX, endY] = boardToScreenSpace(maxX+1, maxY+1);\r\n\r\n\r\n                        \r\n\r\n                        ctx.fillRect(startX, startY, endX-startX, endY-startY);\r\n                    }\r\n\r\n                    ctx.globalAlpha = 1;\r\n\r\n                    return 1;\r\n                });\r\n                addFX(fx);\r\n            }\r\n        }\r\n\r\n        function up() {\r\n            this.off('tick', tick);\r\n            isDown = false;\r\n\r\n            if (!startCoords) return;\r\n\r\n            fx && fx.remove();\r\n\r\n            if (!endCoords) endCoords = [player.x, player.y];\r\n\r\n            square = shapes.square(...startCoords, ...endCoords);\r\n\r\n            renderFX();\r\n\r\n            if (square.length <= 1) return;\r\n            this.on('tick', tick);\r\n        }\r\n\r\n        function tick() {\r\n            let infCd = (player.bucket.allowance === Infinity);\r\n\r\n            if (!this.lastTick) this.lastTick = Date.now();\r\n\r\n            if (infCd && Date.now() - this.lastTick < 50) return;\r\n            this.lastTick = Date.now();\r\n\r\n            //   0\r\n            let counter = 0;\r\n            let toSend = [];\r\n            while (counter < 1000) {\r\n                if (!square || !square.length) {\r\n                    this.off('tick', tick);\r\n                    break;\r\n                }\r\n\r\n                const [x, y] = square.pop();\r\n                const col = getColByCord(x, y, color, color2);\r\n\r\n                if (col === undefined || col === -1) return this.off('tick', tick);\r\n                if (!checkBounds(x, y)) continue;\r\n                if (getPixel(x, y) === col) continue;\r\n                if (!player.bucket.spend(1)) return square.push([x, y]);\r\n\r\n                counter++;\r\n\r\n                if (infCd) {\r\n                    toSend.push([x, y, col]);\r\n                } else {\r\n                    placePixel(x, y, col);\r\n                }\r\n            }\r\n\r\n            if (toSend.length) {\r\n                placePixels(toSend, true);\r\n            }\r\n        }\r\n\r\n        down = down.bind(this);\r\n        move = move.bind(this);\r\n        up = up.bind(this);\r\n\r\n        tick = tick.bind(this);\r\n\r\n        this.on('down', down);\r\n        this.on('move', move);\r\n        this.on('up', up);\r\n    }\r\n}\r\nconst square = new Square('square', 'KeyJ');\r\nexport default square;","import template, { updateTemplate } from '../template';\r\nimport Tool from '../Tool';\r\n\r\n\r\nlet tempOpacity = template.opacity;\r\nexport const templateOp1 = new Tool('template 0/N opaq', 'KeyO');\r\ntemplateOp1.on('down', () => {\r\n    if (template.opacity == 0) {\r\n        template.opacity = tempOpacity;\r\n    } else {\r\n        tempOpacity = template.opacity;\r\n        template.opacity = 0;\r\n    }\r\n    updateTemplate();\r\n});\r\nexport const templateOp2 = new Tool('template 1/N opaq', 'KeyP');\r\ntemplateOp2.on('down', () => {\r\n    if (template.opacity == 1) {\r\n        template.opacity = tempOpacity;\r\n    } else {\r\n        tempOpacity = template.opacity;\r\n        template.opacity = 1;\r\n    }\r\n    updateTemplate();\r\n});\r\n","import { mobile } from \"./toolUtils\";\r\nimport min5fontSheet from '../../font/pixel/min5.png';\r\nimport min5fontInfo from '../../font/pixel/min5.txt';\r\nimport camera from '../camera';\r\nimport { hexPalette } from '../config';\r\nimport { ROLE } from '../constants';\r\nimport { addFX, FX, removeFX } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport MiniWindow from '../MiniWindow';\r\nimport { paste } from \"./paste\";\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\nimport { boardToScreenSpace } from '../utils/conversions';\r\nimport { mapRange } from '../utils/math';\r\n\r\n\r\nexport class PixelFont {\r\n    static defaultVSpacing = 1;\r\n\r\n    constructor(imagePath, infoPath) {\r\n        this.imagePath = imagePath;\r\n        this.infoPath = infoPath;\r\n\r\n        this.defaultWidth = null;\r\n        this.defaultHeight = null;\r\n        this.letters = {};\r\n\r\n        this.loaded = false;\r\n        this._isLoading = false;\r\n    }\r\n\r\n    async load() {\r\n        if (this._isLoading) return;\r\n        this._isLoading = true;\r\n\r\n        try {\r\n            const fontCanvas = await new Promise((res, rej) => {\r\n                const img = new Image();\r\n\r\n                img.onload = () => {\r\n                    const canvas = document.createElement('canvas');\r\n\r\n                    canvas.width = img.width;\r\n                    canvas.height = img.height;\r\n\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(img, 0, 0);\r\n\r\n                    res(canvas);\r\n                };\r\n\r\n                img.onerror = rej;\r\n\r\n                img.src = this.imagePath;\r\n            });\r\n\r\n            const fontInfoResp = await fetch(this.infoPath);\r\n            const fontInfo = await fontInfoResp.json();\r\n\r\n            const defaultWidth = fontInfo.defaultWidth;\r\n            this.defaultWidth = defaultWidth;\r\n            const height = fontInfo.fixedHeight;\r\n            this.defaultHeight = height;\r\n\r\n            const fontCanvasCtx = fontCanvas.getContext('2d');\r\n            this.letters = {};\r\n\r\n            let offsetX = 0;\r\n            for (let letter of fontInfo.letters) {\r\n                const {\r\n                    letter: letterSymbol, width = defaultWidth\r\n                } = letter;\r\n\r\n                const slice = fontCanvasCtx.getImageData(offsetX, 0, width, height);\r\n                this.letters[letterSymbol] = slice;\r\n\r\n                // extra 1 because it's one white pixel before each next letter\r\n                offsetX += width + 1;\r\n            }\r\n        } catch (error) {\r\n            this._isLoading = false;\r\n            throw error;\r\n        }\r\n\r\n        this._isLoading = false;\r\n        this.loaded = true;\r\n    }\r\n\r\n    drawText(text, color = 'black') {\r\n        if (!this.loaded) throw new Error('font not loaded');\r\n\r\n        text = text.toUpperCase();\r\n\r\n        const {\r\n            width: textWidth, height: textHeight\r\n        } = this.measureText(text);\r\n\r\n        if (textWidth == 0 || textHeight == 0) {\r\n            return null;\r\n        }\r\n\r\n        const colorCanvas = document.createElement('canvas');\r\n        const textCanvas = document.createElement('canvas');\r\n\r\n        colorCanvas.width = textCanvas.width = textWidth;\r\n        colorCanvas.height = textCanvas.height = textHeight;\r\n\r\n        const colorCanvasCtx = colorCanvas.getContext('2d');\r\n        const textCanvasCtx = textCanvas.getContext('2d');\r\n\r\n        const textLetters = text.split('');\r\n        let cursorX = 0, cursorY = 0;\r\n        for (let letter of textLetters) {\r\n            if (letter == '\\n') {\r\n                cursorY += this.defaultHeight + PixelFont.defaultVSpacing;\r\n                cursorX = 0;\r\n                continue;\r\n            }\r\n\r\n            if (letter == ' ') {\r\n                cursorX += this.defaultWidth;\r\n                continue;\r\n            }\r\n\r\n            let letterImData = this.letters[letter];\r\n            if (!letterImData) {\r\n                cursorX += this.defaultWidth;\r\n                continue;\r\n            }\r\n\r\n            textCanvasCtx.putImageData(letterImData, cursorX, cursorY);\r\n            cursorX += letterImData.width + 1; // 1 is the constant spacing\r\n        }\r\n\r\n        // first, we draw text canvas shaped, colored rect \r\n        // then we will put the text on top of it, using\r\n        // globalComposite property.\r\n        // this will keep only those pixels of colored rect, in which\r\n        // letters are. this will \"color\" the letters in the color of the rect\r\n        colorCanvasCtx.fillStyle = color;\r\n        colorCanvasCtx.fillRect(0, 0, textWidth, textHeight);\r\n\r\n        colorCanvasCtx.globalCompositeOperation = 'destination-atop';\r\n        colorCanvasCtx.drawImage(textCanvas, 0, 0);\r\n\r\n        return colorCanvas;\r\n    }\r\n\r\n    measureText(text) {\r\n        if (!this.loaded) throw new Error('font not loaded');\r\n\r\n        text = text.toUpperCase();\r\n\r\n        const textLetters = text.split('');\r\n        let curWidth = 0, maxWidth = 0, height = this.defaultHeight;\r\n\r\n        for (let letter of textLetters) {\r\n            if (letter == '\\n') {\r\n                height += this.defaultHeight + PixelFont.defaultVSpacing;\r\n                maxWidth = Math.max(curWidth, maxWidth);\r\n                curWidth = 0;\r\n                continue;\r\n            }\r\n\r\n            if (letter == ' ') {\r\n                curWidth += this.defaultWidth;\r\n                continue;\r\n            }\r\n\r\n            if (this.letters[letter]) {\r\n                curWidth += (this.letters[letter].width || this.defaultWidth) + 1;\r\n            }\r\n        }\r\n\r\n        return {\r\n            width: Math.max(curWidth, maxWidth), height\r\n        };\r\n    }\r\n}\r\nclass Text extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.fonts = [\r\n            new PixelFont(min5fontSheet, min5fontInfo)\r\n        ];\r\n        this.fonts.forEach(f => f.load());\r\n\r\n        this.miniWindow = null;\r\n\r\n        this.on('down', this.down.bind(this));\r\n    }\r\n\r\n    down(e) {\r\n        if (this.miniWindow && !this.miniWindow.closed) return;\r\n\r\n        globals.lockInputs = true;\r\n\r\n        this.miniWindow = new MiniWindow('Draw text', 2);\r\n        const winEl = this.miniWindow.element;\r\n        if (mobile) {\r\n            winEl.css('left', 0).css('top', 0);\r\n        } else {\r\n            winEl.css('left', window.screen.width / 3).css('top', window.screen.height / 3);\r\n        }\r\n\r\n        const innerHtml = $(`\r\n            <textarea style=\"width: 100%;\"></textarea>\r\n            <div style=\"display:flex; margin: 2px 0\">\r\n                <div style=\"display: flex\">\r\n                    <div>x:</div> <input type=\"number\" class=\"textXCord\" style=\"width: 100%\">\r\n                </div>\r\n                <div style=\"display: flex; margin-left: 2px\">\r\n                    <div>y:</div> <input type=\"number\" class=\"textYCord\" style=\"width: 100%\">\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        this.miniWindow.bodyElement.css('max-width', 200).css('display', 'flex').css('flex-direction', 'column');\r\n        this.miniWindow.bodyElement.append(innerHtml);\r\n        document.body.appendChild(winEl[0]);\r\n\r\n        const textInput = $('textarea', this.miniWindow.bodyElement);\r\n        const xCordInput = $('.textXCord', this.miniWindow.bodyElement);\r\n        const yCordInput = $('.textYCord', this.miniWindow.bodyElement);\r\n\r\n        const lastCord = [player.x, player.y];\r\n        xCordInput.val(lastCord[0]);\r\n        yCordInput.val(lastCord[1]);\r\n\r\n        const font = this.fonts[0];\r\n\r\n        let lastText = null, lastColor = player.color, lastTextCanvas = null;\r\n        const previewFx = new FX((ctx) => {\r\n            const text = textInput.val();\r\n            if (!text) return 0;\r\n\r\n            if (!font.loaded) {\r\n                return 0;\r\n            }\r\n\r\n            // remap the sine value based on the time\r\n            // to the min-max opacity borders\r\n            ctx.globalAlpha = mapRange(Math.sin(Date.now() / 400), -1, 1, 0.2, 0.9);\r\n\r\n            const x = xCordInput.val();\r\n            const y = yCordInput.val();\r\n\r\n            if (lastText !== text || lastColor !== player.color) {\r\n                lastText = text;\r\n                lastColor = player.color;\r\n                lastTextCanvas = font.drawText(lastText, hexPalette[lastColor]);\r\n            }\r\n\r\n            const [screenX, screenY] = boardToScreenSpace(x, y);\r\n\r\n\r\n            ctx.save();\r\n            ctx.scale(camera.zoom, camera.zoom);\r\n\r\n            ctx.imageSmoothingEnabled = false;\r\n\r\n            const deZoomedX = screenX / camera.zoom;\r\n            const deZoomedY = screenY / camera.zoom;\r\n\r\n            if (~player.secondCol) {\r\n                ctx.fillStyle = hexPalette[player.secondCol];\r\n                ctx.fillRect(deZoomedX, deZoomedY, lastTextCanvas.width, lastTextCanvas.height);\r\n            }\r\n            ctx.drawImage(lastTextCanvas, deZoomedX, deZoomedY);\r\n\r\n            ctx.restore();\r\n\r\n            return 0;\r\n        });\r\n        addFX(previewFx);\r\n\r\n        this.miniWindow.on('okClicked', () => {\r\n            globals.lockInputs = false;\r\n\r\n            removeFX(previewFx);\r\n\r\n            const text = textInput.val();\r\n            if (!text || !lastTextCanvas) return;\r\n\r\n            // add background if second color is selected\r\n            if (~player.secondCol) {\r\n                const ctx = lastTextCanvas.getContext('2d');\r\n                // draw only on opaque pixels\r\n                ctx.globalCompositeOperation = 'destination-over';\r\n                ctx.fillStyle = hexPalette[player.secondCol];\r\n                ctx.fillRect(0, 0, lastTextCanvas.width, lastTextCanvas.height);\r\n            }\r\n\r\n            const x = +xCordInput.val();\r\n            const y = +yCordInput.val();\r\n\r\n            paste.startDraw(lastTextCanvas, x, y);\r\n        });\r\n\r\n        this.miniWindow.on('cancelClicked', () => {\r\n            globals.lockInputs = false;\r\n\r\n            removeFX(previewFx);\r\n        });\r\n    }\r\n}\r\nconst text = new Text('text', 'KeyT', null, ROLE.USER);\r\nexport default text;","import { boardHeight, boardWidth } from '../config';\r\nimport player from '../player';\r\nimport globals from '../globals';\r\n\r\n\r\nexport const mobile = globals.mobile;\r\n\r\nexport function getPixel(x, y) {\r\n    return globals.chunkManager.getChunkPixel(x, y)\r\n}\r\n\r\nexport function getProtect(x, y) {\r\n    return globals.chunkManager.getProtect(x, y)\r\n}\r\n\r\nexport function isOdd(x, y) {\r\n    return ((x + y) % 2) === 0\r\n}\r\n\r\nexport function getCurCol() {\r\n    if (player.secondCol === -1) {\r\n        return ~player.color ? player.color : -1;\r\n    }\r\n    if (player.color === -1) return player.secondCol;\r\n\r\n    return isOdd(player.x, player.y) ? player.color : player.secondCol\r\n}\r\n\r\nexport function getColByCord(x, y, first = player.color, second = player.secondCol) {\r\n    if (second === -1) return first;\r\n    if (first === -1) return second;\r\n\r\n    return isOdd(x, y) ? first : second\r\n}\r\n\r\nexport function checkBounds(x, y) {\r\n    return (x >= 0 && x < boardWidth && y >= 0 && y < boardHeight)\r\n}\r\n\r\nlet tmLoaded = false;\r\nlet onTMID = setInterval(() => {\r\n    if (globals.toolManager) {\r\n        clearInterval(onTMID);\r\n        _onTmLoaded();\r\n    }\r\n}, 5);\r\nlet tmCallbacks = [];\r\nfunction _onTmLoaded() {\r\n    tmLoaded = true;\r\n    tmCallbacks.forEach(cb => cb(globals.toolManager));\r\n    tmCallbacks = [];\r\n}\r\nexport function onToolManager(cb) {\r\n    if (tmLoaded) cb(globals.toolManager);\r\n    else tmCallbacks.push(cb)\r\n}\r\n\r\nexport function renderFX() {\r\n    globals.fxRenderer.needRender = true;\r\n}","import { toggleChat } from '../Chat';\r\nimport Tool from '../Tool';\r\nimport { toggleEverything, toggleTopMenu } from '../ui/toggles';\r\n\r\n\r\nexport const chatOpac = new Tool('toggle chat', 'KeyK');\r\nchatOpac.on('down', function () {\r\n    toggleChat();\r\n});\r\nexport const menuOpac = new Tool('toggle menu', 'KeyL');\r\nmenuOpac.on('down', function () {\r\n    toggleTopMenu();\r\n});\r\nexport const allOpac = new Tool('toggle everything', 'Semicolon' /* ; */);\r\nallOpac.on('down', function () {\r\n    toggleEverything();\r\n});\r\n","import { mobile } from \"./toolUtils\";\r\nimport wandCursor from '../../img/toolIcons/wand-cur.png';\r\nimport wandIcon from '../../img/toolIcons/wand-cur.png';\r\nimport { allColors } from '../config';\r\nimport { addFX, FX, FX_STATE } from '../fxcanvas';\r\nimport globals from '../globals';\r\nimport player from '../player';\r\nimport Tool from '../Tool';\r\nimport { isDarkColor } from '../utils/color';\r\nimport { screenToBoardSpace } from '../utils/conversions';\r\nimport { isClick } from '../utils/misc';\r\nimport { generateShader } from '../utils/webGL';\r\n\r\n\r\nconst WAND_STATE = {\r\n    DISABLED: 0,\r\n    SELECTING: 1,\r\n    RENDERING: 2\r\n};\r\nclass MagicWand extends Tool {\r\n    constructor(...args) {\r\n        super(...args);\r\n\r\n        this.state = WAND_STATE.DISABLED;\r\n\r\n        this.mouseListeners = {\r\n            down: this.mousedown.bind(this),\r\n            up: this.mouseup.bind(this)\r\n        };\r\n\r\n        this.downPos = null;\r\n\r\n        this.fx = null;\r\n\r\n        this.selectedColor = null;\r\n\r\n        this.maskCanvas = null;\r\n        this.maskImData = null;\r\n        this.maskBuffer = null;\r\n\r\n        this.glData = {\r\n            selColorLoc: null,\r\n            screenSizeLoc: null,\r\n            sdfRadiusLoc: null,\r\n            isDarkLoc: null\r\n        };\r\n\r\n        this.on('up', this.up.bind(this));\r\n        this.on('selected', this.selected.bind(this));\r\n        this.on('deselected', this.deselected.bind(this));\r\n    }\r\n\r\n    // mobile events\r\n    selected() {\r\n        if (this.state === WAND_STATE.RENDERING) {\r\n            this.stopRendering();\r\n        }\r\n        this.startSelecting();\r\n    }\r\n    deselected() {\r\n        if (this.state === WAND_STATE.SELECTING) {\r\n            this.stopSelecting();\r\n        }\r\n    }\r\n\r\n    up() {\r\n        switch (this.state) {\r\n            case WAND_STATE.DISABLED: {\r\n                this.startSelecting();\r\n                break;\r\n            }\r\n            case WAND_STATE.SELECTING: {\r\n                this.stopSelecting();\r\n                break;\r\n            }\r\n            case WAND_STATE.RENDERING: {\r\n                this.stopRendering();\r\n                if (mobile) {\r\n                    this.startSelecting();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    mousedown(e) {\r\n        this.downPos = [e.clientX, e.clientY];\r\n    }\r\n\r\n    mouseup(e) {\r\n        if (!this.downPos) return;\r\n\r\n        const upPos = [e.clientX, e.clientY];\r\n        if (!isClick(this.downPos, upPos)) {\r\n            return;\r\n        }\r\n\r\n        this.stopSelecting();\r\n\r\n        const boardPos = screenToBoardSpace(...upPos);\r\n        const boardColId = globals.chunkManager.getChunkPixel(...boardPos);\r\n        const rgbCol = allColors[boardColId];\r\n\r\n        this.selectedColor = rgbCol;\r\n        globals.wandSelectedColor = boardColId;\r\n\r\n        this.startRendering();\r\n    }\r\n\r\n    startSelecting() {\r\n        this.state = WAND_STATE.SELECTING;\r\n\r\n        this.changeCursor(1);\r\n        player.suspendColors();\r\n\r\n        globals.eventManager.on('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.on('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n    stopSelecting() {\r\n        this.state = WAND_STATE.DISABLED;\r\n\r\n        this.changeCursor(0);\r\n        player.restoreColors();\r\n\r\n        globals.eventManager.off('mousedown', this.mouseListeners.down);\r\n        globals.eventManager.off('mouseup', this.mouseListeners.up);\r\n    }\r\n\r\n    changeCursor(cursorState) {\r\n        if (cursorState === 1) {\r\n            document.body.style.cursor = `url('${wandCursor}') 2 2, auto`;\r\n        } else {\r\n            document.body.style.cursor = '';\r\n        }\r\n    }\r\n\r\n    glRenderMask() {\r\n        const gl = this.glData.gl;\r\n\r\n        gl.viewport(0, 0, this.maskCanvas.width, this.maskCanvas.height);\r\n\r\n        const mainCanvas = globals.mainCtx.canvas;\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, this.glData.texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,\r\n            gl.UNSIGNED_BYTE, mainCanvas);\r\n\r\n        const [r, g, b] = this.selectedColor;\r\n\r\n        gl.uniform4f(this.glData.selColorLoc, r / 255, g / 255, b / 255, 1);\r\n        gl.uniform2f(this.glData.screenSizeLoc, mainCanvas.width, mainCanvas.height);\r\n        gl.uniform1f(this.glData.sdfRadiusLoc, 5);\r\n        gl.uniform1f(this.glData.isDarkLoc, isDarkColor(...this.selectedColor) ? 1 : 0);\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n    }\r\n    startRendering() {\r\n        this.state = WAND_STATE.RENDERING;\r\n\r\n        // first time we need to (re)generate it\r\n        // to prevent the old mask from showing off\r\n        this.generateMaskCanvas();\r\n\r\n        this.fx = new FX(ctx => {\r\n            if (this.state !== WAND_STATE.RENDERING) {\r\n                return FX_STATE.REMOVED;\r\n            }\r\n            const w = ctx.canvas.width;\r\n            const h = ctx.canvas.height;\r\n\r\n            // handling window resize\r\n            if (w !== this.maskCanvas.width ||\r\n                h !== this.maskCanvas.height) {\r\n                this.generateMaskCanvas();\r\n            }\r\n\r\n            this.glRenderMask();\r\n\r\n            ctx.globalAlpha = 0.8;\r\n            ctx.drawImage(this.maskCanvas, 0, 0);\r\n            ctx.globalAlpha = 1;\r\n\r\n            return FX_STATE.FINISHED;\r\n        });\r\n        addFX(this.fx);\r\n    }\r\n\r\n    stopRendering() {\r\n        this.state = WAND_STATE.DISABLED;\r\n\r\n        // cleaning up\r\n        this.maskCanvas = null;\r\n        this.maskImData = null;\r\n        this.maskBuffer = null;\r\n\r\n        this.fx = null;\r\n\r\n        this.selectedColor = null;\r\n        globals.wandSelectedColor = null;\r\n\r\n        globals.fxRenderer.needRender = true;\r\n    }\r\n\r\n    generateMaskCanvas() {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = globals.mainCtx.canvas.width;\r\n        canvas.height = globals.mainCtx.canvas.height;\r\n\r\n\r\n        this.maskCanvas = canvas;\r\n\r\n        this.generateShader();\r\n    }\r\n    generateShader() {\r\n        const maskCanvas = this.maskCanvas;\r\n\r\n        const fragmentShader = `\r\n        precision mediump float;\r\n        uniform sampler2D u_image;\r\n        uniform vec4 u_selectedColor;\r\n        uniform vec2 u_screenSize;\r\n        uniform float u_sdfRadius;\r\n        uniform float u_isDark;\r\n        varying vec2 v_texCoord;\r\n\r\n        void main() {\r\n            vec3 outColor = vec3(0.0);\r\n\r\n            vec4 color = texture2D(u_image, v_texCoord);\r\n            float match = all(equal(color, u_selectedColor)) ? 0.0 : 1.0;\r\n\r\n            float dx = 1.0 / u_screenSize.x;\r\n            float dy = 1.0 / u_screenSize.y;\r\n\r\n            \r\n            // process only surrounding pixels\r\n            if(match == 1.0 && u_isDark == 1.0){\r\n                float maxLength = length(vec2(u_sdfRadius, u_sdfRadius));\r\n                float mindist = 10000.0;\r\n                const float maxRadius = 5.0;\r\n                for(float x = -maxRadius; x < maxRadius; x++){\r\n                    if(abs(x) > u_sdfRadius) continue;\r\n                    for(float y = -maxRadius; y < maxRadius; y++){\r\n                        if(abs(y) > u_sdfRadius) continue;\r\n\r\n                        vec2 newCoord = vec2(dx*x + v_texCoord.x, dy*y + v_texCoord.y);\r\n                        vec4 color = texture2D(u_image, newCoord);\r\n                        bool match = all(equal(color, u_selectedColor));\r\n\r\n                        if(match){\r\n                            mindist = min(mindist, length(vec2(x, y)));\r\n                        }\r\n                    }\r\n                }\r\n                if(mindist != 10000.0){\r\n                    float norm = 1.0 - mindist / maxLength;\r\n\r\n                    outColor = vec3(norm);\r\n                }\r\n            }\r\n\r\n            gl_FragColor = vec4(outColor, match);\r\n        }\r\n        `;\r\n\r\n        const { gl, program, texture } = generateShader(maskCanvas, fragmentShader);\r\n\r\n        this.glData.selColorLoc = gl.getUniformLocation(program, \"u_selectedColor\");\r\n        this.glData.screenSizeLoc = gl.getUniformLocation(program, \"u_screenSize\");\r\n        this.glData.sdfRadiusLoc = gl.getUniformLocation(program, \"u_sdfRadius\");\r\n        this.glData.isDarkLoc = gl.getUniformLocation(program, \"u_isDark\");\r\n\r\n        this.glData.gl = gl;\r\n        this.glData.texture = texture;\r\n    }\r\n}\r\nconst wand = new MagicWand('wand', 'KeyW', wandIcon);\r\nexport default wand;","import { fixChatPosition, toggleEmojis, updateEmojis } from \"../Chat\";\nimport globals from \"../globals\";\nimport { togglePlaced, updatePlaced } from \"../player\";\nimport { getLS, getOrDefault, setLS } from \"../utils/localStorage\";\nimport { getRecommendedColorSize } from \"../utils/misc\";\nimport { chatInput, coords } from \"./elements\";\nimport { showPatternsOnPalette } from \"./palette\";\n\nexport function initUISettings() {\n    toggleEmojis(getLS('hideEmojis') != 1);\n    updateEmojis(getOrDefault('emojis', '        ').split(' '));\n    togglePlaced(!+getOrDefault('hidePlaced', 1))\n    updatePlaced(getLS('placedCount', true));\n    \n    if (getLS('swapToolsPos') == 1) {\n        swapToolsPos(getLS('swapToolsPos'));\n    }\n}\n\nexport function initCoordsClick() {\n    coords.on('click', function () {\n        globals.toolManager.tools.cordAdd.emit('up');\n    })\n}\n\nexport function fixColorsWidth() {\n    const savedWidth = getLS('colorSize', true);\n    const calculated = getRecommendedColorSize();\n\n    const colSize = +savedWidth || calculated\n    setPaletteColorsSize(colSize);\n    fixChatPosition();\n}\n\n// an old analog for setPaletteColorsSize\nexport function setPaletteRows(rows) {\n    let width = (window.innerWidth / 100) * rows;\n\n    $('#palette').css('max-width', width);\n}\n\n\nexport function setPaletteColorsSize(size) {\n    if (size === undefined) {\n        size = getRecommendedColorSize();\n    }\n    $('.paletteColor').css('width', size).css('height', size);\n}\n\nexport function swapToolsPos(state){\n    const qs = $('#tools,.showMenu,.showChat')\n    if(state == 1){\n        qs.addClass('right');\n    }else{\n        qs.removeClass('right');\n    }\n}\n\nexport function unloadPalettePatterns() {\n    $('.paletteColor>img').remove();\n    $('.paletteColor').removeClass('patternColor');\n}\nexport function initMenuResizer() {\n    const resizer = $('#menuResizer');\n    const resizerStripes = $('#resizingStripes');\n\n    let curHeight = +getLS('columnHeight');\n    if (isNaN(curHeight) || curHeight == 0) {\n        curHeight = 123;\n    } else if (curHeight < 0) {\n        curHeight = 0;\n    } else if (curHeight >= (window.screen.height - 250)) {\n        curHeight = window.screen.height - 250;\n    }\n    $('.columnContent').css('height', curHeight);\n\n    let resizeTimeout;\n    let resizeLock = false;\n\n    function unfade() {\n        resizer.css('height', '7px');\n        resizer.css('background-color', '#4c4c4c');\n        resizerStripes.css('opacity', '1');\n    }\n\n    function fade() {\n        clearTimeout(resizeTimeout);\n        resizer.css('height', '');\n        resizer.css('background-color', '');\n        resizerStripes.css('opacity', '');\n    }\n\n    resizer.on('mouseover', () => {\n        clearTimeout(resizeTimeout);\n        resizeTimeout = setTimeout(() => {\n            unfade();\n        }, 500);\n    });\n\n    resizer.on('mouseout', () => {\n        if (resizeLock) return;\n\n        fade();\n    });\n\n    function onmousedown() {\n        resizeLock = true;\n        unfade();\n\n        function onmousemove(e) {\n            curHeight += e.originalEvent.movementY;\n            $('.columnContent').css('height', curHeight);\n            setLS('columnHeight', curHeight);\n        }\n        function oncemouseup() {\n            $(document).off('mousemove', onmousemove);\n            resizeLock = false;\n            fade();\n        }\n\n        $(document).on('mousemove', onmousemove);\n        $(document).one('mouseup', oncemouseup);\n    }\n    resizer.on('mousedown', onmousedown);\n}\n","import { allColors, currentPalette, currentPaletteColors, hexPalette, palettes, setCurrentPalette } from \"../config\";\r\nimport config from './config';\r\nimport { patterns } from \"../convert/patterns\";\r\nimport globals from \"../globals\";\r\nimport player from \"../player\";\r\nimport { isDarkColor } from \"../utils/color\";\r\nimport { getLS, setLS } from \"../utils/localStorage\";\r\nimport { fixColorsWidth, unloadPalettePatterns } from \"./config\";\r\nimport { palette } from \"./elements\";\r\nimport { mobile } from \"../tools/toolUtils\";\r\n\r\nexport function initPalette() {\r\n    const saved = getLS('palette', true) || undefined;\r\n    paletteChosen(saved);\r\n}\r\nexport function paletteChosen(name) {\r\n    const palette = palettes?.find(pal => pal.name === name) || palettes?.at(0);\r\n    let [paletteColors, startIdx] = setCurrentPalette(palette);\r\n\r\n    $('#palette>.paletteColor').remove();\r\n    addPaletteColors(paletteColors, startIdx);\r\n\r\n    if (getLS('showPalettePatterns') == 1) {\r\n        showPatternsOnPalette();\r\n        globals.showPatterns = true;\r\n    }\r\n\r\n    fixColorsWidth();\r\n\r\n    if(name)\r\n        setLS('palette', name, true);\r\n\r\n    globals.toolManager.tools['colorador'].updateUIPalette();\r\n}\r\n\r\n\r\nfunction addPaletteColors(colors, startId) {\r\n    colors.forEach((color, id) => {\r\n        id += startId;\r\n\r\n        const colorEl = document.createElement('div');\r\n        colorEl.style.backgroundColor = `rgb(${color.join(',')})`;\r\n        colorEl.classList = ['paletteColor light'];\r\n        colorEl.id = 'col' + id;\r\n\r\n        // detect long press\r\n        let downtime = 0;\r\n\r\n        var $clrEl = $(colorEl);\r\n\r\n        $clrEl.on('pointerdown', () => {\r\n            downtime = Date.now();\r\n        })\r\n\r\n        $clrEl.on('pointerleave', () => {\r\n            downtime = 0;\r\n        })\r\n\r\n        colorEl.onclick = e => {\r\n            let isLong = false;\r\n            if (downtime != 0) {\r\n                if (Date.now() - downtime > 700) {\r\n                    isLong = true;\r\n                }\r\n                downtime = 0;\r\n            }\r\n\r\n            if(mobile && globals.toolManager.tool === globals.toolManager.tools.colorador){\r\n                globals.toolManager.tools['colorador'].mmb(id);\r\n                return\r\n            }\r\n            let f = isLong ? player.switchSecondColor : player.switchColor;\r\n            f.call(player, id);\r\n        }\r\n\r\n        // only for MMB events\r\n        colorEl.onmouseup = e => {\r\n            if (e.button !== 1) {\r\n                return;\r\n            }\r\n\r\n            globals.toolManager.tools['colorador'].mmb(id);\r\n        }\r\n\r\n        colorEl.oncontextmenu = () => {\r\n            // right button click\r\n            player.switchSecondColor(id);\r\n        }\r\n\r\n        palette.append(colorEl);\r\n    })\r\n}\r\n\r\n\r\nexport function showPatternsOnPalette() {\r\n    unloadPalettePatterns();\r\n\r\n    // just iterate through all colors\r\n    allColors.forEach(([r, g, b], i) => {\r\n        if(!$(`#col${i}`)[0]) return;\r\n        \r\n        const pat = patterns[i % patterns.length];\r\n\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = canvas.height = 14;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        ctx.fillStyle = hexPalette[i];\r\n\r\n        for (let i = 0; i < 7 * 7; i++) {\r\n            if (!pat[i]) continue;\r\n            const x = i % 7;\r\n            const y = i / 7 | 0;\r\n\r\n            ctx.fillRect(x * 2, y * 2, 2, 2);\r\n        }\r\n\r\n        function toI(x, y) {\r\n            return (x + y * 14) * 4;\r\n        }\r\n\r\n        // draw contour\r\n        let imd = ctx.getImageData(0, 0, 14, 14).data;\r\n        if (isDarkColor(r, g, b)) {\r\n            ctx.fillStyle = 'white';\r\n            let coords = [];\r\n            for (let x = 0; x < 14; x++) {\r\n                for (let y = 0; y < 14; y++) {\r\n                    if (imd[toI(x, y) + 3]) continue;\r\n\r\n                    const top = imd[toI(x, y - 1) + 3];\r\n                    const bottom = imd[toI(x, y + 1) + 3];\r\n                    const left = imd[toI(x - 1, y) + 3];\r\n                    const right = imd[toI(x + 1, y) + 3];\r\n\r\n                    const leftTop = imd[toI(x - 1, y - 1) + 3];\r\n                    const rightTop = imd[toI(x + 1, y - 1) + 3];\r\n                    const leftBottom = imd[toI(x - 1, y + 1) + 3];\r\n                    const rightBottom = imd[toI(x + 1, y + 1) + 3];\r\n\r\n                    if (top || bottom || left || right ||\r\n                        leftTop || rightTop || leftBottom || rightBottom) {\r\n                        ctx.fillRect(x, y, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        imd = ctx.getImageData(0, 0, 14, 14).data;\r\n        ctx.fillStyle = 'black';\r\n        for (let i = 0; i < 14 * 14; i++) {\r\n            if (!imd[i * 4 + 3])\r\n                ctx.fillRect(i % 14, i / 14 | 0, 1, 1);\r\n        }\r\n\r\n\r\n        const dataurl = canvas.toDataURL();\r\n        const img = document.createElement('img');\r\n        img.src = dataurl;\r\n        $(`#col${i}`).append(img);\r\n    });\r\n    $('.paletteColor').addClass('patternColor');\r\n}\r\n","import { fixChatPosition } from \"../Chat\";\nimport { topMenu } from \"./elements\";\n\nexport function toggleTopMenu() {\n    if (topMenu.css('display') === 'none') {\n        topMenu.show();\n        topMenu.css('margin-top', '');\n    } else {\n        topMenu.css('margin-top', -topMenu.height() - 30);\n        setTimeout(() => topMenu.hide(), 500);\n    }\n}\n\nexport function toggleEverything() {\n    // $('#ui>div>div').each((_, el) => {\n    //     if(el.style.getPropertyPriority('display') == 'important')\n    //         return;\n\n    //     if (el.style.display === 'none') {\n    //         $(el).css('display', '')\n    //     } else {\n    //         $(el).css('display', 'none')\n    //     }\n    // })\n    $('#ui').fadeToggle(100);\n    fixChatPosition();\n}\n\nexport function initMobileMenuToggler() {\n    $('.showMenu,.hideMenu').on('click', toggleTopMenu)\n}\n\n","import querystring from 'querystring'\n\nimport {\n    hexPalette,\n} from './config';\nimport camera from './camera';\nimport { generateTable } from './windows';\nimport Window from './Window';\nimport globals from './globals';\nimport me from './me';\n\n// import userImg from '../img/user2.png';\nimport userImg from '../img/user.svg';\nimport { ROLE, ROLE_I } from './constants';\nimport { translate as t } from './translate';\n\nimport modBadge from '../img/mod-badge.svg';\nimport adminBadge from '../img/admin-badge.svg';\nimport { htmlspecialchars } from './utils/misc';\nimport { apiRequest } from './utils/api';\nimport MiniWindow from './MiniWindow';\nimport { chatInput } from './ui/elements';\n\n// WARNING: this will work only if file names are not changed by webpack\nconst requireBadge = require.context('../img/badges', false, /\\.png$/);\nconst badgeLinks = {};\nrequireBadge.keys().map(requireBadge).forEach(path => {\n    const filename = path.default.match(/([\\w\\d_]+)\\.png$/);\n    badgeLinks[filename[1]] = path.default;\n});\n\n\nconst usersContainer = $('#usersTable');\n\nexport default class User {\n    // create user window from given object\n    // tempId is a temporary id for connection\n    static async CreateWindow(info, tempId) {\n        const win = new Window({\n            center: true,\n            title: `${info.name || t('PLAYER') + ' ' + (tempId || info.id)}`\n        });\n\n        // show everything by default\n        const htmlInfo = new Map();\n\n        if (info.registered) {\n            htmlInfo.set('name', htmlspecialchars(info.name));\n            htmlInfo.set('mail', htmlspecialchars(info.email));\n\n        }\n\n        htmlInfo.set('id', info.id || tempId);\n\n        if (info.ip) {\n            if (info.cc && info.cc !== 'XX') {\n                // adds a flag near the ip address\n\n                const cc = info.cc;\n                htmlInfo.set('ip', info.ip + ` [${cc}]`);\n                htmlInfo.set('ip', htmlInfo.get('ip') + `<img src=\"${location.protocol}//flagcdn.com/h20/${cc.toLowerCase()}.png\" style=\"margin-left:1px;height:13px;\">`);\n            } else {\n                htmlInfo.set('ip', info.ip);\n            }\n        }\n\n        htmlInfo.set('role', info.role);\n\n        // allowing role/badge change \n        if (info.role !== undefined && me.role === ROLE.ADMIN) {\n            if (me.id !== info.id) {\n                const role = info.role;\n                let str = '';\n                Object.keys(ROLE).forEach(text => {\n                    // now bans are through the special menu\n                    if (text === 'BANNED') return;\n\n                    str += `<option ${(text === role) ? 'selected' : ''}>${text}</option>`;\n                })\n                info.role = role ? ROLE[role] : null;\n\n                htmlInfo.set('role', `<select type=\"role\">${str}</select>`);\n            }\n\n            const badges = info.badges || [];\n            requestAnimationFrame(() => {\n                badges.forEach(badge => addBadge(badge.name));\n            });\n\n            let badgesCont = $(`<div class=\"badgesList\"></div><button class=\"addBadgeBtn\" title=\"Add Badge\">+</button>`);\n            htmlInfo.set('badges', badgesCont.map(function () {\n                return this.outerHTML;\n            }).get().join(''));\n        }\n\n        let infoArr = [...htmlInfo.keys(htmlInfo)].map(key => [key, htmlInfo.get(key)]), misc = [];\n        infoArr = infoArr.filter(([k, v]) => !!v);\n\n        if (me.role >= ROLE.MOD) {\n            misc = [\n                [`<input class=\"alertInput\">`, `<button class=\"sendAlert\">${t('btn.sendAlert')}</button>`],\n                [`<input class=\"modalInput\">`, `<button class=\"sendModal\">${t('btn.sendModal')}</button>`]\n            ];\n            if (info.bannedUntil) {\n                misc.push([t('label.bannedUntil'), info.bannedUntil]);\n            }\n            if (me.id !== info.id) {\n                if (info.role) {\n                    misc.push([`<button class=\"openBanMenu\">${t('ban_menu')}</button>`]);\n                } else {\n                    // ip ban is only for guests\n                    misc.push([`<button class=\"banByIp\">${t('Ban by ip')}</button>`]);\n                }\n            }\n        }\n\n        let together = infoArr.concat(misc);\n\n        $(win.body).append(generateTable(together));\n\n        $('select[type=role]', win.body).on('change', async e => {\n            const role = e.target.value,\n                userId = info.id;\n            const resp = await fetch('/api/admin/changerole', {\n                method: 'POST',\n                body: JSON.stringify({\n                    id: userId,\n                    role\n                }),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            const body = await resp.json();\n            if (body.errors) {\n                body.errors.forEach(error => {\n                    toastr.error(error, t('ERROR'));\n                })\n            } else {\n                toastr.success(t('Changed role to') + ' ' + role);\n            }\n        })\n\n\n        $('.sendAlert', win.body).on('click', () => {\n            const val = $('.alertInput', win.body).val();\n\n            if (val.length == 0) return;\n\n            $('.alertInput', win.body).val('');\n            globals.socket.sendAlert(tempId, val);\n        });\n\n        $('.sendModal', win.body).on('click', () => {\n            const val = $('.modalInput', win.body).val();\n\n            if (val.length == 0) return;\n\n            $('.modalInput', win.body).val('');\n            globals.socket.sendAlert(tempId, val, true);\n        });\n\n        $('.banByIp', win.body).on('click', async () => {\n            const ip = info.ip;\n            if (!ip) return toastr.error(t('No ip!'));\n\n            const miniWindow = new MiniWindow(``, 2);\n            const banMenuContents = $(\n                '<div>'+\n                `0= <input type=\"number\" class=\"bannedUntilNum\" value=\"0\" min=\"0\">` +\n                `<select class=\"bannedUntilMult\">\n                    <option value=\"${1000 * 60}\">${t('time.minute')}</option>\n                    <option value=\"${1000 * 60 * 60}\">${t('time.hour')}</option>\n                    <option value=\"${1000 * 60 * 60 * 24}\">${t('time.day')}</option>\n                </select>`+\n                '<div>'\n            );\n\n            const untilNum = $('.bannedUntilNum', banMenuContents);\n            const untilMulti = $('.bannedUntilMult', banMenuContents);\n\n            miniWindow.on('okClicked', () => {\n                const untilNumValue = untilNum.val();\n                const untilMultiValue = new Number(untilMulti.val());\n\n                const untilDate = new Date(Date.now() + untilNumValue * untilMultiValue);\n\n                const ipBanParams = { ip };\n                if (untilNumValue > 0) {\n                    ipBanParams['until'] = untilDate.toISOString();\n                }\n                apiRequest(`/admin/ban/byIp?${querystring.stringify(ipBanParams)}`);\n            });\n\n            miniWindow.bodyElement.append(banMenuContents);\n            $(document.body).append(miniWindow.element);\n\n            setTimeout(() => miniWindow.center());\n        });\n\n        $('.openBanMenu', win.body).on('click', async () => {\n            const miniWindow = new MiniWindow(`${t('ban_menu_for')} ${htmlspecialchars(info.name)}`, 2);\n            const banMenuContents = $(\n                `<input type=\"checkbox\" id=\"${info.id}-shadow-cb\" class=\"shadowCheckbox\" ${info.shadowBanned ? 'checked' : ''}>` +\n                `<label for=\"${info.id}-shadow-cb\">${t('label.shadowBanned')}</label><br>` +\n\n                `<input type=\"checkbox\" id=\"${info.id}-banned-cb\" class=\"bannedCheckbox\" ${info.role === 'BANNED' ? 'checked' : ''}>` +\n                `<label for=\"${info.id}-banned-cb\">${t('label.banned')}</label><br>` +\n\n                `0= <input type=\"number\" id=\"${info.id}-until-number\" class=\"bannedUntilNum\" value=\"0\" min=\"0\">` +\n                `<select id=\"${info.id}-until-multiplier\" class=\"bannedUntilMult\">\n                    <option value=\"${1000 * 60}\">${t('time.minute')}</option>\n                    <option value=\"${1000 * 60 * 60}\">${t('time.hour')}</option>\n                    <option value=\"${1000 * 60 * 60 * 24}\">${t('time.day')}</option>\n                </select>`\n            );\n            miniWindow.bodyElement.append(banMenuContents);\n            $(document.body).append(miniWindow.element);\n\n\n            const chadowCb = $('.shadowCheckbox', miniWindow.element);\n            const banCb = $('.bannedCheckbox', miniWindow.element);\n            const untilNum = $('.bannedUntilNum', miniWindow.element);\n            const untilMulti = $('.bannedUntilMult', miniWindow.element);\n\n            miniWindow.on('okClicked', () => {\n                const shadowChecked = chadowCb.is(':checked');\n                const banChecked = banCb.is(':checked');\n                const untilNumValue = untilNum.val();\n                const untilMultiValue = new Number(untilMulti.val());\n\n                const untilDate = new Date(Date.now() + untilNumValue * untilMultiValue);\n\n                const vastBanParams = {\n                    uid: info.id,\n                    banned: banChecked\n                };\n                if (untilNumValue > 0) {\n                    vastBanParams['until'] = untilDate.toISOString();\n                }\n                apiRequest(`/admin/ban?${querystring.stringify(vastBanParams)}`);\n\n                const shadowBanParams = {\n                    uid: info.id,\n                    banned: shadowChecked\n                };\n                if (untilNumValue > 0) {\n                    shadowBanParams['until'] = untilDate.toISOString();\n                }\n                apiRequest(`/admin/ban/shadow?${querystring.stringify(shadowBanParams)}`);\n            });\n\n\n            setTimeout(() => miniWindow.center());\n\n        });\n\n        $('.addBadgeBtn', win.body).on('click', async () => {\n            const subwindow = new Window({\n                title: 'Badges for ' + info.id,\n                x: win.x + win.width + 5,\n                y: win.y\n            });\n            if (!subwindow.created) return;\n\n            subwindow.body.style.display = 'flex';\n            subwindow.body.style.gap = '2px';\n\n            for (const [badgeName, badgeLink] of Object.entries(badgeLinks)) {\n                const badgeImg = $(`<div style=\"padding: 3px; background: gray; border-radius: 4px; max-width: fit-content;\">\n                <img src=\"${badgeLink}\">\n                </div>`);\n                badgeImg.on('click', () => {\n                    apiRequest(`/badges/add?userId=${info.id}&badge=${badgeName}`, { method: 'POST' }).then(async resp => {\n                        if (!(await resp.json()).ok) return;\n\n                        addBadge(badgeName);\n                    });\n                });\n                $(subwindow.body).append(badgeImg);\n            }\n        });\n\n        function addBadge(badgeName) {\n            const badgeHtml = $(`<div class=\"badge\" title=\"${badgeName}\">\n                            <img src=\"${badgeLinks[badgeName]}\" alt=\"${badgeName}\">\n                        </div>`);\n            $('.badgesList', win.body).append(badgeHtml);\n\n            badgeHtml.on('click', () => {\n                apiRequest(`/badges/del?userId=${info.id}&badge=${badgeName}`, { method: 'POST' }).then(async resp => {\n                    if (!(await resp.json()).ok) return;\n\n                    badgeHtml.remove();\n                });\n            });\n        }\n    }\n\n\n    constructor(name, id, userId, registered, role, badges = null) {\n        if (!name) name = 'ID ' + id;\n\n        this.name = name;\n        this.id = id;\n        this.userId = userId;\n\n        this.registered = registered;\n\n        this.role = role;\n\n        this.conns = [id];\n\n        this.badges = badges;\n\n\n        const safeName = htmlspecialchars(this.name);\n        let displayName = globals.chat.parseColors(safeName).replace(/<[^>]*>/g, '');\n\n        const roleBadgeProps = this.getRoleBadgeAndTitle();\n\n        this.element = $(\n            `<tr class=\"tableRow\">\n                <td title=\"id ${id}\" class=\"user\">\n                    ${roleBadgeProps ? `<img src=\"${roleBadgeProps.icon}\" title=\"${roleBadgeProps.tooltip}\" class=\"roleBadge\">` : ''}\n                    <button class=\"userInfoBtn minrole-trusted\"><img style=\"height: 20px\" src=\"${userImg}\"></button>\n                    <span class=\"name\">${displayName}</span>\n                    <span class=\"badges\"></span>\n                    <span class=\"xConns\"></span>\n                </td>\n                <td></td>\n            </tr>`);\n\n        this.nameEl = $('.name', this.element);\n        this.coordsEl = $(this.element.children()[1]);\n\n        this.nameEl.on('click', function () {\n            const visibleNick = this.innerText;\n            chatInput[0].value += visibleNick + ', ';\n            chatInput.trigger('focus');\n        })\n\n\n        $('.userInfoBtn', this.element).on('click', async () => {\n            const isReg = this.registered;\n            const id = isReg ? this.userId : this.id;\n\n            const req = await fetch(`/api/userInfo?id=${id}${isReg ? '' : '&unreg=1'}`);\n            const info = await req.json();\n            await User.CreateWindow(info, this.id);\n        });\n\n        this.coordsEl.on('click', () => {\n            const [x, y] = this.coordsEl.text()\n                .slice(1, -1)\n                .split(', ')\n                .map(x => parseInt(x, 10));\n\n            if (Number.isInteger(x) && Number.isInteger(y)){\n                camera.centerOn(x, y);\n            }\n        })\n\n        usersContainer[0].appendChild(this.element[0]);\n\n        me.updateRoleRelatedHtml();\n    }\n\n    async loadBadges() {\n        if (this.userId === null) return;\n\n        const resp = await apiRequest(`/userInfo/badges?id=${this.userId}`);\n        const badges = await resp.json();\n        this.badges = badges;\n    }\n\n    updateBadges() {\n        $('.badges', this.element).append(this.getAchieveBadgesHtml());\n    }\n\n    getAchieveBadgesHtml() {\n        if (!this.badges) return '';\n\n        let html = '';\n        for (let badge of this.badges) {\n            const {\n                name, width, height\n            } = badge;\n\n            const customWidth = width ? `width: ${width}px;` : '';\n            const customHeight = height ? `height: ${height}px;` : '';\n\n            html += `<img src=\"${badgeLinks[name]}\" style=\"${customWidth}${customHeight}\">`;\n        }\n        return html\n    }\n\n    getRoleBadgeAndTitle() {\n        if (!this.role) return null;\n\n        let tooltip, icon;\n\n        switch (this.role) {\n            case 'MOD':\n                tooltip = 'mod';\n                icon = modBadge;\n                break\n            case 'ADMIN':\n                tooltip = 'admin';\n                icon = adminBadge;\n                break\n            default:\n                return null\n        }\n\n        // if (this.userId == 1) {\n        //     tooltip = 'creator';\n        //     icon = creatorBadge;\n        // }\n\n        return {\n            tooltip,\n            icon\n        }\n    }\n\n    updateCoords(color, x, y) {\n        this.coordsEl.css('color', hexPalette[color]);\n        this.coordsEl.text(`(${x}, ${y})`);\n    }\n\n    close(clientId) {\n        this.conns.splice(this.conns.indexOf(clientId), 1);\n        if (this.conns.length === 0)\n            this.destroy();\n        else\n            this.updateX();\n\n        delete globals.users[clientId]\n    }\n\n    destroy() {\n        this.element.remove();\n    }\n\n    newConnection(clientId) {\n        this.conns.push(clientId);\n        this.updateX();\n    }\n\n    updateX() {\n        const text = (this.conns.length > 1) ? `[x${this.conns.length}]` : '';\n        $('.xConns', this.element).text(text);\n    }\n}","import camera from '../camera';\nimport { halfMap } from './misc';\nimport { boardToScreenSpace, screenToBoardSpace } from './conversions';\nimport {\n    chunkSize,\n    boardChunkWid,\n    boardChunkHei,\n    boardWidth,\n    boardHeight\n} from '../config';\n\nexport function isAreaVisible(x, y, w, h) {\n    const [x1, y1] = boardToScreenSpace(x, y);\n    const [x2, y2] = boardToScreenSpace(x + w, y + h);\n\n    return x1 < window.innerWidth && x2 >= 0 && y1 < window.innerHeight && y2 >= 0;\n}\n\nexport function isChunkVisible(cx, cy) {\n    return isAreaVisible(cx * chunkSize, cy * chunkSize, chunkSize, chunkSize);\n}\n\nexport function getVisibleChunks() {\n    // todo rework it\n    // rn it checks left top chunk and right bottom chunk\n\n    let [sx, sy] = screenToBoardSpace(0, 0);\n    let [ex, ey] = screenToBoardSpace(window.innerWidth, window.innerHeight);\n\n\n    let startX = sx / chunkSize | 0, // math floor\n        endX = ex / chunkSize + 1 | 0; // math ceil\n\n    let startY = sy / chunkSize | 0,\n        endY = ey / chunkSize + 1 | 0;\n\n    let arr = []\n    for (let x = Math.max(startX, 0); x < Math.min(endX, boardChunkWid); x++) {\n        for (let y = Math.max(startY, 0); y < Math.min(endY, boardChunkHei); y++) {\n            arr.push([x, y]);\n        }\n    }\n\n    return arr\n}\n\nexport function inBounds(x, y) {\n    if (x < 0 || x >= boardWidth || y < 0 || y >= boardHeight) return false;\n    return true;\n}","import camera from '../camera';\nimport globals from '../globals';\nimport {\n    halfMap\n} from './misc';\nimport {\n    chunkSize\n} from '../config';\n\nexport function screenToBoardSpace(clientX, clientY, rounded = true) {\n    let screenOffsetX = (clientX - (globals.renderer.canvas.width >> 1)) / camera.zoom;\n    let screenOffsetY = (clientY - (globals.renderer.canvas.height >> 1)) / camera.zoom;\n\n    let boardOffsetX = camera.x + halfMap[0];\n    let boardOffsetY = camera.y + halfMap[1];\n\n    let x = boardOffsetX + screenOffsetX,\n        y = screenOffsetY + boardOffsetY;\n\n    if (rounded) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n    }\n\n    return [x, y]\n}\n\nexport function boardToScreenSpace(x, y, round=true) {\n    x -= camera.x + halfMap[0];\n    y -= camera.y + halfMap[1];\n\n    x *= camera.zoom;\n    y *= camera.zoom;\n\n    x += globals.renderer.canvas.width / 2; // x >> 1 = x / 2\n    y += globals.renderer.canvas.height / 2;\n\n    if(round){\n        x = Math.floor(x);\n        y = Math.floor(y);\n    }\n\n    return [x, y]\n}\n\nexport function boardToChunk(x, y) {\n    let cx = x / chunkSize | 0;\n    let cy = y / chunkSize | 0;\n\n    let offx = x % chunkSize;\n    let offy = y % chunkSize;\n\n    return [\n        cx,\n        cy,\n        offx,\n        offy\n    ]\n}\n\nexport function chunkToBoard(cx, cy, offx, offy) {\n    return [cx * chunkSize + offx, cy * chunkSize + offy]\n}","export default {\n    \"ALICEBLUE\": \"#F0F8FF\",\n    \"ANTIQUEWHITE\": \"#FAEBD7\",\n    \"AQUA\": \"#00FFFF\",\n    \"AQUAMARINE\": \"#7FFFD4\",\n    \"AZURE\": \"#F0FFFF\",\n    \"BEIGE\": \"#F5F5DC\",\n    \"BISQUE\": \"#FFE4C4\",\n    \"BLACK\": \"#000000\",\n    \"BLANCHEDALMOND\": \"#FFEBCD\",\n    \"BLUE\": \"#0000FF\",\n    \"BLUEVIOLET\": \"#8A2BE2\",\n    \"BROWN\": \"#A52A2A\",\n    \"BURLYWOOD\": \"#DEB887\",\n    \"CADETBLUE\": \"#5F9EA0\",\n    \"CHARTREUSE\": \"#7FFF00\",\n    \"CHOCOLATE\": \"#D2691E\",\n    \"CORAL\": \"#FF7F50\",\n    \"CORNFLOWERBLUE\": \"#6495ED\",\n    \"CORNSILK\": \"#FFF8DC\",\n    \"CRIMSON\": \"#DC143C\",\n    \"CYAN\": \"#00FFFF\",\n    \"DARKBLUE\": \"#00008B\",\n    \"DARKCYAN\": \"#008B8B\",\n    \"DARKGOLDENROD\": \"#B8860B\",\n    \"DARKGRAY\": \"#A9A9A9\",\n    \"DARKGREY\": \"#A9A9A9\",\n    \"DARKGREEN\": \"#006400\",\n    \"DARKKHAKI\": \"#BDB76B\",\n    \"DARKMAGENTA\": \"#8B008B\",\n    \"DARKOLIVEGREEN\": \"#556B2F\",\n    \"DARKORANGE\": \"#FF8C00\",\n    \"DARKORCHID\": \"#9932CC\",\n    \"DARKRED\": \"#8B0000\",\n    \"DARKSALMON\": \"#E9967A\",\n    \"DARKSEAGREEN\": \"#8FBC8F\",\n    \"DARKSLATEBLUE\": \"#483D8B\",\n    \"DARKSLATEGRAY\": \"#2F4F4F\",\n    \"DARKSLATEGREY\": \"#2F4F4F\",\n    \"DARKTURQUOISE\": \"#00CED1\",\n    \"DARKVIOLET\": \"#9400D3\",\n    \"DEEPPINK\": \"#FF1493\",\n    \"DEEPSKYBLUE\": \"#00BFFF\",\n    \"DIMGRAY\": \"#696969\",\n    \"DIMGREY\": \"#696969\",\n    \"DODGERBLUE\": \"#1E90FF\",\n    \"FIREBRICK\": \"#B22222\",\n    \"FLORALWHITE\": \"#FFFAF0\",\n    \"FORESTGREEN\": \"#228B22\",\n    \"FUCHSIA\": \"#FF00FF\",\n    \"GAINSBORO\": \"#DCDCDC\",\n    \"GHOSTWHITE\": \"#F8F8FF\",\n    \"GOLD\": \"#FFD700\",\n    \"GOLDENROD\": \"#DAA520\",\n    \"GRAY\": \"#808080\",\n    \"GREY\": \"#808080\",\n    \"GREEN\": \"#008000\",\n    \"GREENYELLOW\": \"#ADFF2F\",\n    \"HONEYDEW\": \"#F0FFF0\",\n    \"HOTPINK\": \"#FF69B4\",\n    \"INDIANRED\": \"#CD5C5C\",\n    \"INDIGO\": \"#4B0082\",\n    \"IVORY\": \"#FFFFF0\",\n    \"KHAKI\": \"#F0E68C\",\n    \"LAVENDER\": \"#E6E6FA\",\n    \"LAVENDERBLUSH\": \"#FFF0F5\",\n    \"LAWNGREEN\": \"#7CFC00\",\n    \"LEMONCHIFFON\": \"#FFFACD\",\n    \"LIGHTBLUE\": \"#ADD8E6\",\n    \"LIGHTCORAL\": \"#F08080\",\n    \"LIGHTCYAN\": \"#E0FFFF\",\n    \"LIGHTGOLDENRODYELLOW\": \"#FAFAD2\",\n    \"LIGHTGRAY\": \"#D3D3D3\",\n    \"LIGHTGREY\": \"#D3D3D3\",\n    \"LIGHTGREEN\": \"#90EE90\",\n    \"LIGHTPINK\": \"#FFB6C1\",\n    \"LIGHTSALMON\": \"#FFA07A\",\n    \"LIGHTSEAGREEN\": \"#20B2AA\",\n    \"LIGHTSKYBLUE\": \"#87CEFA\",\n    \"LIGHTSLATEGRAY\": \"#778899\",\n    \"LIGHTSLATEGREY\": \"#778899\",\n    \"LIGHTSTEELBLUE\": \"#B0C4DE\",\n    \"LIGHTYELLOW\": \"#FFFFE0\",\n    \"LIME\": \"#00FF00\",\n    \"LIMEGREEN\": \"#32CD32\",\n    \"LINEN\": \"#FAF0E6\",\n    \"MAGENTA\": \"#FF00FF\",\n    \"MAROON\": \"#800000\",\n    \"MEDIUMAQUAMARINE\": \"#66CDAA\",\n    \"MEDIUMBLUE\": \"#0000CD\",\n    \"MEDIUMORCHID\": \"#BA55D3\",\n    \"MEDIUMPURPLE\": \"#9370DB\",\n    \"MEDIUMSEAGREEN\": \"#3CB371\",\n    \"MEDIUMSLATEBLUE\": \"#7B68EE\",\n    \"MEDIUMSPRINGGREEN\": \"#00FA9A\",\n    \"MEDIUMTURQUOISE\": \"#48D1CC\",\n    \"MEDIUMVIOLETRED\": \"#C71585\",\n    \"MIDNIGHTBLUE\": \"#191970\",\n    \"MINTCREAM\": \"#F5FFFA\",\n    \"MISTYROSE\": \"#FFE4E1\",\n    \"MOCCASIN\": \"#FFE4B5\",\n    \"NAVAJOWHITE\": \"#FFDEAD\",\n    \"NAVY\": \"#000080\",\n    \"OLDLACE\": \"#FDF5E6\",\n    \"OLIVE\": \"#808000\",\n    \"OLIVEDRAB\": \"#6B8E23\",\n    \"ORANGE\": \"#FFA500\",\n    \"ORANGERED\": \"#FF4500\",\n    \"ORCHID\": \"#DA70D6\",\n    \"PALEGOLDENROD\": \"#EEE8AA\",\n    \"PALEGREEN\": \"#98FB98\",\n    \"PALETURQUOISE\": \"#AFEEEE\",\n    \"PALEVIOLETRED\": \"#DB7093\",\n    \"PAPAYAWHIP\": \"#FFEFD5\",\n    \"PEACHPUFF\": \"#FFDAB9\",\n    \"PERU\": \"#CD853F\",\n    \"PINK\": \"#FFC0CB\",\n    \"PLUM\": \"#DDA0DD\",\n    \"POWDERBLUE\": \"#B0E0E6\",\n    \"PURPLE\": \"#800080\",\n    \"REBECCAPURPLE\": \"#663399\",\n    \"RED\": \"#FF0000\",\n    \"ROSYBROWN\": \"#BC8F8F\",\n    \"ROYALBLUE\": \"#4169E1\",\n    \"SADDLEBROWN\": \"#8B4513\",\n    \"SALMON\": \"#FA8072\",\n    \"SANDYBROWN\": \"#F4A460\",\n    \"SEAGREEN\": \"#2E8B57\",\n    \"SEASHELL\": \"#FFF5EE\",\n    \"SIENNA\": \"#A0522D\",\n    \"SILVER\": \"#C0C0C0\",\n    \"SKYBLUE\": \"#87CEEB\",\n    \"SLATEBLUE\": \"#6A5ACD\",\n    \"SLATEGRAY\": \"#708090\",\n    \"SLATEGREY\": \"#708090\",\n    \"SNOW\": \"#FFFAFA\",\n    \"SPRINGGREEN\": \"#00FF7F\",\n    \"STEELBLUE\": \"#4682B4\",\n    \"TAN\": \"#D2B48C\",\n    \"TEAL\": \"#008080\",\n    \"THISTLE\": \"#D8BFD8\",\n    \"TOMATO\": \"#FF6347\",\n    \"TURQUOISE\": \"#40E0D0\",\n    \"VIOLET\": \"#EE82EE\",\n    \"WHEAT\": \"#F5DEB3\",\n    \"WHITE\": \"#FFFFFF\",\n    \"WHITESMOKE\": \"#F5F5F5\",\n    \"YELLOW\": \"#FFFF00\",\n    \"YELLOWGREEN\": \"#9ACD32\"\n}","export function mod(n, m) {\n    return ((n % m) + m) % m;\n}\n\nexport function dist(x1, y1, x2, y2) {\n    return Math.hypot(x2 - x1, y2 - y1)\n}\n\nexport function avrg(...values) {\n    return values.reduce((a, b) => a + b) / values.length\n}\n\nexport function mapRange(value, inputMin, inputMax, outputMin, outputMax) {\n    return (value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin) + outputMin;\n}\n\nexport function clamp(value, min, max){\n    return Math.max(Math.min(value, max), min)\n}","import { canvasName } from '../config';\r\nimport globals from '../globals';\r\nimport { curHistoryCanvasUrl } from '../history';\r\nimport { getPathsafeDate } from './misc';\r\n\r\n\r\nexport function makeScreenshot() {\r\n    let canvas = globals.chunkManager.dumpAll();    \r\n    let href = curHistoryCanvasUrl ?? canvas.toDataURL()\r\n    \r\n    const link = document.createElement('a');\r\n    link.download = `GX ${canvasName} ${getPathsafeDate()}.png`;\r\n    link.href = href;\r\n    link.click();\r\n    link.remove();\r\n}\r\n","export default {\n    line: function (x, y, x2, y2) {\n        let pointArr = [];\n\n        let steep = Math.abs(y2 - y) > Math.abs(x2 - x);\n        if (steep) {\n            [x, y] = [y, x];\n            [x2, y2] = [y2, x2];\n        }\n        let reverseFlag = false;\n        if (x > x2) {\n            [y, y2] = [y2, y];\n            [x, x2] = [x2, x];\n            reverseFlag = true;\n        }\n        let dist = {\n            x: x2 - x,\n            y: Math.abs(y2 - y)\n        }\n        let err = dist.x / 2;\n        let stepY = (y < y2) ? 1 : -1;\n        for (; x <= x2; x++) {\n            pointArr.push([steep ? y : x, steep ? x : y]);\n            err -= dist.y;\n            if (err < 0) {\n                y += stepY;\n                err += dist.x;\n            }\n        }\n        if (reverseFlag) pointArr.reverse();\n\n        pointArr.reverse();\n\n        return pointArr;\n    },\n\n    filledCircle: function (centerX, centerY, r) {\n        let pixels = [];\n\n        const squareR = r * r;\n\n        for (let _x = -r + centerX; _x < r + centerX; _x++) {\n            for (let _y = -r + centerY; _y < r + centerY; _y++) {\n                if (isIn(_x, _y)) {\n                    pixels.push([_x, _y])\n                }\n            }\n        }\n\n        function isIn(_x, _y) {\n            let dx = _x - centerX,\n                dy = _y - centerY;\n\n            if (dx * dx + dy * dy <= squareR * 0.8)\n                return true\n            return false\n        }\n\n        return pixels\n    },\n\n    square(x1, y1, x2, y2) {\n        const minX = Math.min(x1, x2),\n            minY = Math.min(y1, y2),\n            maxX = Math.max(x1, x2),\n            maxY = Math.max(y1, y2);\n\n        let pixels = [];\n        for (let y = minY; y < maxY+1; y++) {\n            for (let x = minX; x < maxX+1; x++) {\n                pixels.push([x, y]);\n            }\n        }\n\n        return pixels\n    }\n}","export function capitalize(str) {\n    return str.replace(\n      /[-\\w]+/g,\n      function(txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n      }\n    );\n  }","export function createWebGLProgram(canvas, vertexSrc, fragmentSrc) {\n    let gl;\n    if(canvas instanceof WebGLRenderingContext){\n        gl = canvas;\n    }else{\n        gl = canvas.getContext('webgl');\n        if (!gl) throw new Error(\"WebGL is not supported\");\n    }\n\n    function compileShader(type, src) {\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            console.error(gl.getShaderInfoLog(shader));\n            throw new Error(\"Shader compilation error\");\n        }\n        return shader;\n    }\n\n    const vs = compileShader(gl.VERTEX_SHADER, vertexSrc);\n    const fs = compileShader(gl.FRAGMENT_SHADER, fragmentSrc);\n\n    const program = gl.createProgram();\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        console.error(gl.getProgramInfoLog(program));\n        throw new Error(\"GL linking error\");\n    }\n\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1, -1, 1, -1, -1, 1,\n        -1, 1, 1, -1, 1, 1\n    ]), gl.STATIC_DRAW);\n\n    const posLoc = gl.getAttribLocation(program, \"a_position\");\n    gl.enableVertexAttribArray(posLoc);\n    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);\n\n    return { gl, program };\n}\n\nexport function createTexture(gl, sourceCanvas) {\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,\n                  gl.UNSIGNED_BYTE, sourceCanvas);\n\n    return texture;\n}\nconst defaultVertexShader = `\n        attribute vec2 a_position;\n        varying vec2 v_texCoord;\n        void main() {\n            v_texCoord = (a_position + 1.0) * 0.5;\n            // y is inverted\n            v_texCoord.y = 1.0 - v_texCoord.y;\n            gl_Position = vec4(a_position, 0.0, 1.0);\n        }\n        `\nexport function generateShader(canvas, fragmentShader, needCreateTexture=true) {\n    const { gl, program } = createWebGLProgram(canvas, defaultVertexShader, fragmentShader);\n\n    let texture;\n    if(needCreateTexture){\n        texture = createTexture(gl, canvas);\n    }\n\n    gl.useProgram(program);\n\n    return { gl, program, texture };\n}\n\nconst testCanvas = document.createElement('canvas');\ntestCanvas.width = testCanvas.height = 1;\nconst glCtx = testCanvas.getContext('webgl');\n\nexport const MAX_TEX_SIZE = glCtx.getParameter(glCtx.MAX_TEXTURE_SIZE);","import { getLS, setLS } from '../utils/localStorage';\nimport { loadImage } from '../utils/misc';\nimport globals from '../globals';\nimport { boardToScreenSpace, screenToBoardSpace } from '../utils/conversions';\nimport { FX } from '../fxcanvas';\nimport { clamp, mapRange } from '../utils/math';\nimport camera from '../camera';\nimport player from '../player';\n\nimport winampFontPng from '../../font/pixel/winamp.png';\nimport winampFontDesc from '../../font/pixel/winamp.txt';\n\nimport startBtnImg from '../../img/winamp/enableRadioBtn.png';\nimport { apiRequest } from '../utils/api';\nimport { PixelFont } from '../tools/text.js';\n\n\nasync function importMaterials() {\n    require.context('../../img/winamp', false, /\\.png$/)\n    const images = {\n        bg: await import('../../img/winamp/bg2.png'),\n        hrSlider: await import('../../img/winamp/hr-slider-btn-small.png'),\n        hrSliderBig: await import('../../img/winamp/slider-btn.png'),\n        digits: await import('../../img/winamp/digits.png'),\n    }\n\n    const wFont = new PixelFont(winampFontPng, winampFontDesc);\n    await wFont.load();\n\n    return {\n        images,\n        fonts: {\n            winamp: wFont\n        }\n    }\n}\n\nclass UIRect {\n    constructor(x, y, w, h) {\n        Object.assign(this, {\n            x, y, w, h\n        });\n    }\n}\n\nlet tempColors;\nfunction preserveColors() {\n    tempColors = [player.color, player.secondCol];\n\n    player.switchColor(-1);\n    player.switchSecondColor(-1);\n}\nfunction restoreColors() {\n    player.switchColor(tempColors[0]);\n    player.switchSecondColor(tempColors[1]);\n}\n\nexport function initRadio() {\n    const player = new WinampPlayer();\n    player.init();\n    window.wPlayer = player;\n}\n\nlet documentClicked = false, onDocumentClickCallbacks = [];\ndocument.addEventListener('click', () => {\n    documentClicked = true;\n\n    onDocumentClickCallbacks.forEach(cb => cb());\n    onDocumentClickCallbacks.length = 0;\n})\n\nexport async function createRadioStarterBtn() {\n    const btnImg = await loadImage(startBtnImg);\n    const bW = btnImg.width;\n    const bH = btnImg.height;\n\n    const bX = -btnImg.width - 5;\n    const bY = 0;\n\n    function renderBtn(ctx) {\n        const z = camera.zoom;\n        const [canvasX, canvasY] = boardToScreenSpace(bX, bY);\n\n        if (this.needRender)\n            this.redraw();\n\n        ctx.save();\n        ctx.scale(z, z);\n        ctx.drawImage(btnImg, canvasX / z, canvasY / z);\n        ctx.restore();\n\n        return 1;\n    }\n\n    let btnFx = new FX(renderBtn);\n    globals.fxRenderer.add(btnFx, 2);\n\n    let mousedownAt = 0, listeners = [];\n    function onMousedown(e) {\n        const boardPos = screenToBoardSpace(e.clientX, e.clientY);\n        if (checkIsButtonPos(...boardPos)) {\n            mousedownAt = Date.now();\n        }\n    }\n\n    async function onMouseup(e) {\n        const boardPos = screenToBoardSpace(e.clientX, e.clientY);\n        if (checkIsButtonPos(...boardPos)) {\n            if (Date.now() - mousedownAt < 500) {\n                await onBtnClick();\n            }\n        }\n    }\n\n    globals.eventManager.on('mousedown', onMousedown);\n    globals.eventManager.on('mouseup', onMouseup);\n\n    listeners.push(['mousedown', onMousedown]);\n    listeners.push(['mouseup', onMouseup]);\n\n    function removeBtn() {\n        if (btnFx) {\n            globals.fxRenderer.remove(btnFx);\n            btnFx = null;\n        }\n        for (const [ev, fn] of listeners) {\n            globals.eventManager.off(ev, fn);\n        }\n        listeners = [];\n    }\n\n    async function onBtnClick() {\n        removeBtn();\n\n        initRadio();\n    }\n\n    function checkIsButtonPos(x, y) {\n        return x >= bX && x < bX + bW && y >= bY && y < bY + bH;\n    }\n}\n\nclass WinampPlayer {\n    constructor() {\n        this.canvas = document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n\n        this.playerPosition = JSON.parse(getLS('winamp.position', true) || '[-275,0]');\n        this.sndBalance = 0; // -1; 1\n        this.volumeLvl = +(getLS('winamp.volume', true) || '0.5'); // 0; 1\n\n        this.queue = null;\n        this.currentTrack = null;\n\n        this.images = null;\n        this.needRender = true;\n\n        this.startPolling();\n\n        this.config = {\n            width: 275,\n            height: 348,\n            headerRect: new UIRect(2, 2, 262, 12),\n            closeBtnRect: new UIRect(265, 4, 7, 7),\n            volumeBoundsRect: new UIRect(108, 61, 63, 4),\n            soundBalanceBoundsRect: new UIRect(178, 61, 35, 4),\n            volumeSliderRect: new UIRect(-1, -1, -1, -1),\n            balanceSliderRect: new UIRect(-1, -1, -1, -1),\n            titleRect: new UIRect(111, 24, 155, 12),\n            kbpsRect: new UIRect(111, 41, 16, 10),\n            khzRect: new UIRect(156, 41, 11, 10),\n            mm1Rect: new UIRect(48, 26, 9, 13),\n            mm2Rect: new UIRect(60, 26, 9, 13),\n            ss1Rect: new UIRect(78, 26, 9, 13),\n            ss2Rect: new UIRect(90, 26, 9, 13),\n            progressSliderBndRect: new UIRect(16, 72, 249, 10),\n            queueBoxRect: new UIRect(18, 257, 238, 48)\n        }\n\n        this._cache = {};\n        this._holdingButton = null;\n        this._lastHoldPos = null;\n        this._destroyed = false;\n        this.noFeed = false;\n        this.title = null;\n        this.visibleTitle = null;\n\n        this._boundHandlers = {};\n        this._socketHandlers = {};\n    }\n\n    addAudioStoppedListeners() {\n        this.audio.addEventListener(\"pause\", () => {\n            // controls are disabled, but you can still\n            // press \"pause/play\" button and it will stop\n            // the player. this is not good because the \n            // whole radio will be screwed\n            if (!this.audio._destroyed) {\n                this.audio.play().catch(err => {\n                    console.warn(\"Resume blocked until user interaction:\", err);\n                });\n            }\n        });\n\n        this.audio.addEventListener(\"stalled\", () => {\n            console.warn(\"Stream stalled\");\n            this.restartStream();\n        });\n\n        this.audio.addEventListener(\"error\", (e) => {\n            console.error(\"Audio error\", e);\n            this.restartStream();\n        });\n\n        this.audio.addEventListener(\"ended\", () => {\n            console.warn(\"Stream ended\");\n            this.restartStream();\n        });\n    }\n\n    async init() {\n        setLS('radioLover', '1');\n\n        await this.loadMaterials();\n        this.recalculateButtons();\n        this.initTouchControls();\n        this.setTitle('Goroxels Radio 1.0 alpha');\n\n        this.canvas.width = this.config.width;\n        this.canvas.height = this.config.height;\n\n        this._fx = new FX(this.render.bind(this));\n        globals.fxRenderer.add(this._fx, 2);\n\n        await this.updateSong();\n        this.startPolling();\n\n        // socket handlers\n        this._socketHandlers.radio = (type) => {\n            switch (type) {\n                case 0: this.updateSong(); break;\n                case 1: this.updateQueue(); break;\n            }\n        };\n        this._socketHandlers.opened = () => {\n            this.updateSong();\n        };\n\n        globals.socket.on('radio', this._socketHandlers.radio);\n        globals.socket.on('opened', this._socketHandlers.opened);\n\n        this.ackRender();\n        this.initAutoRender();\n    }\n\n    volume(val) {\n        this.volumeLvl = val;\n        this.gainNode.gain.value = val;\n        setLS('winamp.volume', val.toString(), true);\n    }\n\n    balance(val) {\n        this.sndBalance = val;\n        this.pannerNode.pan.value = val;\n    }\n\n\n    initAutoRender() {\n        setInterval(() => this.ackRender(), 1000);\n    }\n\n    initTouchControls() {\n        const self = this;\n\n        function mousedown(e) {\n            if (self._holdingButton) mouseup(e);\n            let obj = self.getObjectAtPosition(e.clientX, e.clientY);\n            if (obj) {\n                preserveColors();\n                camera.disableMove();\n                self.onObjMousedown.call(self, obj, e);\n                self._lastHoldPos = screenToBoardSpace(e.clientX, e.clientY);\n            }\n        }\n        function mouseup(e) {\n            self._lastHoldPos = null;\n            camera.enableMove();\n            if (self._holdingButton) {\n                self.onObjMouseup.call(self, self._holdingButton, e);\n                self._holdingButton = false;\n                setTimeout(restoreColors);\n            }\n        }\n        function mousemove(e) {\n            if (self._holdingButton) {\n                self.onObjMousemove.call(self, self._holdingButton, e);\n                self._lastHoldPos = screenToBoardSpace(e.clientX, e.clientY);\n            }\n        }\n\n        this._boundHandlers.mousedown = (e) => {\n            if (this._destroyed) return;\n            if (e.gesture) return mouseup(e);\n            mousedown(e);\n        };\n        this._boundHandlers.mouseup = (e) => {\n            if (this._destroyed) return;\n            mouseup(e);\n        };\n        this._boundHandlers.mousemove = (e) => {\n            if (this._destroyed) return;\n            if (e.gesture) return;\n            mousemove(e);\n        };\n\n        globals.eventManager.on('mousedown', this._boundHandlers.mousedown);\n        globals.eventManager.on('mouseup', this._boundHandlers.mouseup);\n        globals.eventManager.on('mousemove', this._boundHandlers.mousemove);\n    }\n\n    close() {\n        setLS('radioLover', '0');\n\n        if (this.audio) {\n            this.audio._destroyed = true;\n            this.audio.pause();\n            this.audio.src = \"\";\n            this.audio.remove();\n        }\n\n        if (this.audioCtx) {\n            this.audioCtx.close();\n        }\n\n        clearTimeout(this.__pollTimeout);\n        clearInterval(this._titleRollerInterval);\n        globals.fxRenderer.remove(this._fx);\n\n        // remove eventManager handlers\n        if (this._boundHandlers) {\n            globals.eventManager.off('mousedown', this._boundHandlers.mousedown);\n            globals.eventManager.off('mouseup', this._boundHandlers.mouseup);\n            globals.eventManager.off('mousemove', this._boundHandlers.mousemove);\n            this._boundHandlers = {};\n        }\n\n        // remove socket handlers\n        if (this._socketHandlers) {\n            globals.socket.off('radio', this._socketHandlers.radio);\n            globals.socket.off('opened', this._socketHandlers.opened);\n            this._socketHandlers = {};\n        }\n\n        this._destroyed = true;\n\n\n        createRadioStarterBtn();\n    }\n\n    getObjectAtPosition(screenX, screenY) {\n        const objsToCheck = [\n            this.config.headerRect,\n            this.config.closeBtnRect,\n            this.config.volumeSliderRect,\n            this.config.balanceSliderRect,\n        ];\n\n        const [boardX, boardY] = screenToBoardSpace(screenX, screenY);\n        const [playerX, playerY] = this.getRelPos(boardX, boardY);\n\n        for (let obj of objsToCheck) {\n            if (playerX >= obj.x && playerX < obj.x + obj.w &&\n                playerY >= obj.y && playerY < obj.y + obj.h) {\n                return obj;\n            }\n        }\n    }\n\n    onObjMousedown(obj) {\n        this._holdingButton = obj;\n    }\n    onObjMouseup(obj, e) {\n        switch (obj) {\n            case this.config.closeBtnRect: {\n                if (this.getObjectAtPosition(e.clientX, e.clientY) === this.config.closeBtnRect) {\n                    this.close();\n                }\n            }\n        }\n    }\n    onObjMousemove(obj, e) {\n        const [movX, movY] = this.calcMovement(e);\n\n        switch (obj) {\n            case this.config.headerRect: {\n                this.playerPosition[0] += movX;\n                this.playerPosition[1] += movY;\n\n                setLS('winamp.position', JSON.stringify(this.playerPosition), true);\n\n                this.ackRender();\n\n                break;\n            }\n            case this.config.volumeSliderRect: {\n                const [relX] = this.getRelPos(...screenToBoardSpace(e.clientX, e.clientY));\n\n                const bndRect = this.config.volumeBoundsRect;\n                const sliderImg = this.images.hrSlider;\n\n                const [clampedX, clampedY] = this.clampHrSliderPos(relX, bndRect, sliderImg);\n\n                this.config.volumeSliderRect.x = clampedX;\n                this.config.volumeSliderRect.y = clampedY;\n\n                const newValue = this.mapHrSliderPos(clampedX, bndRect, sliderImg, 0, 1);\n                this.volume(newValue);\n\n                this.ackRender();\n\n                break;\n            }\n\n            case this.config.balanceSliderRect: {\n                const [relX] = this.getRelPos(...screenToBoardSpace(e.clientX, e.clientY));\n\n                const bndRect = this.config.soundBalanceBoundsRect;\n                const sliderImg = this.images.hrSlider;\n\n                const [clampedX, clampedY] = this.clampHrSliderPos(relX, bndRect, sliderImg);\n\n                this.config.balanceSliderRect.x = clampedX;\n                this.config.balanceSliderRect.y = clampedY;\n\n                const newValue = this.mapHrSliderPos(clampedX, bndRect, sliderImg, -1, 1);\n                this.balance(newValue);\n\n                this.ackRender();\n\n                break;\n            }\n        }\n    }\n\n    // clamp mouse position to slider bounds\n    clampHrSliderPos(relX, bndRect, sliderImg) {\n        // center the slider to the mouse pos\n        relX -= sliderImg.width / 2;\n\n        const clampX = clamp(relX, bndRect.x, bndRect.x + bndRect.w - sliderImg.width);\n        const constY = bndRect.y + (bndRect.h / 2) - (sliderImg.height / 2) + 1;\n\n        return [clampX | 0, constY | 0];\n    }\n\n    // convert slider position to output value\n    mapHrSliderPos(posX, bndRect, sliderImg, minValue, maxValue) {\n        const minPosX = bndRect.x;\n        const maxPosX = bndRect.x + bndRect.w - sliderImg.width;\n\n        const mappedVal = mapRange(posX, minPosX, maxPosX, minValue, maxValue);\n        return mappedVal;\n    }\n\n    // convert value to position\n    reverseMapHrSliderPos(value, bndRect, sliderImg, minValue, maxValue) {\n        const minPosX = bndRect.x;\n        const maxPosX = bndRect.x + bndRect.w - sliderImg.width;\n\n        const mappedPosX = mapRange(value, minValue, maxValue, minPosX, maxPosX);\n        return mappedPosX | 0;\n    }\n\n    // convert global board position to local canvas position\n    getRelPos(boardX, boardY) {\n        const playerX = boardX - this.playerPosition[0];\n        const playerY = boardY - this.playerPosition[1];\n\n        return [playerX, playerY];\n    }\n\n    // getHrSliderPos(minX, maxX, )\n\n    calcMovement(e) {\n        if (!this._lastHoldPos) {\n            return null;\n        }\n\n        const curBoardPos = screenToBoardSpace(e.clientX, e.clientY);\n\n        const diffX = curBoardPos[0] - this._lastHoldPos[0];\n        const diffY = curBoardPos[1] - this._lastHoldPos[1];\n\n        return [diffX, diffY];\n    }\n\n    async loadMaterials() {\n        const {\n            images: urlsObj,\n            fonts\n        } = await importMaterials();\n\n        const imgObj = {};\n        for (let key of Object.keys(urlsObj)) {\n            let url = urlsObj[key].default;\n\n            imgObj[key] = await loadImage(url);\n        }\n\n        this.images = imgObj;\n        this.fonts = fonts;\n    }\n\n    ackRender() {\n        this.needRender = true;\n        globals.fxRenderer.requestRender();\n    }\n\n    render(ctx) {\n        if (this._destroyed) return 2;\n\n        const [x, y] = boardToScreenSpace(this.playerPosition[0], this.playerPosition[1]);\n        const z = camera.zoom;\n\n        if (this.needRender)\n            this.redraw();\n\n        ctx.save();\n        ctx.scale(z, z);\n        ctx.drawImage(this.canvas, x / z, y / z);\n        ctx.restore();\n\n        return 1\n    }\n\n    generateQueueText() {\n        if (!this.queue) return '';\n\n        const queue = [\n            ...this.queue.queue,\n            ...this.queue.defaultQueue\n        ].slice(0, 7);\n\n        const str = queue.map(s => {\n            let title = cutTextToWidth(s.title, 190);\n            return `${s.id ?? 'x'}. ${title} <${s.duration / 60 | 0}:${pad2(s.duration % 60 | 0)}>`\n\n            function cutTextToWidth(text, maxWidth) {\n                let curWidth = 0;\n                let curText = '';\n                for (const ch of text) {\n                    // every dot is 3px wide\n                    if (curWidth >= maxWidth - 9) {\n                        curText += '...';\n                        break;\n                    }\n\n                    if (ch === ' ' || /[-]/.test(ch)) curWidth += 5;\n                    else if (/[A-z]/.test(ch)) curWidth += 4;\n                    else if (ch === '.') curWidth += 2;\n                    else curWidth += 4;\n\n                    curWidth += 1;\n\n                    curText += ch;\n                }\n\n                return curText;\n            }\n        }).join('\\n');\n\n        return str;\n    }\n\n    redraw() {\n        this.needRender = false;\n\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.drawImage(this.images.bg, 0, 0);\n        this.ctx.drawImage(this.images.hrSlider, this.config.volumeSliderRect.x, this.config.volumeSliderRect.y);\n        this.ctx.drawImage(this.images.hrSlider, this.config.balanceSliderRect.x, this.config.balanceSliderRect.y);\n\n        this.drawTextInInput(this.title, this.config.titleRect, '#00E200');\n\n        if (this.currentTrack) {\n            const kbps = (2 * 2 * this.currentTrack.sampleRate) / 1000 | 0; // channels*sampleSize(16bit=2byte)*sampleRate\n            const khz = this.currentTrack.sampleRate / 1000 | 0;\n\n            this.drawTextInInput(kbps.toString(), this.config.kbpsRect, '#00E200');\n            this.drawTextInInput(khz.toString(), this.config.khzRect, '#00E200');\n\n            const sPassed = (Date.now() - this.currentTrack.startedAt) / 1000;\n\n            const mmPassed = pad2((sPassed / 60 | 0).toString());\n            const ssPassed = pad2((sPassed % 60 | 0).toString());\n\n            this.drawBigDigit(this.config.mm1Rect, mmPassed[0]);\n            this.drawBigDigit(this.config.mm2Rect, mmPassed[1]);\n            this.drawBigDigit(this.config.ss1Rect, ssPassed[0]);\n            this.drawBigDigit(this.config.ss2Rect, ssPassed[1]);\n\n            const progressPosX = this.reverseMapHrSliderPos(sPassed, this.config.progressSliderBndRect, this.images.hrSliderBig, 0, this.currentTrack.duration);\n            const progressPosY = this.config.progressSliderBndRect.y;\n\n            this.ctx.drawImage(this.images.hrSliderBig, progressPosX, progressPosY);\n        }\n\n        // this shit eats a lot of cpu\n        const queueText = this.generateQueueText();\n        if (queueText && queueText !== this._cache.queueText) {\n            const qTextImg = this.fonts.winamp.drawText(queueText, '#00E200');\n            if (qTextImg) {\n                this._cache.queueTextImg = qTextImg;\n                this._cache.queueText = queueText;\n                this.ctx.drawImage(qTextImg, this.config.queueBoxRect.x, this.config.queueBoxRect.y);\n            }\n        } else if (queueText) {\n            this.ctx.drawImage(this._cache.queueTextImg, this.config.queueBoxRect.x, this.config.queueBoxRect.y);\n        }\n    }\n\n    drawBigDigit(rect, number) {\n        const digitW = rect.w;\n        this.ctx.drawImage(this.images.digits, digitW * number, 0, rect.w, rect.h, rect.x, rect.y, rect.w, rect.h);\n    }\n\n    drawTextInInput(text, inputRect, color) {\n        const drawnText = this.fonts.winamp.drawText(text, color);\n        this.ctx.drawImage(drawnText, 0, 0, inputRect.w, drawnText.height, inputRect.x, ((inputRect.y + inputRect.h / 2) - drawnText.height / 2) | 0, inputRect.w, drawnText.height);\n    }\n\n    recalculateButtons() {\n        const smallSliderWidth = this.images.hrSlider.width;\n        const smallSliderHeight = this.images.hrSlider.height;\n\n        const volRect = this.config.volumeBoundsRect;\n        const volSliderX = mapRange(this.volumeLvl, 0, 1, volRect.x, (volRect.x + volRect.w) - smallSliderWidth);\n        const volSliderY = ((volRect.y + volRect.h / 2) - smallSliderHeight / 2) + 1\n\n        this.config.volumeSliderRect.x = volSliderX | 0;\n        this.config.volumeSliderRect.y = volSliderY | 0;\n        this.config.volumeSliderRect.w = smallSliderWidth;\n        this.config.volumeSliderRect.h = smallSliderHeight;\n\n        const balRect = this.config.soundBalanceBoundsRect;\n        const balSliderX = mapRange(this.sndBalance, -1, 1, balRect.x, (balRect.x + balRect.w) - smallSliderWidth);\n        const balSliderY = ((balRect.y + balRect.h / 2) - smallSliderHeight / 2) + 1\n\n        this.config.balanceSliderRect.x = balSliderX | 0;\n        this.config.balanceSliderRect.y = balSliderY | 0;\n        this.config.balanceSliderRect.w = smallSliderWidth;\n        this.config.balanceSliderRect.h = smallSliderHeight;\n    }\n\n    initAudioChain() {\n        if (!this.audioCtx || this.audioCtx.state === \"closed\") {\n            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n        }\n\n        this.gainNode = this.audioCtx.createGain();\n        this.gainNode.gain.value = this.volumeLvl;\n\n        this.pannerNode = this.audioCtx.createStereoPanner();\n        this.pannerNode.pan.value = this.sndBalance;\n\n        if (this.audio) {\n            try { this.audio._destroyed = true; } catch { }\n            try { this.audio.pause(); } catch { }\n            try { this.audio.remove(); } catch { }\n        }\n\n        this.audio = document.createElement(\"audio\");\n        this.audio.autoplay = true;\n        this.audio.controls = false;\n        this.audio._destroyed = false;\n\n        this.addAudioStoppedListeners();\n\n        const srcNode = this.audioCtx.createMediaElementSource(this.audio);\n        srcNode.connect(this.gainNode).connect(this.pannerNode).connect(this.audioCtx.destination);\n    }\n\n    async startStream() {\n        if (this._destroyed) return;\n        if (this._streaming) return;\n\n        this._streaming = true;\n\n        const startFn = () => {\n            try {\n                if (!this.audio || this.audio._destroyed) {\n                    this.initAudioChain();\n                }\n\n                this.audio.src = `${location.protocol}//${location.hostname}/api/radio/stream`;\n                this.audio.autoplay = true;\n\n                const playPromise = this.audio.play();\n                if (playPromise) {\n                    playPromise.catch(err => console.warn(\"Playback blocked until user interaction:\", err));\n                }\n            } catch (err) {\n                console.error(\"Failed to start stream:\", err);\n                this._streaming = false;\n\n                if (!this._destroyed) {\n                    setTimeout(() => this.startStream(), 5000);\n                }\n            }\n        };\n\n        if (!documentClicked) {\n            onDocumentClickCallbacks.push(startFn);\n        } else {\n            startFn();\n        }\n    }\n\n    async restartStream() {\n        if (this._destroyed) return;\n        this._streaming = false;\n        console.info(\"Restarting radio stream...\");\n        await this.startStream();\n    }\n\n    async startPolling() {\n        if (this._destroyed) return;\n        await this.startStream();\n    }\n\n\n    async updateSong() {\n        if (this._destroyed) return;\n\n        this.noFeed = true;\n\n        const song = await this.fetchCurTrack();\n\n        this.currentTrack = song;\n\n        const curTrackMins = song.duration / 60 | 0;\n        const curTrackSecs = song.duration % 60 | 0;\n        this.setTitle(this.currentTrack.title + ` <${curTrackMins}:${pad2(curTrackSecs)}>`);\n\n\n        this.noFeed = false;\n\n        this.ackRender();\n\n        this.updateQueue().then(() => this.ackRender());\n    }\n\n    async updateQueue() {\n        const queue = await this.fetchQueue();\n        if (!queue) return;\n\n        this.queue = queue;\n        this.ackRender();\n    }\n\n    async fetchCurTrack() {\n        const resp = await apiRequest('/radio/current-song');\n        const json = await resp.json();\n        if (!json.success) {\n            // toastr.error('cannot fetch current song! reload the page.');\n            return\n        }\n\n        return json.song;\n    }\n\n    async fetchQueue() {\n        const resp = await apiRequest('/radio/get-queue');\n        const json = await resp.json();\n        if (!json.success) {\n            // toastr.warn('cannot fetch song queue');\n            return\n        }\n\n        return json.queues;\n    }\n\n    setTitle(title) {\n        this._titleSet = Date.now();\n\n        this.title = title;\n\n        clearInterval(this._titleRollerInterval)\n\n        // roll only if it exceeds input width\n        if (this.fonts.winamp.measureText(this.title).width > this.config.titleRect.w) {\n            this._titleRollerInterval = setInterval(() => {\n                // rotate title by 1 char\n                const titleArr = this.title.split('');\n                titleArr.push(titleArr.shift());\n\n                this.title = titleArr.join('');\n                this.ackRender();\n            }, 300);\n        }\n    }\n}\n\n\nfunction pad2(num) {\n    return num.toString().padStart(2, '0');\n}\n\nexport function startWinampRadio() {\n    if (getLS('radioLover') === '1') {\n        initRadio();\n    } else {\n        createRadioStarterBtn();\n    }\n\n}\n\n\n\nexport default WinampPlayer","import toastr from 'toastr';\n\nimport chat, { fixChatPosition, toggleEmojis, updateEmojis } from './Chat';\nimport { game, palettePreviews, palettes, showProtected } from './config';\nimport { ROLE, ROLE_I } from './constants';\nimport { urlInput } from './ui/elements';\nimport globals from './globals';\nimport { showHistoryCanvas, unloadHistoryCanvas, wipes } from './history';\nimport me from './me';\nimport player, { togglePlaced, updateBrush, updateMe } from './player';\nimport tools from './tools';\nimport { translate as t, translate as tr } from './translate';\nimport User from './user';\nimport Window, { ConfirmModal } from './Window';\nimport { getLS, getOrDefault, setLS } from './utils/localStorage';\nimport { capitalize } from './utils/strings';\nimport { decodeKey, getEventKeyCode, htmlspecialchars, reverseFade, stringifyKeyEvent } from './utils/misc';\nimport { makeScreenshot } from './utils/screenshot';\n\nimport arrowSvg from '../img/arrow.svg';\nimport desktopIcon from '../img/icon-desktop.svg';\nimport mobileIcon from '../img/icon-phone.svg';\nimport userImg from '../img/user2.png';\nimport dsLogo from '../img/discord-logo-circle.svg';\nimport ggLogo from '../img/gg-logo.svg';\nimport vkLogo from '../img/vk-logo.svg';\n\nimport lmbIcon from '../img/mouse/mouse-lmb.png';\nimport rmbIcon from '../img/mouse/mouse-rmb.png';\nimport mmbIcon from '../img/mouse/mouse-mmb.png';\nimport mb4Icon from '../img/mouse/mouse-4mb.png';\nimport mb5Icon from '../img/mouse/mouse-5mb.png';\nimport { apiRequest, fetchCaptcha, solveCaptcha } from './utils/api';\nimport { shareTemplate, showTemplates, updateTemplate } from './template';\nimport { setPaletteColorsSize, swapToolsPos, unloadPalettePatterns } from './ui/config';\nimport { paletteChosen, showPatternsOnPalette } from \"./ui/palette\";\n\n\nconst mouseKeys = {\n    'LMB': lmbIcon,\n    'RMB': rmbIcon,\n    'MMB': mmbIcon,\n    '4MB': mb4Icon,\n    '5MB': mb5Icon,\n}\n\nexport function initButtons() {\n    $('#accountSettings').on('click', accountSettings);\n    $('#toolBinds').on('click', keyBinds);\n    $('#uiSettings').on('click', uiSettings);\n    $('#canvasSettings').on('click', gameSettings);\n    $('#toolsB').on('click', toolsWindow);\n    $('.authBtn').on('click', authWindow);\n    $('#showTemplates').on('click', showTemplates);\n    $('#shareTemplate').on('click', shareTemplate);\n}\n\nexport function initHelpButton() {\n    $('.helpBtn').on('click', () => {\n        help();\n    })\n}\n\nexport function showHelpIfFirstTime() {\n    const shownAlready = getLS('helpShown');\n    if (!shownAlready) {\n        setLS('helpShown', '1');\n        help();\n    }\n}\n\n\n\nexport function initOnlineViewer() {\n    $('#onlineColumn .columnHeader').on('click', async () => {\n        let json;\n        try {\n            const resp = await fetch('/api/online');\n            json = await resp.json();\n        } catch (e) {\n            toastr.error(e);\n            return\n        }\n\n        onlineViewWindow(json);\n    });\n}\n\n\nfunction createCollapsibleBlock(title, bodyHtml, collapsed = true) {\n    const head = $('<div>');\n    head[0].style.cssText =\n        `width: 100%;\n    height: 30px;\n    background-color: #5f5f5f;\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    user-select: none;\n    cursor: pointer`\n\n    head.append(`<div style=\"font-size:20px;text-transform:uppercase;\">${title}</div>`)\n\n    const arrow = $('<div>');\n    arrow[0].style.cssText =\n        `position: absolute;\n    top: 50%;\n    transform: translate(0, -50%);\n    left: 5px;\n    background-image: url(${arrowSvg});\n    background-size: 100%;\n    background-repeat: no-repeat;\n    transition: transform .2s ease-in-out;\n    width: 20px;\n    height: 20px;`\n\n    head.append(arrow);\n\n    const body = $('<div>');\n    body[0].style.cssText =\n        `max-height: 0;\n    overflow: hidden;\n    transition: max-height 0.3s linear;\n    font-size: 20px;`\n\n    const innerBody = $('<div>');\n    innerBody[0].style.cssText =\n        `padding:8px`\n    innerBody.html(bodyHtml);\n\n    body.append(innerBody);\n\n    const headBodyContainer = $('<div>');\n    headBodyContainer[0].style.cssText =\n        `margin-bottom: 1px;`\n    headBodyContainer.append(head, body)\n\n    let state = 0; // 0 - closed, 1 - opened\n    let reCheckHeightIntervalId = null;\n    function toggle() {\n        clearTimeout(reCheckHeightIntervalId);\n        if (state) {\n            arrow.css('transform', 'translate(0px, -50%) rotate(0deg)');\n            body.css('max-height', 0);\n        } else {\n            arrow.css('transform', 'translate(0px, -50%) rotate(180deg)');\n\n            requestAnimationFrame(() => {\n                // force layout calc reflow\n                // otherwise scrollHeight may be not updated\n                body[0].offsetHeight;\n\n                body.css('max-height', body[0].scrollHeight);\n\n                reCheckHeightIntervalId = setTimeout(() => {\n                    body.css('max-height', body[0].scrollHeight);\n                }, 300);\n            });\n        }\n        state = !state;\n    }\n    if (!collapsed) setTimeout(toggle);\n\n    head.on('click', toggle);\n\n    return headBodyContainer\n}\n\nexport function generateTable(arr = []) {\n    const table = $('<table class=\"columnTable\"></table>');\n    arr.forEach(([title, content]) => {\n        let tableBlock = $(`\n                <tr>\n                    ${content === void 0 ?\n                `<td colspan=\"2\">${title}</td>` :\n                `<td>${title}</td>\n                        <td>${content}</td>`\n            }\n                </tr>`);\n        table.append(tableBlock)\n    });\n\n    return table\n}\n\nexport function accountSettings() {\n    const settingsWin = new Window({\n        title: capitalize(t('account settings')),\n        center: true\n    });\n    if (!settingsWin.created) return;\n\n    let html = generateTable([\n        [tr('role'), ROLE_I[me.role].toUpperCase()],\n        [\n            tr('change name'),\n            `<input type=\"text\" id=\"name\" style=\"width:50%\"><button id=\"changeName\">yes</button>`\n        ],\n        [\n            `<button id=\"logout\">${tr('logout')}</button>`\n        ],\n        // [\n        //     `<button id=\"deleteAccount\">${tr('delete_account')}</button>`\n        // ]\n\n    ]);\n\n    $(settingsWin.body).append(html);\n\n    $('#name').val(me.name)\n    $('#changeName').on('click', () => {\n        const newName = $('#name').val();\n\n        if (!me.registered) {\n            return toastr.error('Hey wtf', '0_o');\n        }\n        if (newName.length < 0 || newName.length > 32) {\n            return toastr.error('Name length is not 0 < length < 32', 'Name change')\n        }\n        if (me.name === newName) {\n            return toastr.error('Name is the same as was', 'Name change')\n        }\n\n        fetch('/api/changename', {\n            method: 'POST',\n            body: JSON.stringify({\n                name: newName\n            }),\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        }).then(async r => {\n            const result = await r.json();\n            if (!result.errors.length) {\n                globals.socket.close();\n                toastr.success('Name successfully changed');\n                updateMe();\n            } else {\n                result.errors.map(e => {\n                    toastr.error(e, 'Name change error')\n                })\n            }\n        })\n    })\n\n    $('#logout').on('click', async () => {\n        if (me.registered) {\n            const req = await apiRequest('/auth/logout');\n            const success = await req.json();\n            if (success) {\n                location.pathname = '/';\n            } else {\n                toastr.error('Can\\'t log out');\n            }\n        }\n    })\n}\n\nexport function keyBinds() {\n    const keysWin = new Window({\n        title: capitalize(t('toolbinds settings')),\n        center: true\n    });\n    if (!keysWin.created) return;\n\n    let table = generateTable();\n\n\n\n    for (const tool of Object.values(tools)) {\n        if (!tool.key) continue;\n        if (tool.requiredRole > me.role) continue;\n\n        const tableRow = $(\n            `<tr>\n            <td>${t('toolName.' + tool.name)}</td>\n            <td>\n                <div class=\"toolKeys\" id=\"KEYS-${tool.name}\">\n                </div>\n                <button class=\"resetKeyBtn\" id=\"RESET-${tool.name}\"></button>\n                <button class=\"changeKeyBtn\" \"id=\"CHANGE-${tool.name}\"></button>\n            </td>\n        </tr>`);\n\n        table.append(tableRow);\n\n        const keysContainer = $('.toolKeys', tableRow);\n        const changeBtn = $('.changeKeyBtn', tableRow);\n        const resetBtn = $('.resetKeyBtn', tableRow);\n\n        changeBtn.on('click', () => {\n            if (globals.lockInputs) return;\n            globals.lockInputs = true;\n\n            keysContainer.html('<span>...</span>');\n\n            let clearFade = reverseFade(tableRow[0]);\n            const onkeydown = e => {\n                e.preventDefault();\n                e.stopPropagation();\n\n                redrawToolKeys(e);\n\n                const code = getEventKeyCode(e);\n                if (isNormalKey(code) || isMouseKey(code)) {\n                    globals.toolManager.changeKey(tool, stringifyKeyEvent(e));\n                }\n            }\n            document.addEventListener('keydown', onkeydown);\n            document.addEventListener('pointerdown', onkeydown);\n\n            const onkeyup = e => {\n                const isMouse = isMouseKey(getEventKeyCode(e));\n                if (!isMouse && !e.code || e.code === 'ControlLeft' || e.code === 'AltLeft') return;\n\n                e.preventDefault();\n                e.stopPropagation();\n\n                cleanup();\n\n                globals.toolManager.saveBinds();\n            }\n\n            document.addEventListener('keyup', onkeyup);\n            document.addEventListener('pointerup', onkeyup);\n\n            function cleanup() {\n                clearFade?.call();\n                document.removeEventListener('keydown', onkeydown);\n                document.removeEventListener('pointerdown', onkeydown);\n                document.removeEventListener('keyup', onkeyup);\n                document.removeEventListener('pointerup', onkeyup);\n\n                globals.lockInputs = false;\n            }\n        });\n\n        resetBtn.on('click', () => {\n            if (globals.lockInputs) return;\n\n            redrawToolKeys(decodeKey(tool.defaultKey));\n\n            globals.toolManager.changeKey(tool, tool.defaultKey);\n            globals.toolManager.saveBinds();\n        })\n\n        function redrawToolKeys(key) {\n            const alt = key.alt ?? key.altKey;\n            const ctrl = key.ctrl ?? key.ctrlKey;\n\n            const keyCode = getEventKeyCode(key);\n\n            keysContainer.html('');\n\n            if (alt) {\n                keysContainer.append('<kbd>ALT</kbd> + ');\n            }\n            if (ctrl) {\n                keysContainer.append('<kbd>CTRL</kbd> + ');\n            }\n\n            if (isNormalKey(keyCode)) {\n                keysContainer.append(`<kbd>${keyCode}</kbd>`);\n            } else if (isMouseKey(keyCode)) {\n                const img = `<img src=\"${mouseKeys[keyCode]}\"/>`\n                keysContainer.append(`<kbd>${img}</kbd>`);\n            }\n        }\n\n        function isNormalKey(code) {\n            return code && !code.startsWith('Control') && !code.startsWith('Alt') && !isMouseKey(code)\n        }\n\n        function isMouseKey(code) {\n            return Object.keys(mouseKeys).includes(code);\n        }\n\n        const parsed = decodeKey(tool.key);\n\n        redrawToolKeys(parsed);\n    }\n\n    $(keysWin.body).append(table);\n}\n\nexport function uiSettings() {\n    const setWin = new Window({\n        title: capitalize(t('ui settings')),\n        center: true\n    });\n    if (!setWin.created) return;\n\n    const table = generateTable([\n        [t('colors size'), '<input type=\"range\" min=\"16\", max=\"64\" step=\"1\" id=\"colSize\"><div style=\"width:50px;\"><div>'],\n        [t('hide emojis'), '<input type=\"checkbox\" id=\"toggleEmojis\">'],\n        [t('emoji list'), '<input type=\"text\" id=\"emojiList\">'],\n        [`<button id=\"moreEmojis\">${t('super secret button')}</button>`],\n        [t('show placed pixels'), '<input type=\"checkbox\" id=\"togglePlaced\">'],\n        [t('show patterns over the palette'), '<input type=\"checkbox\" id=\"showPatterns\">'],\n        [t('tools_to_right_pos'), '<input type=\"checkbox\" id=\"swapToolsPos\">']\n    ]);\n    $(setWin.body).append(table);\n\n    function colorSizeChanged() {\n        const val = $('#colSize').val();\n        setPaletteColorsSize(val);\n        $('#colSize').next().text(val + 'px');\n        setLS('colorSize', val, true);\n        fixChatPosition();\n    }\n\n    const colSizeVal = getOrDefault('colorSize', 24, true);\n    $('#colSize').next().text(colSizeVal);\n    $('#colSize').val(colSizeVal)\n    $('#colSize').on('input', colorSizeChanged);\n\n    $('#toggleEmojis')[0].checked = getLS('hideEmojis') == 1;\n    $('#toggleEmojis').on('click', e => {\n        const state = !e.target.checked;\n        setLS('hideEmojis', state ? 0 : 1);\n        toggleEmojis(state);\n    });\n\n    $('#emojiList').val(getOrDefault('emojis', '        '));\n    $('#emojiList').on('change', e => {\n        setLS('emojis', e.target.value);\n        updateEmojis(e.target.value.split(' '));\n    })\n\n    $('#moreEmojis').on('click', () => {\n        const w = new Window(t('more emojis!'));\n        if (!w.created) return;\n\n        w.body.innerHTML = ''\n        w.body.style.userSelect = 'text';\n    });\n    $('#togglePlaced')[0].checked = getOrDefault('hidePlaced', 1) == 0;\n    $('#togglePlaced').on('click', e => {\n        const show = e.target.checked;\n        setLS('hidePlaced', show ? 0 : 1);\n        togglePlaced(show);\n    });\n\n    $('#showPatterns')[0].checked = globals.showPatterns;\n    $('#showPatterns').on('click', e => {\n        const show = e.target.checked;\n        globals.showPatterns = show;\n        setLS('showPalettePatterns', show ? '1' : '0');\n        show ? showPatternsOnPalette() : unloadPalettePatterns();\n    });\n\n    $('#swapToolsPos')[0].checked = +getOrDefault('swapToolsPos', 0) == 1;\n    $('#swapToolsPos').on('click', e => {\n        const swap = e.target.checked;\n        globals.showPatterns = swap;\n        setLS('swapToolsPos', swap ? '1' : '0');\n        swapToolsPos(swap);\n    });\n}\n\nexport function showPaletteSelect(){\n    if(Window.Exists(t('select_palette_title'))){\n        return;\n    }\n\n    \n    const selectWin = new Window({\n        title: t('select_palette_title'),\n        center: true\n    });\n    const paletteCards = [];\n    for(const curPalette of palettes){\n        const {name} = curPalette;\n        const card = $(`\n            <div class=\"paletteCard\">\n                <div class=\"paletteTitle\">${name}</div>\n                <div class=\"palettePreview\">\n                    <img src=\"${palettePreviews[name]}\"></img>\n                </div>\n            </div>\n            `);\n        paletteCards.push(card);\n\n        card.one('click', () => {\n            paletteChosen(name);\n\n            selectWin.close();\n        })\n    }\n    const paletteCardsCont = $(`<div class=\"paletteCards\"></div>`);\n    paletteCards.forEach(card => paletteCardsCont.append(card));\n    $(selectWin.body).append(paletteCardsCont);\n    $(selectWin.body).css('width', '90vw').css('max-width', '450px');\n\n    $(document.body).append(selectWin.element);\n}\n\nexport function gameSettings() {\n    const win = new Window({\n        title: capitalize(t('game settings')),\n        center: true\n    });\n    if (!win.created) return;\n\n    // 1 for guests (packets disabled by server), 20 for admins, and 10 for others \n    let maxBrushSize = (me.role === ROLE.ADMIN ? 20 : (me.role < ROLE.USER ? 1 : 10))\n\n    const tableOptions = [\n        [\n            t('show protected'),\n            `<input type=\"checkbox\" id=\"showProtected\" ${game.showProtected ? 'checked' : ''}>`\n        ],\n        [\n            t('brush size'),\n            `<input type=\"checkbox\" id=\"customBrushSize\" ${player.brushSize > 1 ? 'checked' : ''}>\n            <input id=\"brushSize\" type=\"range\" value=\"${player.brushSize}\" ` +\n            `${player.brushSize == 1 ? 'disabled' : ''} min=\"2\" ` +\n            `max=\"${maxBrushSize}\" step=\"2\">` +\n            `<span id=\"brushSizeCounter\">${player.brushSize - 1}<span>`\n        ],\n        [\n            t('max saved pixels'),\n            `<input id=\"savePixelsInp\" type=\"number\" min=\"0\" value=\"${player.maxPlaced}\" style=\"width:4rem\">`\n        ],\n        [\n            t('disable chat colors'),\n            `<input type=\"checkbox\" id=\"disableChatColors\" ${chat.colorsEnabled ? '' : 'checked'}>`\n        ],\n        [\n            t('chat messages limit'),\n            `<input type=\"number\" id=\"chatLimit\" value=\"${game.chatLimit}\" title=\"maximum messages in chat\">`\n        ],\n        [\n            t('enable grid'),\n            `<input type=\"checkbox\" id=\"enableGridCB\" ${tools.grid.state == 1 ? 'checked' : ''}>`\n        ],\n        [\n            t('draw line length'),\n            `<input type=\"checkbox\" id=\"drawLineLenCB\" ${tools.line.drawLength ? 'checked' : ''} title=\"draw line length near it\">`\n        ],\n    ];\n\n    if(palettes){\n        tableOptions.unshift([\n            `<button id=\"changePaletteBtn\">${t('change_palette')}</button>`\n        ])\n    }\n    const table = generateTable(tableOptions);\n\n    $(win.body).append(table);\n\n    $('#changePaletteBtn').on('click', showPaletteSelect);\n\n    $('#showProtected').on('change', e => {\n        const show = e.target.checked;\n        game.showProtected = show;\n        showProtected(show);\n    });\n\n    $('#customBrushSize').on('change', e => {\n        const use = e.target.checked;\n\n        if (use) {\n            $('#brushSize').removeAttr('disabled');\n            updateBrush($('#brushSize').val());\n        } else {\n            $('#brushSize').attr('disabled');\n            updateBrush(1);\n        }\n    });\n\n    $('#brushSize').on('input', e => {\n        updateBrush(e.target.value);\n    });\n\n    $('#savePixelsInp').on('change', e => {\n        e = e.target;\n        if (+e.value < 0) e.value = 0;\n\n        player.maxPlaced = +e.value;\n        setLS('maxPlaced', player.maxPlaced)\n    });\n\n    $('#disableChatColors').on('change', e => {\n        const checked = e.target.checked\n\n        setLS('disableColors', checked.toString());\n\n        chat.setColors(!checked)\n    });\n\n    $('#chatLimit').on('change', e => {\n        const value = parseInt(e.target.value, 10);\n        if (isNaN(value) || value < 1) return;\n\n        setLS('chatLimit', value.toString());\n\n        game.chatLimit = value;\n    });\n\n    $('#enableGridCB').on('change', e => {\n        const checked = e.target.checked;\n\n        setLS('enableGrid', checked.toString());\n\n        if (checked) tools.grid.show();\n        else tools.grid.hide();\n    });\n\n    $('#drawLineLenCB').on('change', e => {\n        const checked = e.target.checked;\n\n        setLS('drawLineLen', checked.toString());\n\n        tools.line.drawLength = checked;\n    });\n}\n\nexport async function captchaModal() {\n    let win = new Window({\n        title: t('Captcha'),\n        center: true,\n        closeable: false\n    });\n\n    if (win.created) {\n        const [help, cont, inp] = $(\n            `<div>${t('Case insensitive, 0/o i/l are same')}. <a href=\"#\">${t('Can\\'t recognize?')}</a></div>` +\n            '<div class=\"captchaContainer\"></div>' +\n            '<input class=\"fullWidthInput\" type=\"text\"></input>'\n        );\n\n        help.children[0].onclick = captchaModal;\n\n        const [line] = $(`<div style=\"display:flex;justify-content:center\">${t('Captcha').toUpperCase()}:&nbsp;&nbsp;</div>`);\n        line.appendChild(inp);\n\n        win.body.appendChild(help)\n        win.body.appendChild(cont);\n        win.body.appendChild(line);\n\n        inp.addEventListener('keydown', async e => {\n            if (e.key === 'Enter') {\n                if (inp.value.length == 0) return;\n                let val = inp.value;\n                inp.value = '';\n\n                const success = await solveCaptcha(val);\n\n                if (success) {\n                    win.close();\n                } else {\n                    captchaModal();\n                }\n            }\n        })\n    } else win = win.oldWindow;\n\n    let svg;\n    try {\n        svg = await fetchCaptcha();\n    } catch (e) {\n        console.error('error downloading captcha image: ' + e);\n\n        globals.socket.close();\n        return win.close();\n    }\n\n    // according to default dark theme\n    svg = svg.replace('stroke=\"black\"', 'stroke=\"white\"');\n\n    $('.captchaContainer', win.body).html(svg);\n\n    win.moveToCenter();\n    $('input', win.body).trigger('focus');\n}\n\nexport function toolsWindow() {\n    const toolWin = new Window({\n        title: capitalize(t('tools')),\n        center: true\n    });\n    if (!toolWin.created) return;\n\n    const tableArr = [\n        [`<a href=\"/convert\" target=\"_blank\">${t('convert image into palette')}</a>`],\n        [`<button id=\"screenshot\">${t('save canvas')}</button>`],\n        [`<button id=\"showPrevWipes\">${t('tools.showPrevWipesBtn')}</button>`]\n    ]\n\n    if (me.role >= ROLE.MOD) {\n        tableArr.unshift([`<button id=\"searchUsersB\">${t('search users')}</button>`])\n    }\n\n    const table = generateTable(tableArr);\n    $(toolWin.body).append(table);\n\n    $('#searchUsersB', table).on('click', () => {\n        const win = new Window({\n            title: capitalize(t('search users')),\n            center: true\n        });\n        if (!win.created) return;\n\n        const table = generateTable([\n            [`<input type=\"text\" placeholder=\"nickname\" id=\"userSearchText\" max=\"32\" style=\"width:250px\"> ${t('OR')} ` +\n                '<input type=\"text\" placeholder=\"id\" id=\"userSearchId\" max=\"32\" style=\"width:50px\">' +\n                `<input type=\"checkbox\" id=\"searchIsBanned\"><label for=\"searchIsBanned\">${t('banned?')}</label>`],\n            ['<div id=\"searchUsersBody\">']\n        ]);\n\n        $(win.body).append(table);\n\n        const input = $('#userSearchText');\n\n        $('#userSearchId').on('input', async e => {\n            let num = e.target.value.trim();\n            num = +num;\n\n            if (isNaN(num) || num < 1 || num > Number.MAX_SAFE_INTEGER) {\n                return\n            }\n\n            const isBanned = $('#searchIsBanned')[0].checked;\n\n            const searchResp = await search(null, num, isBanned);\n            afterSearch(searchResp);\n        })\n\n        $('#userSearchText').on('input', async _ => {\n            let text = input.val().trim();\n            text = text.slice(0, 32);\n\n            const isBanned = $('#searchIsBanned')[0].checked;\n\n            const searchResp = await search(text, null, isBanned);\n            afterSearch(searchResp);\n        });\n\n        function afterSearch(resp) {\n            if (!resp || !resp.length) {\n                // clean up if nothing found\n                $('#searchUsersBody').html('');\n                return\n            };\n\n            let table = document.createElement('table');\n            table.className = 'innerTable';\n            table.innerHTML += '<tr><th>NICK</th><th>ID</th><th>ROLE</th><th>&nbsp;</th></tr>'\n\n            for (let user of resp) {\n                const safeNick = htmlspecialchars(user.name);\n\n                // little workaround with click listener,\n                // this might be shorter\n                const uinfoButton = document.createElement('button');\n                uinfoButton.className = 'userInfoBtn';\n                uinfoButton.innerHTML = `<img src=\"${userImg}\">`;\n                uinfoButton.addEventListener('click', async () => {\n                    const req = await apiRequest(`/userInfo?id=${user.id}`);\n                    const info = await req.json();\n                    await User.CreateWindow(info);\n                })\n\n                const row = $(\n                    `<tr>\n                        <td>${safeNick}</td><td>${user.id}</td>` +\n                    `<td>${user.role}</td>` +\n                    `<td></td>\n                    </tr>`\n                );\n\n                row[0].lastElementChild.appendChild(uinfoButton);\n                table.appendChild(row[0]);\n            }\n\n            $('#searchUsersBody').html(table);\n        }\n\n        async function search(term, id, isBanned) {\n            if (!isBanned) {\n                if (!term && !id) return;\n            }\n            if (term && id) return;\n\n            if (term) {\n                term = encodeURIComponent(term);\n            }\n            const req = await apiRequest(`/admin/users/search?isBanned=${isBanned ? 1 : 0}&${id ? `id=${id}` : `t=${term}`}`)\n\n            const json = await req.json();\n            return json\n        }\n    });\n\n    $('#screenshot').on('click', makeScreenshot);\n\n    $('#showPrevWipes').on('click', () => {\n        const wipesWin = new Window({\n            title: capitalize(t('prevWipesWinTitle'))\n        });\n        if (!wipesWin.created) return;\n\n        wipesWin.body.style.maxHeight = '200px';\n\n        if (!globals.mobile) {\n            wipesWin.moveTo(\n                toolWin.right + 5,\n                toolWin.top\n            );\n        } else {\n            wipesWin.moveToCenter();\n        }\n\n        const createWipeRow = function (wipeName) {\n            return [`<button data-name=\"${wipeName}\" class=\"showWipeBtn\">${wipeName}</button>`];\n        }\n        const table = generateTable(Object.keys(wipes).map(createWipeRow));\n        $(wipesWin.body).append(table);\n\n        $('.showWipeBtn', wipesWin.body).on('click', el => {\n            const name = el.target.dataset.name;\n            showHistoryCanvas(name);\n        });\n\n        const oldCloseFunc = wipesWin.close;\n        wipesWin.close = (...args) => {\n            unloadHistoryCanvas();\n\n            oldCloseFunc.call(wipesWin, ...args);\n        }\n    })\n}\n\nexport function authWindow() {\n    const win = new Window({\n        title: capitalize(t('LOG IN')),\n        center: true\n    });\n    if (!win.created) return;\n\n    const tableArr = [\n        [`<a href=\"/api/auth/vk\"><img src=\"${vkLogo}\" class=\"authLogo\">VK</a>`],\n        [`<a href=\"/api/auth/discord\"><img src=\"${dsLogo}\" class=\"authLogo\">DISCORD</a>`],\n        [`<a href=\"/api/auth/google\"><img src=\"${ggLogo}\" class=\"authLogo\">GOOGLE</a>`]\n    ]\n\n    const table = generateTable(tableArr);\n\n    $('td', table).css('text-align', 'left');\n    $('a', table).css('margin-left', '15px');\n\n    $(win.body).append(table);\n}\n\n\nexport function help() {\n    const helpWin = new Window({\n        title: t('help'),\n        center: true\n    });\n    if (!helpWin.created) return;\n\n    helpWin.body.style.maxWidth = '800px';\n    helpWin.body.style.width = '90vw';\n    helpWin.body.style.height = '90vh';\n\n    const desktopIconMacro = `<img class=\"smallSvgIcon\" src=\"${desktopIcon}\">`;\n    const mobileIconMacro = `<img class=\"smallSvgIcon\" src=\"${mobileIcon}\">`;\n\n    // TODO move this to translations\n    const intro = createCollapsibleBlock(t('intro.introHeader'),\n        `<div style=\"width:100%;text-align:center;\"><img src=\"./img/goroxels.png\" style=\"vertical-align: middle;\">${t('intro.desc')}</div><br><br>\n    ${t('intro.desc2')}`, false);\n\n    const howto = createCollapsibleBlock(t('how to play?'),\n        `<div style=\"display:inline-flex\">\n            <div>${t('intro.howToPlayDecs')}</div>\n            <div style=\"padding-left: 10px;\">\n                <div class=\"desktop\">\n                <video autoplay loop muted style=\"height:196px\"><source src=\"./video/clickerMouse.webm\" type=\"video/webm\"></video>\n                </div>\n                <div class=\"mobile\">\n                <video autoplay loop muted style=\"height:196px\"><source src=\"./video/phoneDrawing.mp4\" type=\"video/mp4\"></video>\n                </div>\n            </div>\n        </div>`);\n\n    const tools = createCollapsibleBlock(t('tools'),\n        `${t('intro.toolsDecs')}<br><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.toolsClicker')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/clicker.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${t('intro.toolsAS')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/as.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${t('intro.toolC')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/toolC.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.brush')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/brush2.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.line')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/line.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.flood')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/flood.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.grid')}<br><br></div>\n        <div class=\"desktop\">\n            <img src=\"./img/unavailable.png\" style=\"height:196px\">\n        </div>\n    </div><br>\n    <div class=\"helpWithVideoCont\">\n        <div>${desktopIconMacro}${mobileIconMacro}${t('intro.ctrlZ')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/ctrlZ.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>\n    ${desktopIconMacro}${mobileIconMacro}${t('intro.resetColors')}<br>`);\n\n    const tools2 = createCollapsibleBlock(t('intro.tools2header'),\n        `<div style=\"width:100%;text-align:center;\"><b>${t('intro.tools2desc')}</b></div><br><br>\n    ${desktopIconMacro}${t('intro.toolsHiders')}<br><br>\n    ${desktopIconMacro}${mobileIconMacro}${t('intro.multicol')}<br>\n    ${t('intro.multicol2')}<br>\n    ${t('intro.multicol3')}<br><br>\n    ${desktopIconMacro}${t('intro.sendCoords')}<br><br>\n    ${desktopIconMacro}${t('intro.templateTools')}<br>`);\n\n    const template = createCollapsibleBlock(t('template'),\n        `<div style=\"width:100%;text-align:center;\"><b>${t('intro.templateIntro')}</b></div><br><br>\n    ${t('intro.templateDesc')}<br><br>\n    ${t('intro.templateDescConvert')}<br><br>\n    <div class=\"helpWithVideoCont mobile\">\n        <video autoplay loop muted style=\"height:196px\"><source src=\"./video/patternDemo.webm\" type=\"video/webm\"></video>\n    </div>\n    <div class=\"helpWithVideoCont\">\n        <div>${t('intro.templateDescReminder')}<br><br></div>\n        <div class=\"desktop\">\n            <video autoplay loop muted style=\"height:196px\"><source src=\"./video/patternDemo.webm\" type=\"video/webm\"></video>\n        </div>\n    </div><br>`);\n\n    const author = createCollapsibleBlock(t('intro.authorHeader'),\n        `${t('intro.authorText')}<br>\n        ${t('intro.authorContacts')}<br>\n        ${t('intro.telegram_channel')}: <a href=\"https://t.me/goroxels\">t.me/goroxels</a><br>\n        ${t('intro.my_boosty')} <a href=\"https://boosty.to/gorox\">https://boosty.to/gorox</a>\n        <div style=\"text-align:center\"><img src=\"./img/3rdcf.png\" title=\" \"></div>`);\n\n\n    $(helpWin.body).append(intro, howto, tools, tools2, template, author);\n}\n\nexport function onlineViewWindow(json) {\n    let win = new Window({\n        title: capitalize(t('online')),\n        center: true,\n        closeable: true\n    });\n\n    if (!win.created) {\n        win = win.oldWindow;\n    }\n\n    win.body.style.width = '325px';\n    win.moveToCenter();\n\n    const tableArr = [];\n    Object.keys(json).forEach(key => {\n        if (key === 'TOTAL') {\n            win.updateTitle(t('online') + ` (${json[key]})`, true);\n            return;\n        }\n\n        const firstEl = `<a href=\"/${key}\" target=\"_shagorox\"><h3>${key}<h3></a>`;\n        const secondEl = `<h2>${json[key]}</h2>`;\n\n        tableArr.push([firstEl, secondEl]);\n    })\n\n    const table = generateTable(tableArr);\n\n    $('*', win.body).remove();\n    $(win.body).append(table);\n}\n\nexport function templatesWindow(templatesJson) {\n    let win = new Window({\n        title: capitalize(t('templates_title')),\n        center: true,\n        closeable: true\n    });\n\n    if (!win.created) {\n        return;\n    }\n\n    win.body.classList.add('templatesBody');\n    win.body.style.maxWidth = 'min(495px, 90vw)'; // 5 items\n    if (globals.mobile) {\n        win.body.style.justifyContent = 'space-evenly';\n    }\n\n    const templatesJsonSorted = templatesJson\n        .slice()\n        .sort((a, b) => {\n            const aIsMine = me.id === a.userId;\n            const bIsMine = me.id === b.userId;\n\n            if (aIsMine !== bIsMine) {\n                return aIsMine ? 1 : -1;\n            }\n\n            return new Date(a.createdAt) - new Date(b.createdAt);\n        });\n\n    const meAdmin = me.role === ROLE.ADMIN;\n    for (const tempJson of templatesJsonSorted) {\n        const meOwner = me.id === tempJson.userId;\n        const canDelete = meOwner || meAdmin;\n\n        const templateThumbLink = `api/template/img?t=thumb&f=${tempJson.thumb}`;\n\n        const templateEl = $(\n            `<div class=\"templateItem ${meOwner ? 'myTemplateItem' : ''}\">\n                ${canDelete ? '<button class=\"templateBtn deleteBtn\"></button>' : ''}\n                <button class=\"templateBtn infoBtn\">i</button>\n                <img src=\"${templateThumbLink}\" alt=\"thumbnail\">\n                <div class=\"templateName\">${tempJson.name}</div>\n            </div>`\n        );\n\n        $(win.body).prepend(templateEl);\n\n        templateEl.find('.deleteBtn').on('click', async e => {\n            e.stopPropagation();\n\n            new ConfirmModal(t('confirm_template_deletion'), async (confirmed) => {\n                if (!confirmed) return;\n                const resp = await apiRequest(`/template/del?name=${encodeURIComponent(tempJson.name)}`, { method: 'POST' });\n                const data = await resp.json();\n                if (data.success) {\n                    templateEl.remove();\n                }\n            })\n        });\n\n        templateEl.find('.infoBtn').on('click', async e => {\n            e.stopPropagation();\n\n            let ownerName = '???';\n            try {\n                const resp = await apiRequest(`/userInfo?id=${tempJson.userId}`);\n                const data = await resp.json();\n                if (data && data.name) {\n                    ownerName = htmlspecialchars(data.name);\n                }\n            } catch (e) {\n                console.error('  userInfo', e);\n            }\n\n            const isMine = me.id === tempJson.userId;\n            const createdDate = new Date(tempJson.createdAt).toLocaleString();\n\n            const infoWin = new Window({\n                title: capitalize(t('template_info')),\n                center: true,\n                closeable: true\n            });\n\n            if (!infoWin.created) return;\n\n            infoWin.body.style.width = '280px';\n            infoWin.body.innerHTML = `\n                <ul class=\"templateInfoList\">\n                    <li><b>${t('name')}:</b> ${tempJson.name}</li>\n                    <li><b>${t('createdAt')}:</b> ${createdDate}</li>\n                    <li><b>${t('owner')}:</b> ${ownerName}</li>\n                    <li><b>${t('isMine')}:</b> ${isMine ? t('yes') : t('no')}</li>\n                    <li><b>${t('public')}:</b> ${tempJson.public ? t('yes') : t('no')}</li>\n                </ul>\n            `;\n        });\n\n\n        templateEl.on('click', () => {\n            let imgLink = `GRX/f=${tempJson.file}`;\n            if (tempJson.origWidth) {\n                imgLink += `&w=${tempJson.origWidth}`;\n            }\n\n            urlInput.val(imgLink);\n            updateTemplate();\n        })\n    }\n}\n\n\n","export default __webpack_public_path__ + \"/video/as.webm\";","export default __webpack_public_path__ + \"/video/brush.webm\";","export default __webpack_public_path__ + \"/video/brush2.webm\";","export default __webpack_public_path__ + \"/video/clicker.webm\";","export default __webpack_public_path__ + \"/video/clickerMouse.webm\";","export default __webpack_public_path__ + \"/video/ctrlZ.webm\";","export default __webpack_public_path__ + \"/video/flood.webm\";","export default __webpack_public_path__ + \"/video/line.webm\";","export default __webpack_public_path__ + \"/video/patternDemo.webm\";","export default __webpack_public_path__ + \"/video/phoneDrawing.mp4\";","export default __webpack_public_path__ + \"/video/toolC.webm\";","const compressWorker = {\r\n    worker: new Worker(new URL('./compress.worker.js', import.meta.url)),\r\n\r\n    decompress: async (imUint8Arr) => {\r\n        return new Promise((res, rej) => {\r\n            let timeout = setTimeout(onerror.bind(this, 'timeout'), 10_000);\r\n\r\n            const taskId = Math.random();\r\n            compressWorker.worker.postMessage(\r\n                { data: imUint8Arr, level: 2, id: taskId},\r\n                [imUint8Arr.buffer]\r\n            );\r\n\r\n            compressWorker.worker.addEventListener('message', onmessage);\r\n            compressWorker.worker.addEventListener('error', onerror);\r\n\r\n            function onerror(err){\r\n                cleanup();\r\n\r\n                rej(err);\r\n            }\r\n            function onmessage(e){\r\n                if(e.data.id !== taskId) return;\r\n\r\n                cleanup();\r\n                res(e.data.decompressed);\r\n            }\r\n            function cleanup(){\r\n                compressWorker.worker.removeEventListener('message', onmessage);\r\n                compressWorker.worker.removeEventListener('error', onerror);\r\n\r\n                clearTimeout(timeout);\r\n            }\r\n        })\r\n    }\r\n}\r\nwindow.wowo = compressWorker;\r\n\r\nexport default {\r\n    compressWorker\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + \"93a7211f658dcb611f30\" + \".bundle.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"\";","__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"game\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkgoroxels_client\"] = self[\"webpackChunkgoroxels_client\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors\",\"penis\"], () => (__webpack_require__(\"./src/js/main.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"ignoreList":[],"sourceRoot":""}