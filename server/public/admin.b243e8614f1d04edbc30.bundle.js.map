{"version":3,"file":"admin.b243e8614f1d04edbc30.bundle.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;ACAA,iEAAe,qBAAuB,iBAAiB,E;;;;;;;;;;;;;;;;;;;;ACAvD;;AAE6B;AACH;AAC4B;;AAEjB;AACQ;AACT;;;AAGpC;;AAEA;AACA,kBAAkB,kDAAqB;;AAEvC;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,MAAM;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,CAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAI,CAAC;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C,yBAAyB,sBAAsB;AAC/C,2BAA2B,GAAG,GAAG,GAAG;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,CAAC;AACd,YAAY,CAAC;AACb;AACA;;AAEA,yBAAyB,CAAC;AAC1B,yBAAyB,CAAC;AAC1B,uBAAuB,CAAC;AACxB,uBAAuB,CAAC;;AAExB;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA,YAAY,CAAC;AACb;;AAEA;AACA;AACA,YAAY,CAAC;AACb;AACA;AACA;AACA,YAAY,CAAC;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;;AAEA;;AAEA,QAAQ,CAAC;;AAET;AACA,kCAAkC,IAAI;AACtC,YAAY,CAAC;AACb;;AAEA,QAAQ,CAAC;;AAET;AACA;;AAEA;AACA,kEAAkE,aAAa;AAC/E;;AAEA,QAAQ,CAAC;;AAET;AACA,yCAAyC,KAAK,IAAI,wBAAwB;AAC1E,YAAY,CAAC;AACb;;AAEA,QAAQ,CAAC;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,CAAC;AAChC;AACA;;AAEA,oEAAoE,mBAAmB;AACvF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,CAAC;;AAExB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD,0DAAU;;AAE/D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC,UAAU;AAC3C;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,SAAS;AACtC,iCAAiC,SAAS;AAC1C,+BAA+B,UAAU,IAAI,UAAU;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,CAAC;AACT,QAAQ,CAAC,4BAA4B,CAAC;AACtC,QAAQ,CAAC;;AAET;AACA,QAAQ,CAAC;AACT;;AAEA;AACA,eAAe,CAAC;AAChB;;AAEA;AACA,eAAe,CAAC;AAChB;;AAEA;AACA,eAAe,CAAC;AAChB;;AAEA;AACA,eAAe,CAAC;AAChB;;AAEA;AACA,aAAa,CAAC;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI,CAAC;AACL,2CAA2C,CAAC;AAC5C;AACA,KAAK;;AAEL;AACA,IAAI,CAAC;AACL,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EA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,QAAQ,MAAM;AACd,eAAe,MAAM;AACrB;AACA;AACA,kBAAkB,4CAAI;AACtB;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,4CAAI;AACjB,YAAY,CAAC;AACb,aAAa,4CAAI;AACjB,YAAY,CAAC;AACb;AACA;AACA,gBAAgB,CAAC;AACjB;AACA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA,QAAQ,CAAC;AACT,8BAA8B,EAAE,IAAI,0BAA0B,GAAG,YAAY;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,G;;;;;;UCjyBD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WC/BA;WACA;WACA,E;;;;;WCFA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,E;;;;;WC3BA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;WCNA,2B;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA,4G;;;;;UEhDA;UACA;UACA;UACA;UACA","sources":["webpack://goroxels-client/./src/css/waiter.css","webpack://goroxels-client/./src/img/sha.jpg","webpack://goroxels-client/./src/js/admin/main.js","webpack://goroxels-client/webpack/bootstrap","webpack://goroxels-client/webpack/runtime/amd define","webpack://goroxels-client/webpack/runtime/chunk loaded","webpack://goroxels-client/webpack/runtime/compat get default export","webpack://goroxels-client/webpack/runtime/define property getters","webpack://goroxels-client/webpack/runtime/hasOwnProperty shorthand","webpack://goroxels-client/webpack/runtime/make namespace object","webpack://goroxels-client/webpack/runtime/publicPath","webpack://goroxels-client/webpack/runtime/jsonp chunk loading","webpack://goroxels-client/webpack/before-startup","webpack://goroxels-client/webpack/startup","webpack://goroxels-client/webpack/after-startup"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","export default __webpack_public_path__ + \"/img/sha.jpg\";","// TODO add protected pixels support\n\nimport '../../css/waiter.css'\nimport '../../img/sha.jpg'\nimport '../../../node_modules/toastr/build/toastr.css'\n\nimport querystring from 'querystring'\nimport { rgb2uint32 } from '../convert/color'\nimport { ROLE } from '../constants';\n\n\nlet canvases;\n\nasync function apiRequest(path, args, isPost = false, isBinary = false) {\n    const query = querystring.stringify(args)\n\n    const resp = await fetch('/api/' + path + '?' + query, {\n        method: isPost ? 'POST' : 'GET'\n    });\n\n    if (resp.headers.get('Content-Type').startsWith('plain/binary') || isBinary) {\n        return await resp.arrayBuffer();\n    }\n    const json = await resp.json();\n\n    if (json.errors) {\n        json.errors.forEach(e => toastr.error(e));\n        return null\n    }\n\n    return json\n}\n\n// returns cancelAnimation callback\nfunction addWaiter(container) {\n    const el =\n        $(`<div class=\"waitContainer\" style=\"opacity: 0\">\n        <div class=\"waitElement\">\n            <div class=\"waitShape\"></div>\n            <div class=\"waitShape\"></div>\n            <div class=\"waitShape\"></div>\n            <div class=\"waitShape\"></div>\n        </div>\n    </div>`);\n\n    const rect = container.getBoundingClientRect();\n\n    $(container).append(el);\n\n    el.css('top', rect.top)\n        .css('left', rect.left)\n        .css('width', rect.width)\n        .css('height', rect.height);\n\n    setTimeout(() => {\n        el.css('opacity', 1);\n    })\n\n    return () => {\n        el.remove();\n    }\n}\n\nfunction parseBackupResponse(respAB) {\n    const respUI8 = new Uint8Array(respAB);\n\n    let curChar, currentOffset = 0;\n    while (curChar !== 0) {\n        curChar = respUI8[currentOffset++];\n        if (currentOffset > 0xffff) {\n            throw new Error('Metadata length is too long, aborting');\n        }\n    }\n\n    const metadataText = new TextDecoder().decode(respUI8.subarray(0, currentOffset - 1));\n\n    const metadata = JSON.parse(metadataText);\n\n    const chunkLength = metadata.chunkSize ** 2;\n\n    const chunks = {};\n    for (let cx = 0; cx < metadata.width; cx++) {\n        for (let cy = 0; cy < metadata.height; cy++) {\n            const key = `${cx},${cy}`;\n            const localOffset = chunkLength * (cx + cy * metadata.width)\n            const offset = currentOffset + localOffset;\n            chunks[key] = respUI8.subarray(offset, offset + chunkLength);\n        }\n    }\n\n    return {\n        metadata, chunks\n    }\n}\n\nasync function initBackup() {\n    function getCropVals() {\n        if (!$(\"#cropCB\").is(':checked')) {\n            $('#cropXStart,#cropYStart,#cropXEnd,#cropYEnd').removeAttr('placeholder');\n            return null\n        };\n\n        let cropXstart = $('#cropXStart').val();\n        let cropYstart = $('#cropYStart').val();\n        let cropXend = $('#cropXEnd').val();\n        let cropYend = $('#cropYEnd').val();\n\n        if (!cropXstart.length) {\n            cropXstart = 0;\n            $('#cropXStart').attr('placeholder', cropXstart);\n        }\n        if (!cropYstart.length) {\n            cropYstart = 0;\n            $('#cropYStart').attr('placeholder', cropYstart);\n        }\n\n        if (!cropXend.length) {\n            cropXend = cropXstart\n            $('#cropXEnd').attr('placeholder', cropXend);\n        }\n        if (!cropYend.length) {\n            cropYend = cropYstart\n            $('#cropYEnd').attr('placeholder', cropYend);\n        }\n\n        cropXstart = +cropXstart;\n        cropXend = +cropXend;\n        cropYstart = +cropYstart;\n        cropYend = +cropYend;\n\n        if (cropXstart < 0 || cropXstart > cropXend ||\n            cropYstart < 0 || cropYstart > cropYend) {\n            return null\n        }\n\n        return {\n            cropXstart, cropXend,\n            cropYstart, cropYend\n        }\n    }\n    async function updateDays(canvas) {\n        let days = await apiRequest('admin/backup/getDays', { canvas });\n        if (!days) return false;\n\n        days = sortDates(days);\n\n        $('#dateSelect option').remove();\n\n        for (let day of days) {\n            const el = `<option>${day}</option>`;\n            $('#dateSelect').append(el);\n        }\n\n        $('#dateSelect option:last-child').attr('selected', true);\n\n        return days\n    }\n\n    async function updateTimes(canvas, day) {\n        const times = await apiRequest('admin/backup/getTimes', { canvas, day })\n        if (!times) return false;\n\n        $('#timeSelect option').remove();\n\n        for (let time of times) {\n            const el = `<option value=\"${time}\">${time.replace(/-/g, ':')}</option>`;\n            $('#timeSelect').append(el);\n        }\n\n        $('#timeSelect option:last-child').attr('selected', true);\n\n        return times\n    }\n\n    let lastData = {};\n    async function updateBackup(canvas, day, time, forceUpdate) {\n        // TODO cache rendered and uncompressed canvas instead?\n        let waiterCB = null;\n        if (forceUpdate) {\n            const canvasCont = $('#bkCanvasWrapper')[0]\n            if (canvasCont)\n                waiterCB = addWaiter(canvasCont);\n\n            let resp = await apiRequest('admin/backup/getBackup', { canvas, day, time }, false, true);\n            if (!resp) return;\n\n            lastData = parseBackupResponse(resp);\n        }\n\n        const timer = Date.now();\n        renderBackup(lastData.chunks, lastData.metadata, getCurrentChunkCrop(), isUseGrid());\n        console.log('renderBackup in ' + (Date.now() - timer));\n        createZoomView($('#bkCanvasWrapper>canvas')[0]);\n\n        if (waiterCB) {\n            waiterCB();\n        }\n    }\n\n    function renderBackup(chunks, metadata, crop, useGrid) {\n        const chunkSize = metadata.chunkSize;\n\n        let width = chunkSize * metadata.width,\n            height = chunkSize * metadata.height;\n\n        let offX = 0,\n            offY = 0;\n\n        if (crop !== null) {\n            crop.startX = Math.min(metadata.width, crop.startX);\n            crop.startY = Math.min(metadata.height, crop.startY);\n            crop.endX = Math.min(metadata.width, crop.endX);\n            crop.endY = Math.min(metadata.height, crop.endY);\n\n            offX = -(crop.startX * chunkSize);\n            offY = -(crop.startY * chunkSize);\n\n            width = ((crop.endX + 1) - crop.startX) * chunkSize;\n            height = ((crop.endY + 1) - crop.startY) * chunkSize;\n        }\n\n        const encodedPal = metadata.palette.map(x => rgb2uint32(x));\n\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n        const imgData = ctx.createImageData(width, height);\n        const u32a = new Uint32Array(imgData.data.buffer);\n\n        Object.keys(chunks).forEach(chunkId => {\n            const [cx, cy] = chunkId.split(',').map(x => +x);\n            if (crop !== null) {\n                if (cx < crop.startX || cx > crop.endX ||\n                    cy < crop.startY || cy > crop.endY) {\n                    return\n                }\n            }\n\n            let rawData = chunks[chunkId];\n\n            let color, i = 0, j, preY;\n\n            const startX = cx * chunkSize + offX,\n                endX = startX + chunkSize;\n            const startY = cy * chunkSize + offY,\n                endY = startY + chunkSize;\n\n            for (let y = startY; y < endY; y++) {\n                preY = y * width\n                for (let x = startX; x < endX; x++) {\n                    if (x < 3 && y == 0) {\n                        console.log({\n                            x, y,\n                            rdn: rawData[i] & 0x7F,\n                            rd: rawData[i]\n                        })\n                    }\n                    color = encodedPal[rawData[i++] & 0x7F];\n                    j = x + preY;\n\n                    u32a[j] = color;\n                }\n            }\n        })\n\n        ctx.putImageData(imgData, 0, 0);\n\n        if (useGrid) {\n            ctx.beginPath();\n\n            ctx.strokeStyle = 'red';\n            ctx.lineWidth = 3;\n            ctx.setLineDash([ctx.lineWidth / 0.75, ctx.lineWidth / 0.66666]);\n\n            for (let y = chunkSize; y < height - 1; y += chunkSize) {\n                ctx.moveTo(0, y);\n                ctx.lineTo(width - 1, y);\n            }\n            for (let x = chunkSize; x < width - 1; x += chunkSize) {\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, height - 1);\n            }\n\n            ctx.stroke();\n            ctx.closePath();\n\n            ctx.setLineDash([]);\n\n            const halfChunk = chunkSize / 2,\n                fontHei = chunkSize / 4;\n            ctx.font = fontHei + 'px sans-serif';\n            ctx.fillStyle = 'red'\n            ctx.strokeStyle = 'white';\n\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.lineWidth = fontHei / 6;\n\n            let text,\n                offx = 0, offy = 0;\n            if (crop) {\n                offx = crop.startX || 0;\n                offy = crop.startY || 0;\n            }\n\n            const cw = canvas.width / chunkSize,\n                ch = canvas.height / chunkSize;\n            for (let cy = 0; cy < ch; cy++) {\n                for (let cx = 0; cx < cw; cx++) {\n                    text = `(${cx + offx}, ${cy + offy})`;\n\n                    let x = (cx * chunkSize) + halfChunk,\n                        y = (cy * chunkSize) + halfChunk;\n\n                    ctx.strokeText(text, x, y);\n                    ctx.fillText(text, x, y);\n                }\n            }\n        }\n\n        $('#backupContainer *').remove();\n        $('#backupContainer').append($('<div id=\"bkCanvasWrapper\">'));\n        $('#bkCanvasWrapper').append(canvas);\n\n        // убрать\n        $('body').scrollTop(999);\n    }\n\n    function getCurrentCanvas() {\n        return $('#buCanvasSelect').val()\n    }\n\n    function getCurrentDay() {\n        return $('#dateSelect').val()\n    }\n\n    function getCurrentTime() {\n        return $('#timeSelect').val()\n    }\n\n    function isUseGrid() {\n        return $('#gridCB').is(':checked')\n    }\n\n    function getCurrentChunkCrop() {\n        if (!$(\"#cropCB\").is(':checked')) return null;\n\n        const vals = getCropVals();\n        if (!vals) {\n            return null;\n        }\n\n        const {\n            cropXstart, cropXend,\n            cropYstart, cropYend\n        } = vals;\n\n\n        return {\n            startX: cropXstart,\n            startY: cropYstart,\n            endX: cropXend,\n            endY: cropYend\n        }\n    }\n\n    async function initialRequest() {\n        await onCanvasUpdated();\n    }\n\n    function onSomethingChanged(forceUpdate) {\n        const curCanvas = getCurrentCanvas();\n        const curDay = getCurrentDay();\n        const curTime = getCurrentTime();\n\n        if ([curCanvas, curDay, curTime].some(x => x == \"\")) {\n            return\n        }\n\n        updateBackup(curCanvas, curDay, curTime, forceUpdate);\n    }\n\n    async function onCanvasUpdated() {\n        const canvas = getCurrentCanvas();\n\n        const days = await updateDays(canvas),\n            day = days[days.length - 1];\n        const times = await updateTimes(canvas, day),\n            time = times[times.length - 1]\n\n        await updateBackup(canvas, day, time, true);\n    }\n\n    $('#gridCB, #cropCB, #timeSelect, .cropInput').on('change', e => {\n        if (e.className == 'cropInput' && !$(\"#cropCB\").is(':checked')) return;\n        onSomethingChanged(e.target.id === 'timeSelect');\n    });\n\n    // just to add and remove \"disabled\" attr from/to rollback checkbock\n    $('#cropCB').on('change', () => {\n        const enabled = $(\"#cropCB\").is(':checked');\n        if (enabled)\n            $('#cropRollbackCB').removeAttr('disabled');\n        else\n            $('#cropRollbackCB').attr('disabled', '');\n    })\n\n    $('#buCanvasSelect').on('change', onCanvasUpdated);\n    $('#dateSelect').on('change', async () => {\n        await updateTimes(getCurrentCanvas(), getCurrentDay());\n        onSomethingChanged(true);\n    });\n\n    function sortDates(dates) {\n        return dates.sort((a, b) => {\n            return dateToInt(a) - dateToInt(b)\n        });\n    }\n\n    function dateToInt(date) {\n        const [\n            day,\n            month,\n            year\n        ] = date.split('.').map(x => parseInt(x, 10));\n\n        let int = 0;\n\n        int += year * 365;\n        int += month * 31;\n        int += day;\n\n        return int\n    }\n\n    $('#rollback').on('click', async () => {\n        const canvas = getCurrentCanvas();\n        const day = getCurrentDay();\n        const time = getCurrentTime();\n        const crop = getCurrentChunkCrop();\n\n        if ([canvas, day, time].some(x => x == \"\")) {\n            return\n        }\n\n        const cropEnabled = crop && $(\"#cropRollbackCB\").is(':checked');\n\n        if (!cropEnabled) {\n            alert('Ебанулся?');\n            return;\n        }\n\n        // let p = prompt('Are you sure?');\n        // if(p == null) return;\n\n        const resp = await apiRequest('/admin/backup/rollback', {\n            canvas, day, time,\n            crop: cropEnabled ? [crop.startX, crop.startY, crop.endX, crop.endY].join(',') : ''\n        }, true);\n        const json = await resp.json();\n        if (json.success) toastr.success('Rollbacked!');\n        else toastr.error(json.errors);\n    })\n\n    initialRequest().catch(e => {\n        console.error(e);\n        toastr.error(e);\n    });\n}\n\nfunction initIP() {\n    $('#sendIps').on('click', async () => {\n        const act = $('input[name=\"ipAction\"]:checked').val();\n        let ips = $('#ips').val();\n\n        ips = ips.split('\\n');\n\n        if (ips.length == 0) {\n            toastr.error('All ips are invalid');\n            return\n        }\n\n        const resp = await fetch('/api/admin/ip', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({ ips, action: act })\n        });\n        const json = await resp.json();\n\n        for (let error of json.errors)\n            toastr.error(error);\n\n        if (json.success) toastr.success('Success');\n        else toastr.error('Bad luck');\n    })\n}\nfunction initOther() {\n    $('#sendCaptchaEnabled').on('click', async () => {\n        const state = $('#captchaState')[0].checked;\n\n        const resp = await fetch('/api/admin/config/captchaState', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({ state })\n        })\n\n        const json = await resp.json();\n        if (json.success) {\n            toastr.success('Success');\n        } else {\n            toastr.error('Failed');\n            console.log(json);\n        }\n    });\n\n    $('#sendJoinDelay').on('click', async () => {\n        const value = $('#joinDelay').val();\n        if (!value) return;\n\n        const parsed = parseInt(value, 10);\n        if (parsed < 0 || isNaN(parsed)) return;\n\n        const resp = await fetch('/api/admin/config/afterJoinDelay', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({ value: parsed })\n        })\n\n        const json = await resp.json();\n        if (json.success) {\n            toastr.success('Success');\n        } else {\n            toastr.error('Failed');\n            console.log(json);\n        }\n    });\n\n    initApplyMask();\n}\nfunction initApplyMask() {\n    const fileInp = $('#protectMaskFile');\n    let lastFile;\n    fileInp.on('change', e => {\n        if (fileInp[0].files.length) {\n            const file = fileInp[0].files[0];\n            lastFile = file;\n            $('label[for=protectMaskFile]').text(file.name);\n        } else {\n            $('label[for=protectMaskFile]').text('Choose image');\n        }\n    });\n\n    $('#submitProtectMask').on('click', async () => {\n        if (!lastFile) return;\n\n        const xOff = +$('#protectMaskXOff').val();\n        const yOff = +$('#protectMaskYOff').val();\n        if ([xOff, yOff].some(n => isNaN(n) || n < 0)) return;\n\n        const canvas = $('#pmCanvasSelect').val();\n\n        const img = await new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onload = e => {\n                const image = new Image();\n                image.onload = () => resolve(image);\n                image.onerror = reject;\n                image.src = e.target.result;\n            };\n            reader.onerror = reject;\n            reader.readAsDataURL(lastFile);\n        });\n\n        const tileSize = 500;\n        const tilesX = Math.ceil(img.width / tileSize);\n        const tilesY = Math.ceil(img.height / tileSize);\n        const total = tilesX * tilesY;\n        let done = 0;\n\n        let toast = toastr.info(`Uploading mask... (0 / ${total})`, \"Mask Upload\", {\n            timeOut: 0,\n            extendedTimeOut: 0,\n            closeButton: true,\n            tapToDismiss: false\n        });\n\n        const canvasEl = document.createElement('canvas');\n        const ctx = canvasEl.getContext('2d');\n\n        for (let ty = 0; ty < tilesY; ty++) {\n            for (let tx = 0; tx < tilesX; tx++) {\n                const sx = tx * tileSize;\n                const sy = ty * tileSize;\n                const w = Math.min(tileSize, img.width - sx);\n                const h = Math.min(tileSize, img.height - sy);\n\n                canvasEl.width = w;\n                canvasEl.height = h;\n                ctx.clearRect(0, 0, w, h);\n                ctx.drawImage(img, sx, sy, w, h, 0, 0, w, h);\n\n                const blob = await new Promise(res => canvasEl.toBlob(res, 'image/png'));\n                const fd = new FormData();\n                fd.append('x', xOff + sx);\n                fd.append('y', yOff + sy);\n                fd.append('canvas', canvas);\n                fd.append('img', blob, `chunk_${tx}_${ty}.png`);\n\n                const resp = await fetch('/api/admin/canvas/applyProtectMask', {\n                    method: 'POST',\n                    body: fd\n                });\n                const respJson = await resp.json();\n                respJson?.errors?.forEach(e => toastr.error(e));\n\n                done++;\n                if (toast && toast.find('.toast-message').length) {\n                    toast.find('.toast-message').text(`Uploading mask... (${done} / ${total})`);\n                }\n            }\n        }\n\n        toast.remove()\n        if (toast && toast.find('.toast-message').length) {\n            toast.find('.toast-message').text(`Upload complete! (${done} / ${total})`);\n        }\n        toastr.success(\"Protect mask applied successfully\");\n    });\n}\n\n\nfunction initCanvasActions() {\n    canvases.forEach((canv, id) => {\n        $('#selectActCanvas').append(`<option value=\"${id}\">${canv.name}</option>`);\n    })\n\n    $('#canvasAction').on('change', () => {\n        const act = $('#canvasAction').val();\n        // hide all (if will be more in future)\n        $('.hidden.enlargeConfig').addClass('hidden');\n        // and then show one\n        if (act === 'enlarge') {\n            $('.hidden.enlargeConfig').removeClass('hidden');\n        }\n    })\n\n    $('#doCanvasAction').on('click', async () => {\n        const act = $('#canvasAction').val();\n        if (!act) return;\n\n        const canv = $('#selectActCanvas').val();\n        if (!canv) return;\n\n        if (act === 'wipe')\n            await wipeCanvas(canv);\n        if (act === 'enlarge') {\n            const t = $('#enTop').val();\n            const r = $('#enRight').val();\n            const b = $('#enBot').val();\n            const l = $('#enLeft').val();\n\n            if ([t, r, b, l].some(x => x > 254))\n                return toastr.error('Max canvas size is 255!');\n            if ([t, r, b, l].some(x => x < 0))\n                return toastr.error('ENLARGE only, one way road');\n\n            await enlargeCanvas(canv, t, r, b, l);\n        }\n    })\n\n    async function wipeCanvas(id) {\n        await apiRequest('admin/canvas/wipe', {\n            canvas: id\n        }, true);\n        toastr.success('Canvas ' + canvases[id].name + ' wiped!')\n    }\n\n    async function enlargeCanvas(id, t, r, b, l) {\n        // TODO check for errors\n        await apiRequest('admin/canvas/enlarge', {\n            canvas: id,\n\n            top: t,\n            right: r,\n            bottom: b,\n            left: l\n        }, true);\n        toastr.success('Canvas ' + canvases[id].name + ' enlarged!')\n    }\n}\n\nasync function loadConfig() {\n    const resp = await fetch('/config.json');\n    return await resp.json();\n}\n\n/**\n * \n * @param {HTMLCanvasElement} canvas \n */\nfunction createZoomView(canvas) {\n    const size = 200;\n    const halfSize = size / 2 | 0;\n\n    $('#zoomedCanvasView').remove();\n\n    const zoomedViewCanvas = document.createElement('canvas');\n    zoomedViewCanvas.id = 'zoomedCanvasView';\n    zoomedViewCanvas.width = zoomedViewCanvas.height = size;\n    zoomedViewCanvas.style.cssText =\n        `border: 1px solid black; \\nposition: absolute; \\ndisplay: none`\n\n    document.body.appendChild(zoomedViewCanvas);\n\n    const ctx = zoomedViewCanvas.getContext('2d');\n    const origCtx = canvas.getContext('2d');\n\n    const rect = canvas.getBoundingClientRect();\n    const canvasSizeDiffX = canvas.width / rect.width;\n    const canvasSizeDiffY = canvas.height / rect.height;\n\n    canvas.addEventListener('mousemove', e => {\n        zoomedViewCanvas.style.display = ''\n\n        const posX = Math.max(e.offsetX, 0);\n        const posY = Math.max(e.offsetY, 0);\n\n        const cordX = posX * canvasSizeDiffX;\n        const cordY = posY * canvasSizeDiffY;\n\n        const leftBound = cordX - halfSize;\n        const topBound = cordY - halfSize;\n\n        const rightBound = cordX + halfSize;\n        const bottomBound = cordY + halfSize;\n\n        render(leftBound, topBound, rightBound, bottomBound);\n\n        zoomedViewCanvas.style.left = (e.clientX + 10) + 'px';\n        zoomedViewCanvas.style.top = (e.clientY + 10) + 'px';\n    });\n\n    canvas.addEventListener('mouseleave', () => {\n        zoomedViewCanvas.style.display = 'none';\n    });\n\n\n    function render(startX, startY, endX, endY) {\n        const imdata = origCtx.getImageData(startX, startY, endX - startX, endY - startY);\n        ctx.putImageData(imdata, 0, 0);\n    }\n}\n\n(async () => {\n    let resp;\n    try {\n        resp = await fetch('/api/me');\n    } catch (e) {\n        toastr.error(e)\n        return toastr.error('Error while fetching /api/me:')\n    }\n    const me = await resp.json();\n    if (me.role < ROLE.MOD) {\n        location.href = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ';\n        return\n    }\n\n    canvases = (await loadConfig()).canvases;\n\n    switch (me.role) {\n        case ROLE.ADMIN:\n            $('.admin').show();\n        case ROLE.MOD:\n            $('.mod').show();\n        default: {\n            if (me.id == 1) {\n                $('.superadmin').show();\n            }\n            break\n        }\n    }\n\n    for (let i = 0; i < canvases.length; i++) {\n        const canvas = canvases[i];\n        $('.canvasSelect').append(\n            `<option value=\"${i}\" ${i === 0 ? 'selected' : ''}>${canvas.name}</option>`\n        )\n    }\n\n    initBackup();\n    initIP();\n    initOther();\n    initCanvasActions()\n})()","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"admin\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkgoroxels_client\"] = self[\"webpackChunkgoroxels_client\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendors\",\"penis\"], () => (__webpack_require__(\"./src/js/admin/main.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"ignoreList":[],"sourceRoot":""}